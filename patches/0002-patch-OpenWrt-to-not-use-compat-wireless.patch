From ea34ff6af1e08e0e0d6ceef061f8c173ef0f2431 Mon Sep 17 00:00:00 2001
From: Vision Systems GmbH <contact@visionsystems.de>
Date: Fri, 31 Mar 2017 15:23:52 +0200
Subject: [PATCH] patch OpenWrt to not use compat-wireless

---
 package/kernel/mac80211/Makefile                   | 2622 +++++++++++---------
 package/kernel/mac80211/files/lib/wifi/mac80211.sh |    6 +-
 .../kernel/mac80211/patches/000-fix_kconfig.patch  |   14 -
 .../kernel/mac80211/patches/001-fix_build.patch    |  167 --
 .../mac80211/patches/002-change_allconfig.patch    |   64 -
 .../patches/003-remove_bogus_modparams.patch       |   34 -
 .../004-header-backport-GENL_UNS_ADMIN_PERM.patch  |   21 -
 ...kport-nla_put_u64_64bit-and-nla_put_64bit.patch |  158 --
 ...-rhashtable-backport-version-due-to-API-c.patch |   18 -
 .../007-fix_duplicate_skcipher_backport.patch      |   11 -
 .../mac80211/patches/010-disable_rfkill.patch      |   13 -
 .../mac80211/patches/030-rt2x00_options.patch      |   47 -
 .../mac80211/patches/040-brcmutil_option.patch     |    9 -
 .../mac80211/patches/050-lib80211_option.patch     |   30 -
 .../mac80211/patches/060-no_local_ssb_bcma.patch   |  132 -
 .../mac80211/patches/070-ath_common_config.patch   |    9 -
 .../100-remove-cryptoapi-dependencies.patch        |  370 ---
 .../110-mac80211_keep_keys_on_stop_ap.patch        |   12 -
 .../120-cfg80211_allow_perm_addr_change.patch      |   43 -
 .../patches/150-disable_addr_notifier.patch        |   67 -
 .../patches/201-ath5k-WAR-for-AR71xx-PCI-bug.patch |   38 -
 package/kernel/mac80211/patches/210-ap_scan.patch  |   11 -
 ...00-ath9k-force-rx_clear-when-disabling-rx.patch |   31 -
 ...mit-retries-for-powersave-response-frames.patch |  121 -
 ...k-interpret-requested-txpower-in-EIRP-dom.patch |   37 -
 ...211-mesh-flush-mesh-paths-unconditionally.patch |  146 --
 ...304-mac80211-fix-fast_tx-header-alignment.patch |   25 -
 ...d-fallback-for-devices-that-do-not-report.patch |   52 -
 ...d-eth_type_trans-back-for-PCIe-full-dongl.patch |   87 -
 ...mac-Fix-kernel-oops-in-failed-chip_attach.patch |   88 -
 ...ac-Fix-did-not-remove-int-handler-warning.patch |   83 -
 ...ac-rework-function-picking-free-BSS-index.patch |  119 -
 .../patches/351-0006-brcmfmac-use-kmemdup.patch    |   28 -
 ...d-field-storing-control-channel-to-the-st.patch |  244 --
 ...mac-support-get_channel-cfg80211-callback.patch |   94 -
 ...-print-errors-if-creating-interface-fails.patch |   59 -
 ...fix-setting-AP-channel-with-new-firmwares.patch |  114 -
 ...n-t-remove-interface-on-link-down-firmwar.patch |   60 -
 ...1-0012-brcmfmac-fix-skb-priority-handling.patch |   28 -
 ...vise-SDIO-error-message-in-brcmf_sdio_dri.patch |   27 -
 ...e-ndev-needed_headroom-to-reserve-additio.patch |   30 -
 ...d-support-for-the-PCIE-devices-43525-and-.patch |   66 -
 ...ange-rx_seq-check-log-from-error-print-to.patch |   30 -
 ...cmfmac-drop-unused-pm_block-vif-attribute.patch |  103 -
 ...ac-include-required-headers-in-cfg80211.h.patch |   37 -
 ...ightly-simplify-building-interface-combin.patch |  108 -
 ...x-lockup-when-removing-P2P-interface-afte.patch |  154 --
 ...e-const-char-for-interface-name-in-brcmf_.patch |   39 -
 ...-include-also-core.h-header-in-cfg80211.h.patch |   33 -
 ...dd-missing-break-when-deleting-P2P_DEVICE.patch |   27 -
 ...lete-interface-directly-in-code-that-sent.patch |   75 -
 ...pport-removing-AP-interfaces-with-interfa.patch |   84 -
 .../mac80211/patches/400-ath_move_debug_code.patch |   30 -
 .../mac80211/patches/401-ath9k_blink_default.patch |   11 -
 .../mac80211/patches/402-ath_regd_optional.patch   |   69 -
 .../mac80211/patches/403-world_regd_fixup.patch    |   84 -
 .../mac80211/patches/404-regd_no_assoc_hints.patch |   19 -
 .../kernel/mac80211/patches/405-ath_regd_us.patch  |   26 -
 .../patches/406-ath_relax_default_regd.patch       |   47 -
 .../patches/410-ath9k_allow_adhoc_and_ap.patch     |   10 -
 .../patches/411-ath5k_allow_adhoc_and_ap.patch     |   46 -
 .../patches/420-ath5k_disable_fast_cc.patch        |   18 -
 .../mac80211/patches/430-add_ath5k_platform.patch  |   33 -
 .../431-add_platform_eeprom_support_to_ath5k.patch |   56 -
 .../mac80211/patches/432-ath5k_add_pciids.patch    |   11 -
 .../patches/440-ath5k_channel_bw_debugfs.patch     |  143 --
 .../patches/500-ath9k_eeprom_debugfs.patch         |   65 -
 .../mac80211/patches/501-ath9k_ahb_init.patch      |   32 -
 .../patches/510-ath9k_intr_mitigation_tweak.patch  |   18 -
 .../mac80211/patches/511-ath9k_reduce_rxbuf.patch  |   11 -
 .../patches/512-ath9k_channelbw_debugfs.patch      |  125 -
 .../mac80211/patches/513-ath9k_add_pci_ids.patch   |   30 -
 .../522-mac80211_configure_antenna_gain.patch      |  160 --
 .../mac80211/patches/530-ath9k_extra_leds.patch    |  276 ---
 .../patches/531-ath9k_extra_platform_leds.patch    |   71 -
 ...ath9k_get_led_polarity_from_platform_data.patch |   20 -
 .../patches/540-ath9k_reduce_ani_interval.patch    |   11 -
 .../patches/541-ath9k_rx_dma_stop_check.patch      |   28 -
 .../mac80211/patches/542-ath9k_debugfs_diag.patch  |  139 --
 .../patches/543-ath9k_entropy_from_adc.patch       |  186 --
 .../544-ath9k-ar933x-usb-hang-workaround.patch     |   79 -
 .../mac80211/patches/545-ath9k_ani_ws_detect.patch |  155 --
 .../patches/546-ath9k_platform_led_name.patch      |   39 -
 .../patches/547-ath9k_led_defstate_fix.patch       |   29 -
 .../patches/548-ath9k_enable_gpio_chip.patch       |  237 --
 .../patches/549-ath9k_enable_gpio_buttons.patch    |  149 --
 .../patches/550-ath9k_add_ar9280_gpio_chip.patch   |   27 -
 ...00lib-move-rt2800_drv_data-declaration-in.patch |   66 -
 ...00lib-introduce-RT2800_HAS_HIGH_SHARED_ME.patch |   80 -
 ...x00-rt2800-serialize-shared-memory-access.patch |  531 ----
 ...rt2800lib-fix-beacon-generation-on-RT3593.patch |  131 -
 ...00lib-add-hw_beacon_count-field-to-struct.patch |   62 -
 ...00lib-init-additional-beacon-offset-regis.patch |   67 -
 ...00lib-fix-max-supported-beacon-count-for-.patch |   24 -
 ...llow-to-build-rt2800soc-module-for-RT3883.patch |   30 -
 ...t2x00-rt2800lib-enable-support-for-RT3883.patch |   20 -
 ...0-rt2x00-rt2800lib-add-rf_vals-for-RF3853.patch |  112 -
 ...2800lib-enable-VCO-calibration-for-RF3853.patch |   28 -
 ...00lib-add-channel-configuration-function-.patch |  235 --
 ...13-rt2x00-rt2800lib-enable-RF3853-support.patch |   20 -
 ...00lib-add-MAC-register-initialization-for.patch |   77 -
 ...00soc-fix-rt2800soc_disable_radio-for-RT3.patch |   30 -
 ...00lib-add-BBP-register-initialization-for.patch |   71 -
 ...00lib-add-RFCSR-initialization-for-RT3883.patch |  178 --
 ...00lib-use-the-extended-EEPROM-map-for-RT3.patch |   22 -
 ...2800lib-force-rf-type-to-RF3853-on-RT3883.patch |   21 -
 ...00lib-add-channel-configuration-code-for-.patch |  136 -
 ...00lib-fix-txpower_to_dev-function-for-RT3.patch |   30 -
 ...00lib-use-correct-txpower-calculation-fun.patch |   23 -
 ...00lib-hardcode-txmixer-gain-values-to-zer.patch |   33 -
 ...800lib-use-correct-RT-XWI-size-for-RT3883.patch |   20 -
 ...800lib-use-correct-beacon-base-for-RT3883.patch |   22 -
 ...00lib-use-correct-beacon-count-for-RT3883.patch |   22 -
 ...00lib-fix-antenna-configuration-for-RT388.patch |   22 -
 ...00lib-fix-LNA-gain-configuration-for-RT38.patch |   32 -
 ...rt2x00-rt2800lib-fix-VGC-setup-for-RT3883.patch |   44 -
 ...00lib-fix-EEPROM-LNA-validation-for-RT388.patch |   42 -
 ...00lib-fix-txpower-compensation-for-RT3883.patch |   22 -
 ...00lib-enable-RT2800_HAS_HIGH_SHARED_MEM-f.patch |   23 -
 ...00lib-use-high-memory-for-beacons-on-RT38.patch |   22 -
 ...00mmio-add-a-workaround-for-spurious-TX_F.patch |  136 -
 .../mac80211/patches/601-rt2x00-set_pci_mwi.patch  |   13 -
 .../602-rt2x00-introduce-rt2x00_platform_h.patch   |   32 -
 .../603-rt2x00-introduce-rt2x00eeprom.patch        |  301 ---
 .../604-rt2x00-of_load_eeprom_filename.patch       |   33 -
 ...-eeprom-on-SoC-from-a-mtd-device-defines-.patch |  101 -
 ...low_disabling_bands_through_platform_data.patch |   47 -
 .../patches/608-add_platform_data_mac_addr.patch   |   63 -
 ...-rt2x00-allow_disabling_bands_through_dts.patch |   27 -
 .../patches/610-rt2x00-fix-rt3352-ext-pa.patch     |  211 --
 .../patches/611-rt2x00-rf_vals-rt3352-xtal20.patch |  106 -
 ...e-wmac-loadable-via-OF-on-rt288x-305x-SoC.patch |   33 -
 .../patches/615-rt2x00-fix_20mhz_clk.patch         |   29 -
 .../patches/616-rt2x00-support-rt5350.patch        |  276 ---
 .../619-rt2x00-change-led-polarity-from-OF.patch   |   40 -
 .../patches/620-rt2x00-add-AP+STA-support.patch    |   11 -
 .../mac80211/patches/620-rt2x00-rt3352-rf-id.patch |   15 -
 .../mac80211/patches/621-rt2x00-ht20_40_fix.patch  |   29 -
 .../622-rt2x00-fix-beacon-bit-balance.patch        |   47 -
 .../700-mwl8k-missing-pci-id-for-WNR854T.patch     |   10 -
 .../801-libertas-configure-sysfs-links.patch       |   21 -
 .../802-libertas-set-wireless-macaddr.patch        |   11 -
 .../patches/805-b43-gpio-mask-module-option.patch  |   37 -
 .../kernel/mac80211/patches/810-b43_no_pio.patch   |   86 -
 .../patches/820-b43-add-antenna-control.patch      |  131 -
 .../841-b43-reduce-number-of-RX-slots.patch        |   11 -
 .../845-b43-only-use-gpio-0-1-for-led.patch        |   17 -
 .../847-b43-always-take-overlapping-devs.patch     |   11 -
 ...msmac-remove-extra-regulation-restriction.patch |   27 -
 ...mfmac-register-wiphy-s-during-module_init.patch |   97 -
 ...rkaround-bug-with-some-inconsistent-BSSes.patch |   50 -
 .../863-brcmfmac-Disable-power-management.patch    |   27 -
 ...910-00-rt2x00-enable-rt2800soc-for-mt7620.patch |   20 -
 .../patches/910-01-add-support-for-mt7620.patch    | 1202 ---------
 .../921-ath10k_init_devices_synchronously.patch    |   33 -
 .../patches/930-ath10k_add_tpt_led_trigger.patch   |   37 -
 .../patches/936-ath10k_skip_otp_check.patch        |   42 -
 .../940-mwl8k_init_devices_synchronously.patch     |   20 -
 ...rx_location_info-out-of-struct-rx_pkt_end.patch |   37 -
 ...wing-hw-checks-during-safe-and-full-reset.patch |  139 --
 ...3-4-ath10k-Define-rx_ppdu_end-for-QCA9984.patch |   89 -
 ...950-4-4-ath10k-Enable-support-for-QCA9984.patch |  171 --
 ...ath10k-fix-get-rx_status-from-htt-context.patch |   75 -
 163 files changed, 1463 insertions(+), 13401 deletions(-)
 delete mode 100644 package/kernel/mac80211/patches/000-fix_kconfig.patch
 delete mode 100644 package/kernel/mac80211/patches/001-fix_build.patch
 delete mode 100644 package/kernel/mac80211/patches/002-change_allconfig.patch
 delete mode 100644 package/kernel/mac80211/patches/003-remove_bogus_modparams.patch
 delete mode 100644 package/kernel/mac80211/patches/004-header-backport-GENL_UNS_ADMIN_PERM.patch
 delete mode 100644 package/kernel/mac80211/patches/005-header-backport-nla_put_u64_64bit-and-nla_put_64bit.patch
 delete mode 100644 package/kernel/mac80211/patches/006-compat-bump-rhashtable-backport-version-due-to-API-c.patch
 delete mode 100644 package/kernel/mac80211/patches/007-fix_duplicate_skcipher_backport.patch
 delete mode 100644 package/kernel/mac80211/patches/010-disable_rfkill.patch
 delete mode 100644 package/kernel/mac80211/patches/030-rt2x00_options.patch
 delete mode 100644 package/kernel/mac80211/patches/040-brcmutil_option.patch
 delete mode 100644 package/kernel/mac80211/patches/050-lib80211_option.patch
 delete mode 100644 package/kernel/mac80211/patches/060-no_local_ssb_bcma.patch
 delete mode 100644 package/kernel/mac80211/patches/070-ath_common_config.patch
 delete mode 100644 package/kernel/mac80211/patches/100-remove-cryptoapi-dependencies.patch
 delete mode 100644 package/kernel/mac80211/patches/110-mac80211_keep_keys_on_stop_ap.patch
 delete mode 100644 package/kernel/mac80211/patches/120-cfg80211_allow_perm_addr_change.patch
 delete mode 100644 package/kernel/mac80211/patches/150-disable_addr_notifier.patch
 delete mode 100644 package/kernel/mac80211/patches/201-ath5k-WAR-for-AR71xx-PCI-bug.patch
 delete mode 100644 package/kernel/mac80211/patches/210-ap_scan.patch
 delete mode 100644 package/kernel/mac80211/patches/300-ath9k-force-rx_clear-when-disabling-rx.patch
 delete mode 100644 package/kernel/mac80211/patches/301-ath9k-limit-retries-for-powersave-response-frames.patch
 delete mode 100644 package/kernel/mac80211/patches/302-Revert-ath9k-interpret-requested-txpower-in-EIRP-dom.patch
 delete mode 100644 package/kernel/mac80211/patches/303-mac80211-mesh-flush-mesh-paths-unconditionally.patch
 delete mode 100644 package/kernel/mac80211/patches/304-mac80211-fix-fast_tx-header-alignment.patch
 delete mode 100644 package/kernel/mac80211/patches/350-0001-brcmfmac-add-fallback-for-devices-that-do-not-report.patch
 delete mode 100644 package/kernel/mac80211/patches/350-0002-brcmfmac-add-eth_type_trans-back-for-PCIe-full-dongl.patch
 delete mode 100644 package/kernel/mac80211/patches/351-0003-brcmfmac-Fix-kernel-oops-in-failed-chip_attach.patch
 delete mode 100644 package/kernel/mac80211/patches/351-0004-brcmfmac-Fix-did-not-remove-int-handler-warning.patch
 delete mode 100644 package/kernel/mac80211/patches/351-0005-brcmfmac-rework-function-picking-free-BSS-index.patch
 delete mode 100644 package/kernel/mac80211/patches/351-0006-brcmfmac-use-kmemdup.patch
 delete mode 100644 package/kernel/mac80211/patches/351-0007-brcmutil-add-field-storing-control-channel-to-the-st.patch
 delete mode 100644 package/kernel/mac80211/patches/351-0008-brcmfmac-support-get_channel-cfg80211-callback.patch
 delete mode 100644 package/kernel/mac80211/patches/351-0009-brcmfmac-print-errors-if-creating-interface-fails.patch
 delete mode 100644 package/kernel/mac80211/patches/351-0010-brcmfmac-fix-setting-AP-channel-with-new-firmwares.patch
 delete mode 100644 package/kernel/mac80211/patches/351-0011-brcmfmac-don-t-remove-interface-on-link-down-firmwar.patch
 delete mode 100644 package/kernel/mac80211/patches/351-0012-brcmfmac-fix-skb-priority-handling.patch
 delete mode 100644 package/kernel/mac80211/patches/351-0013-brcmfmac-revise-SDIO-error-message-in-brcmf_sdio_dri.patch
 delete mode 100644 package/kernel/mac80211/patches/351-0014-brcmfmac-use-ndev-needed_headroom-to-reserve-additio.patch
 delete mode 100644 package/kernel/mac80211/patches/351-0015-brcmfmac-add-support-for-the-PCIE-devices-43525-and-.patch
 delete mode 100644 package/kernel/mac80211/patches/351-0016-brcmfmac-change-rx_seq-check-log-from-error-print-to.patch
 delete mode 100644 package/kernel/mac80211/patches/351-0017-brcmfmac-drop-unused-pm_block-vif-attribute.patch
 delete mode 100644 package/kernel/mac80211/patches/351-0018-brcmfmac-include-required-headers-in-cfg80211.h.patch
 delete mode 100644 package/kernel/mac80211/patches/351-0019-brcmfmac-slightly-simplify-building-interface-combin.patch
 delete mode 100644 package/kernel/mac80211/patches/351-0020-brcmfmac-fix-lockup-when-removing-P2P-interface-afte.patch
 delete mode 100644 package/kernel/mac80211/patches/351-0021-brcmfmac-use-const-char-for-interface-name-in-brcmf_.patch
 delete mode 100644 package/kernel/mac80211/patches/351-0022-brcmfmac-include-also-core.h-header-in-cfg80211.h.patch
 delete mode 100644 package/kernel/mac80211/patches/351-0023-brcmfmac-add-missing-break-when-deleting-P2P_DEVICE.patch
 delete mode 100644 package/kernel/mac80211/patches/352-0001-brcmfmac-delete-interface-directly-in-code-that-sent.patch
 delete mode 100644 package/kernel/mac80211/patches/352-0002-brcmfmac-support-removing-AP-interfaces-with-interfa.patch
 delete mode 100644 package/kernel/mac80211/patches/400-ath_move_debug_code.patch
 delete mode 100644 package/kernel/mac80211/patches/401-ath9k_blink_default.patch
 delete mode 100644 package/kernel/mac80211/patches/402-ath_regd_optional.patch
 delete mode 100644 package/kernel/mac80211/patches/403-world_regd_fixup.patch
 delete mode 100644 package/kernel/mac80211/patches/404-regd_no_assoc_hints.patch
 delete mode 100644 package/kernel/mac80211/patches/405-ath_regd_us.patch
 delete mode 100644 package/kernel/mac80211/patches/406-ath_relax_default_regd.patch
 delete mode 100644 package/kernel/mac80211/patches/410-ath9k_allow_adhoc_and_ap.patch
 delete mode 100644 package/kernel/mac80211/patches/411-ath5k_allow_adhoc_and_ap.patch
 delete mode 100644 package/kernel/mac80211/patches/420-ath5k_disable_fast_cc.patch
 delete mode 100644 package/kernel/mac80211/patches/430-add_ath5k_platform.patch
 delete mode 100644 package/kernel/mac80211/patches/431-add_platform_eeprom_support_to_ath5k.patch
 delete mode 100644 package/kernel/mac80211/patches/432-ath5k_add_pciids.patch
 delete mode 100644 package/kernel/mac80211/patches/440-ath5k_channel_bw_debugfs.patch
 delete mode 100644 package/kernel/mac80211/patches/500-ath9k_eeprom_debugfs.patch
 delete mode 100644 package/kernel/mac80211/patches/501-ath9k_ahb_init.patch
 delete mode 100644 package/kernel/mac80211/patches/510-ath9k_intr_mitigation_tweak.patch
 delete mode 100644 package/kernel/mac80211/patches/511-ath9k_reduce_rxbuf.patch
 delete mode 100644 package/kernel/mac80211/patches/512-ath9k_channelbw_debugfs.patch
 delete mode 100644 package/kernel/mac80211/patches/513-ath9k_add_pci_ids.patch
 delete mode 100644 package/kernel/mac80211/patches/522-mac80211_configure_antenna_gain.patch
 delete mode 100644 package/kernel/mac80211/patches/530-ath9k_extra_leds.patch
 delete mode 100644 package/kernel/mac80211/patches/531-ath9k_extra_platform_leds.patch
 delete mode 100644 package/kernel/mac80211/patches/532-ath9k_get_led_polarity_from_platform_data.patch
 delete mode 100644 package/kernel/mac80211/patches/540-ath9k_reduce_ani_interval.patch
 delete mode 100644 package/kernel/mac80211/patches/541-ath9k_rx_dma_stop_check.patch
 delete mode 100644 package/kernel/mac80211/patches/542-ath9k_debugfs_diag.patch
 delete mode 100644 package/kernel/mac80211/patches/543-ath9k_entropy_from_adc.patch
 delete mode 100644 package/kernel/mac80211/patches/544-ath9k-ar933x-usb-hang-workaround.patch
 delete mode 100644 package/kernel/mac80211/patches/545-ath9k_ani_ws_detect.patch
 delete mode 100644 package/kernel/mac80211/patches/546-ath9k_platform_led_name.patch
 delete mode 100644 package/kernel/mac80211/patches/547-ath9k_led_defstate_fix.patch
 delete mode 100644 package/kernel/mac80211/patches/548-ath9k_enable_gpio_chip.patch
 delete mode 100644 package/kernel/mac80211/patches/549-ath9k_enable_gpio_buttons.patch
 delete mode 100644 package/kernel/mac80211/patches/550-ath9k_add_ar9280_gpio_chip.patch
 delete mode 100644 package/kernel/mac80211/patches/600-0001-rt2x00-rt2800lib-move-rt2800_drv_data-declaration-in.patch
 delete mode 100644 package/kernel/mac80211/patches/600-0002-rt2x00-rt2800lib-introduce-RT2800_HAS_HIGH_SHARED_ME.patch
 delete mode 100644 package/kernel/mac80211/patches/600-0003-rt2x00-rt2800-serialize-shared-memory-access.patch
 delete mode 100644 package/kernel/mac80211/patches/600-0004-rt2x00-rt2800lib-fix-beacon-generation-on-RT3593.patch
 delete mode 100644 package/kernel/mac80211/patches/600-0005-rt2x00-rt2800lib-add-hw_beacon_count-field-to-struct.patch
 delete mode 100644 package/kernel/mac80211/patches/600-0006-rt2x00-rt2800lib-init-additional-beacon-offset-regis.patch
 delete mode 100644 package/kernel/mac80211/patches/600-0007-rt2x00-rt2800lib-fix-max-supported-beacon-count-for-.patch
 delete mode 100644 package/kernel/mac80211/patches/600-0008-rt2x00-allow-to-build-rt2800soc-module-for-RT3883.patch
 delete mode 100644 package/kernel/mac80211/patches/600-0009-rt2x00-rt2800lib-enable-support-for-RT3883.patch
 delete mode 100644 package/kernel/mac80211/patches/600-0010-rt2x00-rt2800lib-add-rf_vals-for-RF3853.patch
 delete mode 100644 package/kernel/mac80211/patches/600-0011-rt2x00-rt2800lib-enable-VCO-calibration-for-RF3853.patch
 delete mode 100644 package/kernel/mac80211/patches/600-0012-rt2x00-rt2800lib-add-channel-configuration-function-.patch
 delete mode 100644 package/kernel/mac80211/patches/600-0013-rt2x00-rt2800lib-enable-RF3853-support.patch
 delete mode 100644 package/kernel/mac80211/patches/600-0014-rt2x00-rt2800lib-add-MAC-register-initialization-for.patch
 delete mode 100644 package/kernel/mac80211/patches/600-0015-rt2x00-rt2800soc-fix-rt2800soc_disable_radio-for-RT3.patch
 delete mode 100644 package/kernel/mac80211/patches/600-0016-rt2x00-rt2800lib-add-BBP-register-initialization-for.patch
 delete mode 100644 package/kernel/mac80211/patches/600-0017-rt2x00-rt2800lib-add-RFCSR-initialization-for-RT3883.patch
 delete mode 100644 package/kernel/mac80211/patches/600-0018-rt2x00-rt2800lib-use-the-extended-EEPROM-map-for-RT3.patch
 delete mode 100644 package/kernel/mac80211/patches/600-0019-rt2x00-rt2800lib-force-rf-type-to-RF3853-on-RT3883.patch
 delete mode 100644 package/kernel/mac80211/patches/600-0020-rt2x00-rt2800lib-add-channel-configuration-code-for-.patch
 delete mode 100644 package/kernel/mac80211/patches/600-0021-rt2x00-rt2800lib-fix-txpower_to_dev-function-for-RT3.patch
 delete mode 100644 package/kernel/mac80211/patches/600-0022-rt2x00-rt2800lib-use-correct-txpower-calculation-fun.patch
 delete mode 100644 package/kernel/mac80211/patches/600-0023-rt2x00-rt2800lib-hardcode-txmixer-gain-values-to-zer.patch
 delete mode 100644 package/kernel/mac80211/patches/600-0024-rt2x00-rt2800lib-use-correct-RT-XWI-size-for-RT3883.patch
 delete mode 100644 package/kernel/mac80211/patches/600-0025-rt2x00-rt2800lib-use-correct-beacon-base-for-RT3883.patch
 delete mode 100644 package/kernel/mac80211/patches/600-0026-rt2x00-rt2800lib-use-correct-beacon-count-for-RT3883.patch
 delete mode 100644 package/kernel/mac80211/patches/600-0027-rt2x00-rt2800lib-fix-antenna-configuration-for-RT388.patch
 delete mode 100644 package/kernel/mac80211/patches/600-0028-rt2x00-rt2800lib-fix-LNA-gain-configuration-for-RT38.patch
 delete mode 100644 package/kernel/mac80211/patches/600-0029-rt2x00-rt2800lib-fix-VGC-setup-for-RT3883.patch
 delete mode 100644 package/kernel/mac80211/patches/600-0030-rt2x00-rt2800lib-fix-EEPROM-LNA-validation-for-RT388.patch
 delete mode 100644 package/kernel/mac80211/patches/600-0031-rt2x00-rt2800lib-fix-txpower-compensation-for-RT3883.patch
 delete mode 100644 package/kernel/mac80211/patches/600-0032-rt2x00-rt2800lib-enable-RT2800_HAS_HIGH_SHARED_MEM-f.patch
 delete mode 100644 package/kernel/mac80211/patches/600-0033-rt2x00-rt2800lib-use-high-memory-for-beacons-on-RT38.patch
 delete mode 100644 package/kernel/mac80211/patches/600-0034-rt2x00-rt2800mmio-add-a-workaround-for-spurious-TX_F.patch
 delete mode 100644 package/kernel/mac80211/patches/601-rt2x00-set_pci_mwi.patch
 delete mode 100644 package/kernel/mac80211/patches/602-rt2x00-introduce-rt2x00_platform_h.patch
 delete mode 100644 package/kernel/mac80211/patches/603-rt2x00-introduce-rt2x00eeprom.patch
 delete mode 100644 package/kernel/mac80211/patches/604-rt2x00-of_load_eeprom_filename.patch
 delete mode 100644 package/kernel/mac80211/patches/605-rt2x00-load-eeprom-on-SoC-from-a-mtd-device-defines-.patch
 delete mode 100644 package/kernel/mac80211/patches/607-rt2x00-allow_disabling_bands_through_platform_data.patch
 delete mode 100644 package/kernel/mac80211/patches/608-add_platform_data_mac_addr.patch
 delete mode 100644 package/kernel/mac80211/patches/609-rt2x00-allow_disabling_bands_through_dts.patch
 delete mode 100644 package/kernel/mac80211/patches/610-rt2x00-fix-rt3352-ext-pa.patch
 delete mode 100644 package/kernel/mac80211/patches/611-rt2x00-rf_vals-rt3352-xtal20.patch
 delete mode 100644 package/kernel/mac80211/patches/612-rt2x00-make-wmac-loadable-via-OF-on-rt288x-305x-SoC.patch
 delete mode 100644 package/kernel/mac80211/patches/615-rt2x00-fix_20mhz_clk.patch
 delete mode 100644 package/kernel/mac80211/patches/616-rt2x00-support-rt5350.patch
 delete mode 100644 package/kernel/mac80211/patches/619-rt2x00-change-led-polarity-from-OF.patch
 delete mode 100644 package/kernel/mac80211/patches/620-rt2x00-add-AP+STA-support.patch
 delete mode 100644 package/kernel/mac80211/patches/620-rt2x00-rt3352-rf-id.patch
 delete mode 100644 package/kernel/mac80211/patches/621-rt2x00-ht20_40_fix.patch
 delete mode 100644 package/kernel/mac80211/patches/622-rt2x00-fix-beacon-bit-balance.patch
 delete mode 100644 package/kernel/mac80211/patches/700-mwl8k-missing-pci-id-for-WNR854T.patch
 delete mode 100644 package/kernel/mac80211/patches/801-libertas-configure-sysfs-links.patch
 delete mode 100644 package/kernel/mac80211/patches/802-libertas-set-wireless-macaddr.patch
 delete mode 100644 package/kernel/mac80211/patches/805-b43-gpio-mask-module-option.patch
 delete mode 100644 package/kernel/mac80211/patches/810-b43_no_pio.patch
 delete mode 100644 package/kernel/mac80211/patches/820-b43-add-antenna-control.patch
 delete mode 100644 package/kernel/mac80211/patches/841-b43-reduce-number-of-RX-slots.patch
 delete mode 100644 package/kernel/mac80211/patches/845-b43-only-use-gpio-0-1-for-led.patch
 delete mode 100644 package/kernel/mac80211/patches/847-b43-always-take-overlapping-devs.patch
 delete mode 100644 package/kernel/mac80211/patches/850-brcmsmac-remove-extra-regulation-restriction.patch
 delete mode 100644 package/kernel/mac80211/patches/861-brcmfmac-register-wiphy-s-during-module_init.patch
 delete mode 100644 package/kernel/mac80211/patches/862-brcmfmac-workaround-bug-with-some-inconsistent-BSSes.patch
 delete mode 100644 package/kernel/mac80211/patches/863-brcmfmac-Disable-power-management.patch
 delete mode 100644 package/kernel/mac80211/patches/910-00-rt2x00-enable-rt2800soc-for-mt7620.patch
 delete mode 100644 package/kernel/mac80211/patches/910-01-add-support-for-mt7620.patch
 delete mode 100644 package/kernel/mac80211/patches/921-ath10k_init_devices_synchronously.patch
 delete mode 100644 package/kernel/mac80211/patches/930-ath10k_add_tpt_led_trigger.patch
 delete mode 100644 package/kernel/mac80211/patches/936-ath10k_skip_otp_check.patch
 delete mode 100644 package/kernel/mac80211/patches/940-mwl8k_init_devices_synchronously.patch
 delete mode 100644 package/kernel/mac80211/patches/950-1-4-ath10k-Move-rx_location_info-out-of-struct-rx_pkt_end.patch
 delete mode 100644 package/kernel/mac80211/patches/950-2-4-ath10k-Clean-up-growing-hw-checks-during-safe-and-full-reset.patch
 delete mode 100644 package/kernel/mac80211/patches/950-3-4-ath10k-Define-rx_ppdu_end-for-QCA9984.patch
 delete mode 100644 package/kernel/mac80211/patches/950-4-4-ath10k-Enable-support-for-QCA9984.patch
 delete mode 100644 package/kernel/mac80211/patches/951-ath10k-fix-get-rx_status-from-htt-context.patch

diff --git a/package/kernel/mac80211/Makefile b/package/kernel/mac80211/Makefile
index 368249e..52200ec 100644
--- a/package/kernel/mac80211/Makefile
+++ b/package/kernel/mac80211/Makefile
@@ -10,50 +10,27 @@ include $(INCLUDE_DIR)/kernel.mk
 
 PKG_NAME:=mac80211
 
-PKG_VERSION:=2016-05-12
+PKG_VERSION:=3.18
 PKG_RELEASE:=1
-PKG_SOURCE_URL:=http://mirror2.openwrt.org/sources
-PKG_BACKPORT_VERSION:=
-PKG_MD5SUM:=2142cf38509896dca108624e7c193611
 
-PKG_SOURCE:=compat-wireless-$(PKG_VERSION)$(PKG_BACKPORT_VERSION).tar.bz2
-PKG_BUILD_DIR:=$(KERNEL_BUILD_DIR)/compat-wireless-$(PKG_VERSION)
 PKG_BUILD_PARALLEL:=1
 
-PKG_MAINTAINER:=Felix Fietkau <nbd@nbd.name>
-
 PKG_DRIVERS = \
-	adm8211 \
-	airo \
-	ath ath5k ath9k ath9k-common ath9k-htc ath10k \
-	b43 b43legacy \
-	carl9170 \
-	hermes hermes-pci hermes-pcmcia hermes-plx\
-	iwl-legacy iwl3945 iwl4965 iwlwifi \
-	lib80211 \
-	libipw ipw2100 ipw2200 \
-	libertas-sdio libertas-usb libertas-spi \
-	mac80211-hwsim \
-	mt7601u \
-	mwl8k mwifiex-pcie \
-	p54-common p54-pci p54-spi p54-usb \
-	rt2x00-lib rt2x00-pci rt2x00-usb \
-	rt2400-pci rt2500-pci rt2500-usb \
-	rt2800-lib rt2800-mmio rt2800-pci rt2800-soc rt2800-usb \
-	rt61-pci rt73-usb \
-	rtl8180 rtl8187 \
+	adm8211 ath5k libertas-usb libertas-sdio p54-common p54-pci p54-usb p54-spi \
+	rt2x00-lib rt2x00-pci rt2x00-usb rt2800-lib rt2400-pci rt2500-pci \
+	rt2500-usb rt61-pci rt73-usb rt2800-mmio rt2800-pci rt2800-usb rt2800-soc \
+	rtl8180 rtl8187 zd1211rw mac80211-hwsim carl9170 b43 b43legacy \
+	ath9k-common ath9k ath9k-htc ath10k ath net-libipw net-ipw2100 net-ipw2200 \
+	mwl8k mwifiex-pcie net-hermes net-hermes-pci net-hermes-plx net-hermes-pcmcia \
+	iwl-legacy iwl3945 iwl4965 iwlagn wlcore wl12xx wl18xx lib80211 \
 	rtlwifi rtlwifi-pci rtlwifi-usb rtl8192c-common rtl8192ce rtl8192se \
-	rtl8192de rtl8192cu \
-	rtl8xxxu \
-	wlcore wl12xx wl18xx \
-	zd1211rw
+	rtl8192de rtl8192cu
 
 PKG_CONFIG_DEPENDS:= \
 	CONFIG_PACKAGE_kmod-mac80211 \
 	$(patsubst %,CONFIG_PACKAGE_kmod-%,$(PKG_DRIVERS)) \
 	CONFIG_PACKAGE_MAC80211_DEBUGFS \
 	CONFIG_PACKAGE_MAC80211_MESH \
-	CONFIG_PACKAGE_MAC80211_TRACING \
 	CONFIG_PACKAGE_ATH_DEBUG \
 	CONFIG_PACKAGE_ATH_DFS \
 	CONFIG_PACKAGE_B43_DEBUG \
@@ -65,12 +42,7 @@ PKG_CONFIG_DEPENDS:= \
 	CONFIG_PACKAGE_B43_BUSES_BCMA_AND_SSB \
 	CONFIG_PACKAGE_B43_BUSES_BCMA \
 	CONFIG_PACKAGE_B43_BUSES_SSB \
-	CONFIG_PACKAGE_BRCM80211_DEBUG \
-	CONFIG_PACKAGE_IWLWIFI_DEBUG \
-	CONFIG_PACKAGE_IWLWIFI_DEBUGFS \
 	CONFIG_PACKAGE_RTLWIFI_DEBUG \
-	CONFIG_ATH9K_SUPPORT_PCOEM \
-	CONFIG_ATH9K_TX99 \
 	CONFIG_ATH_USER_REGD \
 
 include $(INCLUDE_DIR)/package.mk
@@ -79,30 +51,40 @@ WMENU:=Wireless Drivers
 
 define KernelPackage/mac80211/Default
   SUBMENU:=$(WMENU)
-  URL:=https://wireless.wiki.kernel.org/
-  MAINTAINER:=Felix Fietkau <nbd@nbd.name>
+  DEPENDS:=@!TARGET_uml @(!TARGET_avr32||BROKEN)
 endef
 
 define KernelPackage/cfg80211
   $(call KernelPackage/mac80211/Default)
   TITLE:=cfg80211 - wireless configuration API
   DEPENDS+= +iw
+  KCONFIG:= CONFIG_CFG80211=m
   FILES:= \
-	$(PKG_BUILD_DIR)/compat/compat.ko \
-	$(PKG_BUILD_DIR)/net/wireless/cfg80211.ko
+	$(LINUX_DIR)/net/wireless/cfg80211.ko
 endef
 
 define KernelPackage/cfg80211/description
 cfg80211 is the Linux wireless LAN (802.11) configuration API.
 endef
 
+#CONFIG_CFG80211_INTERNAL_REGDB=y \
+
 define KernelPackage/mac80211
   $(call KernelPackage/mac80211/Default)
   TITLE:=Linux 802.11 Wireless Networking Stack
-  DEPENDS+= +kmod-cfg80211 +hostapd-common
+  DEPENDS+= +kmod-crypto-core +kmod-crypto-arc4 +kmod-crypto-aes +kmod-cfg80211 +hostapd-common
   KCONFIG:=\
-	CONFIG_AVERAGE=y
-  FILES:= $(PKG_BUILD_DIR)/net/mac80211/mac80211.ko
+	CONFIG_AVERAGE=y \
+	CONFIG_WLAN=y \
+	CONFIG_NL80211_TESTMODE=y \
+	CONFIG_CFG80211_WEXT=y \
+	CONFIG_CFG80211_CERTIFICATION_ONUS=y \
+	CONFIG_MAC80211_RC_MINSTREL=y \
+	CONFIG_MAC80211_RC_MINSTREL_HT=y \
+	CONFIG_MAC80211_RC_MINSTREL_VHT=y \
+	CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y \
+	CONFIG_MAC80211=m
+  FILES:= $(LINUX_DIR)/net/mac80211/mac80211.ko
   MENU:=1
 endef
 
@@ -117,15 +99,6 @@ define KernelPackage/mac80211/config
 		  Select this to see extensive information about
 		  the internal state of mac80211 in debugfs.
 
-	config PACKAGE_MAC80211_TRACING
-		bool "Enable tracing (mac80211 and supported drivers)"
-		select KERNEL_FTRACE
-		select KERNEL_ENABLE_DEFAULT_TRACERS
-		default n
-		help
-		  Select this to enable tracing of mac80211 and
-		  related wifi drivers (using trace-cmd).
-
 	config PACKAGE_MAC80211_MESH
 		bool "Enable 802.11s mesh support"
 		default y
@@ -137,716 +110,839 @@ define KernelPackage/mac80211/description
 Generic IEEE 802.11 Networking Stack (mac80211)
 endef
 
-define KernelPackage/adm8211
+PKG_LINUX_FIRMWARE_NAME:=linux-firmware
+PKG_LINUX_FIRMWARE_VERSION:=f404336ba808cbd57547196e13367079a23b822c
+PKG_LINUX_FIRMWARE_SOURCE:=$(PKG_LINUX_FIRMWARE_NAME)-2015-03-20-$(PKG_LINUX_FIRMWARE_VERSION).tar.bz2
+PKG_LINUX_FIRMWARE_PROTO:=git
+PKG_LINUX_FIRMWARE_SOURCE_URL:=https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git
+PKG_LINUX_FIRMWARE_SUBDIR:=$(PKG_LINUX_FIRMWARE_NAME)-$(PKG_LINUX_FIRMWARE_VERSION)
+#PKG_LINUX_FIRMWARE_MIRROR_MD5SUM:=e219333f01835c6e556875a9e0deb3f9
+
+define Download/linux-firmware
+  FILE:=$(PKG_LINUX_FIRMWARE_SOURCE)
+  URL:=$(PKG_LINUX_FIRMWARE_SOURCE_URL)
+  MD5SUM:=$(PKG_LINUX_FIRMWARE_MD5SUM)
+  PROTO:=$(PKG_LINUX_FIRMWARE_PROTO)
+  VERSION:=$(PKG_LINUX_FIRMWARE_VERSION)
+  SUBDIR:=$(PKG_LINUX_FIRMWARE_SUBDIR)
+  MIRROR_MD5SUM:=$(PKG_LINUX_FIRMWARE_MIRROR_MD5SUM)
+endef
+$(eval $(call Download,linux-firmware))
+
+PKG_ATH10K_LINUX_FIRMWARE_NAME:=ath10k-firmware
+PKG_ATH10K_LINUX_FIRMWARE_VERSION:=da0f85d924226ee30c46e037120621c9e192b39e
+PKG_ATH10K_LINUX_FIRMWARE_SOURCE:=$(PKG_ATH10K_LINUX_FIRMWARE_NAME)-$(PKG_ATH10K_LINUX_FIRMWARE_VERSION).tar.bz2
+PKG_ATH10K_LINUX_FIRMWARE_PROTO:=git
+PKG_ATH10K_LINUX_FIRMWARE_SOURCE_URL:=https://github.com/kvalo/ath10k-firmware.git
+PKG_ATH10K_LINUX_FIRMWARE_SUBDIR:=$(PKG_ATH10K_LINUX_FIRMWARE_NAME)-$(PKG_ATH10K_LINUX_FIRMWARE_VERSION)
+#PKG_ATH10K_LINUX_FIRMWARE_MIRROR_MD5SUM:=?
+
+define Download/ath10k-firmware
+  FILE:=$(PKG_ATH10K_LINUX_FIRMWARE_SOURCE)
+  URL:=$(PKG_ATH10K_LINUX_FIRMWARE_SOURCE_URL)
+  PROTO:=$(PKG_ATH10K_LINUX_FIRMWARE_PROTO)
+  VERSION:=$(PKG_ATH10K_LINUX_FIRMWARE_VERSION)
+  SUBDIR:=$(PKG_ATH10K_LINUX_FIRMWARE_SUBDIR)
+  #MIRROR_MD5SUM:=$(PKG_ATH10K_LINUX_FIRMWARE_MIRROR_MD5SUM)
+endef
+$(eval $(call Download,ath10k-firmware))
+
+# Prism54 drivers
+P54PCIFW:=2.13.12.0.arm
+P54USBFW:=2.13.24.0.lm87.arm
+P54SPIFW:=2.13.0.0.a.13.14.arm
+
+define Download/p54usb
+  FILE:=$(P54USBFW)
+  URL:=http://daemonizer.de/prism54/prism54-fw/fw-usb
+  MD5SUM:=8e8ab005a4f8f0123bcdc51bc25b47f6
+endef
+$(eval $(call Download,p54usb))
+
+define Download/p54pci
+  FILE:=$(P54PCIFW)
+  URL:=http://daemonizer.de/prism54/prism54-fw/fw-softmac
+  MD5SUM:=ff7536af2092b1c4b21315bd103ef4c4
+endef
+$(eval $(call Download,p54pci))
+
+define Download/p54spi
+  FILE:=$(P54SPIFW)
+  URL:=http://daemonizer.de/prism54/prism54-fw/stlc4560
+  MD5SUM:=42661f8ecbadd88012807493f596081d
+endef
+$(eval $(call Download,p54spi))
+
+define KernelPackage/p54/Default
   $(call KernelPackage/mac80211/Default)
-  TITLE:=ADMTek 8211 support
-  DEPENDS+=@PCI_SUPPORT +kmod-mac80211 +kmod-eeprom-93cx6
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/admtek/adm8211.ko
-  AUTOLOAD:=$(call AutoProbe,adm8211)
+  TITLE:=Prism54 Drivers
 endef
 
-define KernelPackage/airo
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Cisco Aironet driver
-  DEPENDS+=@PCI_SUPPORT +@DRIVER_WEXT_SUPPORT +kmod-cfg80211 @TARGET_x86
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/cisco/airo.ko
-  AUTOLOAD:=$(call AutoProbe,airo)
+define KernelPackage/p54/description
+  Kernel module for Prism54 chipsets (mac80211)
 endef
 
-define KernelPackage/airo/description
- Kernel support for Cisco Aironet cards
+define KernelPackage/p54-common
+  $(call KernelPackage/p54/Default)
+  DEPENDS+= @PCI_SUPPORT||@USB_SUPPORT||@TARGET_omap24xx +kmod-mac80211 +kmod-lib-crc-ccitt
+  TITLE+= (COMMON)
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/p54/p54common.ko
 endef
 
-define KernelPackage/ath/config
-  if PACKAGE_kmod-ath
-	config ATH_USER_REGD
-		bool "Force Atheros drivers to respect the user's regdomain settings"
-		help
-		  Atheros' idea of regulatory handling is that the EEPROM of the card defines
-		  the regulatory limits and the user is only allowed to restrict the settings
-		  even further, even if the country allows frequencies or power levels that
-		  are forbidden by the EEPROM settings.
+define KernelPackage/p54-pci
+  $(call KernelPackage/p54/Default)
+  TITLE+= (PCI)
+  DEPENDS+= @PCI_SUPPORT +kmod-p54-common
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/p54/p54pci.ko
+  AUTOLOAD:=$(call AutoProbe,p54pci)
+endef
 
-		  Select this option if you want the driver to respect the user's decision about
-		  regulatory settings.
+define KernelPackage/p54-usb
+  $(call KernelPackage/p54/Default)
+  TITLE+= (USB)
+  DEPENDS+= @USB_SUPPORT +kmod-usb-core +kmod-p54-common
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/p54/p54usb.ko
+  AUTOLOAD:=$(call AutoProbe,p54usb)
+endef
 
-	config PACKAGE_ATH_DEBUG
-		bool "Atheros wireless debugging"
-		help
-		  Say Y, if you want to debug atheros wireless drivers.
-		  Only ath9k & ath10k make use of this.
+define KernelPackage/p54-spi
+  $(call KernelPackage/p54/Default)
+  TITLE+= (SPI)
+  DEPENDS+= @TARGET_omap24xx +kmod-p54-common
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/p54/p54spi.ko
+  AUTOLOAD:=$(call AutoProbe,p54spi)
+endef
 
-	config PACKAGE_ATH_DFS
-		bool "Enable DFS support"
-		default y
+define KernelPackage/rt2x00/Default
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Ralink Drivers for RT2x00 cards
+endef
+
+define KernelPackage/rt2x00-lib
+$(call KernelPackage/rt2x00/Default)
+  DEPENDS+= @(PCI_SUPPORT||USB_SUPPORT||TARGET_ramips) +kmod-mac80211 +kmod-lib-crc-itu-t
+  TITLE+= (LIB)
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt2x00lib.ko
+  MENU:=1
+endef
+
+define KernelPackage/rt2x00-lib/config
+  if PACKAGE_kmod-rt2x00-lib
+
+	config PACKAGE_RT2X00_LIB_DEBUGFS
+		bool "Enable rt2x00 debugfs support"
+		depends on PACKAGE_MAC80211_DEBUGFS
 		help
-		  Dynamic frequency selection (DFS) is required for most of the 5 GHz band
-		  channels in Europe, US, and Japan.
+		  Enable creation of debugfs files for the rt2x00 drivers.
+		  These debugfs files support both reading and writing of the
+		  most important register types of the rt2x00 hardware.
 
-		  Select this option if you want to use such channels.
+	config PACKAGE_RT2X00_DEBUG
+		bool "Enable rt2x00 debug output"
+		help
+		  Enable debugging output for all rt2x00 modules
 
   endif
 endef
 
-define KernelPackage/ath
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Atheros common driver part
-  DEPENDS+= @PCI_SUPPORT||USB_SUPPORT||TARGET_ar71xx||TARGET_ath25 +kmod-mac80211
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath.ko
-  MENU:=1
+define KernelPackage/rt2x00-mmio
+$(call KernelPackage/rt2x00/Default)
+  DEPENDS+= @(PCI_SUPPORT||TARGET_ramips) +kmod-rt2x00-lib +kmod-eeprom-93cx6
+  HIDDEN:=1
+  TITLE+= (MMIO)
+  FILES:= $(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt2x00mmio.ko
 endef
 
-define KernelPackage/ath/description
- This module contains some common parts needed by Atheros Wireless drivers.
+define KernelPackage/rt2x00-pci
+$(call KernelPackage/rt2x00/Default)
+  DEPENDS+= @PCI_SUPPORT +kmod-rt2x00-mmio +kmod-rt2x00-lib
+  HIDDEN:=1
+  TITLE+= (PCI)
+  FILES:= $(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt2x00pci.ko
+  AUTOLOAD:=$(call AutoProbe,rt2x00pci)
 endef
 
-define KernelPackage/ath5k
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Atheros 5xxx wireless cards support
-  URL:=https://wireless.wiki.kernel.org/en/users/drivers/ath5k
-  DEPENDS+= @PCI_SUPPORT||@TARGET_ath25 +kmod-ath
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath5k/ath5k.ko
-  AUTOLOAD:=$(call AutoProbe,ath5k)
+define KernelPackage/rt2x00-usb
+$(call KernelPackage/rt2x00/Default)
+  DEPENDS+= @USB_SUPPORT +kmod-rt2x00-lib +kmod-usb-core
+  HIDDEN:=1
+  TITLE+= (USB)
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt2x00usb.ko
+  AUTOLOAD:=$(call AutoProbe,rt2x00usb)
 endef
 
-define KernelPackage/ath5k/description
- This module adds support for wireless adapters based on
- Atheros 5xxx chipset.
+define KernelPackage/rt2800-lib
+$(call KernelPackage/rt2x00/Default)
+  DEPENDS+= @(PCI_SUPPORT||USB_SUPPORT||TARGET_ramips) +kmod-rt2x00-lib +kmod-lib-crc-ccitt +@DRIVER_11N_SUPPORT
+  HIDDEN:=1
+  TITLE+= (rt2800 LIB)
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt2800lib.ko
 endef
 
-define KernelPackage/ath9k-common
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Atheros 802.11n wireless devices (common code for ath9k and ath9k_htc)
-  URL:=https://wireless.wiki.kernel.org/en/users/drivers/ath9k
-  DEPENDS+= @PCI_SUPPORT||USB_SUPPORT||TARGET_ar71xx +kmod-ath +@DRIVER_11N_SUPPORT +@DRIVER_11W_SUPPORT +@KERNEL_RELAY
-  FILES:= \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath9k/ath9k_common.ko \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath9k/ath9k_hw.ko
+define KernelPackage/rt2400-pci
+$(call KernelPackage/rt2x00/Default)
+  DEPENDS+= @PCI_SUPPORT +kmod-rt2x00-pci
+  TITLE+= (RT2400 PCI)
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt2400pci.ko
+  AUTOLOAD:=$(call AutoProbe,rt2400pci)
 endef
 
-define KernelPackage/ath9k
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Atheros 802.11n PCI wireless cards support
-  URL:=https://wireless.wiki.kernel.org/en/users/drivers/ath9k
-  DEPENDS+= @PCI_SUPPORT||TARGET_ar71xx +kmod-ath9k-common
-  FILES:= \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath9k/ath9k.ko
-  AUTOLOAD:=$(call AutoProbe,ath9k)
+define KernelPackage/rt2500-pci
+$(call KernelPackage/rt2x00/Default)
+  DEPENDS+= @PCI_SUPPORT +kmod-rt2x00-pci
+  TITLE+= (RT2500 PCI)
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt2500pci.ko
+  AUTOLOAD:=$(call AutoProbe,rt2500pci)
 endef
 
-define KernelPackage/ath9k/description
-This module adds support for wireless adapters based on
-Atheros IEEE 802.11n AR5008 and AR9001 family of chipsets.
+define KernelPackage/rt2500-usb
+$(call KernelPackage/rt2x00/Default)
+  DEPENDS+= @USB_SUPPORT +kmod-rt2x00-usb
+  TITLE+= (RT2500 USB)
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt2500usb.ko
+  AUTOLOAD:=$(call AutoProbe,rt2500usb)
 endef
 
-define KernelPackage/ath9k/config
+define KernelPackage/rt61-pci
+$(call KernelPackage/rt2x00/Default)
+  DEPENDS+= @PCI_SUPPORT +kmod-rt2x00-pci
+  TITLE+= (RT2x61 PCI)
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt61pci.ko
+  AUTOLOAD:=$(call AutoProbe,rt61pci)
+endef
 
-	config ATH9K_SUPPORT_PCOEM
-		bool "Support chips used in PC OEM cards"
-		depends on PACKAGE_kmod-ath9k
+define KernelPackage/rt73-usb
+  $(call KernelPackage/rt2x00/Default)
+  DEPENDS+= @USB_SUPPORT +kmod-rt2x00-usb
+  TITLE+= (RT73 USB)
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt73usb.ko
+  AUTOLOAD:=$(call AutoProbe,rt73usb)
+endef
 
+define KernelPackage/rt2800-mmio
+$(call KernelPackage/rt2x00/Default)
+  TITLE += (RT28xx/RT3xxx MMIO)
+  DEPENDS += +kmod-rt2800-lib +kmod-rt2x00-mmio
+  HIDDEN:=1
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt2800mmio.ko
 endef
 
-define KernelPackage/ath9k-htc
+define KernelPackage/rt2800-soc
+$(call KernelPackage/rt2x00/Default)
+  DEPENDS += @(TARGET_ramips_rt288x||TARGET_ramips_rt305x||TARGET_ramips_rt3883||TARGET_ramips_mt7620) +kmod-rt2800-mmio +kmod-rt2800-lib
+  TITLE += (RT28xx/RT3xxx SoC)
+  FILES := \
+	$(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt2x00soc.ko \
+	$(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt2800soc.ko
+  AUTOLOAD:=$(call AutoProbe,rt2800soc)
+endef
+
+define KernelPackage/rt2800-pci
+$(call KernelPackage/rt2x00/Default)
+  DEPENDS+= @PCI_SUPPORT +kmod-rt2x00-pci +kmod-rt2800-lib +kmod-rt2800-mmio
+  TITLE+= (RT2860 PCI)
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt2800pci.ko
+  AUTOLOAD:=$(call AutoProbe,rt2800pci)
+endef
+
+define KernelPackage/rt2800-usb
+$(call KernelPackage/rt2x00/Default)
+  DEPENDS+= @USB_SUPPORT +kmod-rt2x00-usb +kmod-rt2800-lib +kmod-lib-crc-ccitt
+  TITLE+= (RT2870 USB)
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt2800usb.ko
+  AUTOLOAD:=$(call AutoProbe,rt2800usb)
+endef
+
+define KernelPackage/rtl818x/Default
   $(call KernelPackage/mac80211/Default)
-  TITLE:=Atheros 802.11n USB device support
-  URL:=https://wireless.wiki.kernel.org/en/users/drivers/ath9k
-  DEPENDS+= @USB_SUPPORT +kmod-ath9k-common +kmod-usb-core +ath9k-htc-firmware
-  FILES:= \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath9k/ath9k_htc.ko
-  AUTOLOAD:=$(call AutoProbe,ath9k_htc)
+  TITLE:=Realtek Drivers for RTL818x devices
+  URL:=http://wireless.kernel.org/en/users/Drivers/rtl8187
+  DEPENDS+= +kmod-eeprom-93cx6 +kmod-mac80211
 endef
 
-define KernelPackage/ath9k-htc/description
-This module adds support for wireless adapters based on
-Atheros USB AR9271 and AR7010 family of chipsets.
+define KernelPackage/rtl8180
+  $(call KernelPackage/rtl818x/Default)
+  DEPENDS+= @PCI_SUPPORT
+  TITLE+= (RTL8180 PCI)
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rtl818x/rtl8180/rtl818x_pci.ko
+  AUTOLOAD:=$(call AutoProbe,rtl818x_pci)
 endef
 
-define KernelPackage/ath10k
+define KernelPackage/rtl8187
+$(call KernelPackage/rtl818x/Default)
+  DEPENDS+= @USB_SUPPORT +kmod-usb-core
+  TITLE+= (RTL8187 USB)
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rtl818x/rtl8187/rtl8187.ko
+  AUTOLOAD:=$(call AutoProbe,rtl8187)
+endef
+
+define KernelPackage/rtlwifi/config
+	config PACKAGE_RTLWIFI_DEBUG
+		bool "Realtek wireless debugging"
+		depends on PACKAGE_kmod-rtlwifi
+		help
+		  Say Y, if you want to debug realtek wireless drivers.
+
+endef
+
+define KernelPackage/rtlwifi
   $(call KernelPackage/mac80211/Default)
-  TITLE:=Atheros 802.11ac wireless cards support
-  URL:=https://wireless.wiki.kernel.org/en/users/Drivers/ath10k
-  DEPENDS+= @PCI_SUPPORT +kmod-ath +@DRIVER_11N_SUPPORT +@DRIVER_11W_SUPPORT +@KERNEL_RELAY
-  FILES:= \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath10k/ath10k_core.ko \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath10k/ath10k_pci.ko
-  AUTOLOAD:=$(call AutoLoad,55,ath10k_core ath10k_pci)
+  TITLE:=Realtek common driver part
+  DEPENDS+= @(PCI_SUPPORT||USB_SUPPORT) +kmod-mac80211 +@DRIVER_11N_SUPPORT
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rtlwifi/rtlwifi.ko
+  HIDDEN:=1
 endef
 
-define KernelPackage/ath10k/description
-This module adds support for wireless adapters based on
-Atheros IEEE 802.11ac family of chipsets. For now only
-PCI is supported.
+define KernelPackage/rtlwifi-pci
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek common driver part (PCI support)
+  DEPENDS+= @PCI_SUPPORT +kmod-rtlwifi
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rtlwifi/rtl_pci.ko
+  AUTOLOAD:=$(call AutoProbe,rtl_pci)
+  HIDDEN:=1
 endef
 
-#Broadcom firmware
-ifneq ($(CONFIG_B43_FW_6_30),)
-  PKG_B43_FWV4_NAME:=broadcom-wl
-  PKG_B43_FWV4_VERSION:=6.30.163.46
-  PKG_B43_FWV4_OBJECT:=$(PKG_B43_FWV4_NAME)-$(PKG_B43_FWV4_VERSION).wl_apsta.o
-  PKG_B43_FWV4_SOURCE:=$(PKG_B43_FWV4_NAME)-$(PKG_B43_FWV4_VERSION).tar.bz2
-  PKG_B43_FWV4_SOURCE_URL:=http://www.lwfinger.com/b43-firmware/
-  PKG_B43_FWV4_MD5SUM:=6fe97e9368d25342a1ab943d3cf3496d
-else
-ifneq ($(CONFIG_B43_FW_5_10),)
-  PKG_B43_FWV4_NAME:=broadcom-wl
-  PKG_B43_FWV4_VERSION:=5.10.56.27.3
-  PKG_B43_FWV4_OBJECT:=$(PKG_B43_FWV4_NAME)-$(PKG_B43_FWV4_VERSION)/driver/wl_apsta/wl_prebuilt.o
-  PKG_B43_FWV4_SOURCE:=$(PKG_B43_FWV4_NAME)-$(PKG_B43_FWV4_VERSION)_mipsel.tar.bz2
-  PKG_B43_FWV4_SOURCE_URL:=http://mirror2.openwrt.org/sources/
-  PKG_B43_FWV4_MD5SUM:=3363e3a6b3d9d73c49dea870c7834eac
-else
-ifneq ($(CONFIG_B43_FW_4_178),)
-  PKG_B43_FWV4_NAME:=broadcom-wl
-  PKG_B43_FWV4_VERSION:=4.178.10.4
-  PKG_B43_FWV4_OBJECT:=$(PKG_B43_FWV4_NAME)-$(PKG_B43_FWV4_VERSION)/linux/wl_apsta.o
-  PKG_B43_FWV4_SOURCE:=$(PKG_B43_FWV4_NAME)-$(PKG_B43_FWV4_VERSION).tar.bz2
-  PKG_B43_FWV4_SOURCE_URL:=http://mirror2.openwrt.org/sources/
-  PKG_B43_FWV4_MD5SUM:=14477e8cbbb91b11896affac9b219fdb
-else
-ifneq ($(CONFIG_B43_FW_5_100_138),)
-  PKG_B43_FWV4_NAME:=broadcom-wl
-  PKG_B43_FWV4_VERSION:=5.100.138
-  PKG_B43_FWV4_OBJECT:=$(PKG_B43_FWV4_NAME)-$(PKG_B43_FWV4_VERSION)/linux/wl_apsta.o
-  PKG_B43_FWV4_SOURCE:=$(PKG_B43_FWV4_NAME)-$(PKG_B43_FWV4_VERSION).tar.bz2
-  PKG_B43_FWV4_SOURCE_URL:=http://www.lwfinger.com/b43-firmware/
-  PKG_B43_FWV4_MD5SUM:=f4e357b09eaf5d8b1f1920cf3493a555
-else
-  PKG_B43_FWV4_NAME:=broadcom-wl
-  PKG_B43_FWV4_VERSION:=4.150.10.5
-  PKG_B43_FWV4_OBJECT:=$(PKG_B43_FWV4_NAME)-$(PKG_B43_FWV4_VERSION)/driver/wl_apsta_mimo.o
-  PKG_B43_FWV4_SOURCE:=$(PKG_B43_FWV4_NAME)-$(PKG_B43_FWV4_VERSION).tar.bz2
-  PKG_B43_FWV4_SOURCE_URL:=http://mirror2.openwrt.org/sources/
-  PKG_B43_FWV4_MD5SUM:=0c6ba9687114c6b598e8019e262d9a60
-endif
-endif
-endif
-endif
-ifneq ($(CONFIG_B43_OPENFIRMWARE),)
-  PKG_B43_FWV4_NAME:=broadcom-wl
-  PKG_B43_FWV4_VERSION:=5.2
-  PKG_B43_FWV4_OBJECT:=openfwwf-$(PKG_B43_FWV4_VERSION)
-  PKG_B43_FWV4_SOURCE:=openfwwf-$(PKG_B43_FWV4_VERSION).tar.gz
-  PKG_B43_FWV4_SOURCE_URL:=http://www.ing.unibs.it/openfwwf/firmware/
-  PKG_B43_FWV4_MD5SUM:=e045a135453274e439ae183f8498b0fa
-endif
-
-
-define Download/b43
-  FILE:=$(PKG_B43_FWV4_SOURCE)
-  URL:=$(PKG_B43_FWV4_SOURCE_URL)
-  MD5SUM:=$(PKG_B43_FWV4_MD5SUM)
+define KernelPackage/rtlwifi-usb
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek common driver part (USB support)
+  DEPENDS+= @USB_SUPPORT +kmod-usb-core +kmod-rtlwifi
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rtlwifi/rtl_usb.ko
+  AUTOLOAD:=$(call AutoProbe,rtl_usb)
+  HIDDEN:=1
 endef
-$(eval $(call Download,b43))
 
-define KernelPackage/b43
+define KernelPackage/rtl8192c-common
   $(call KernelPackage/mac80211/Default)
-  TITLE:=Broadcom 43xx wireless support
-  URL:=https://wireless.wiki.kernel.org/en/users/drivers/b43
-  KCONFIG:= \
-  	CONFIG_HW_RANDOM=y
-  # Depend on PCI_SUPPORT to make sure we can select kmod-bcma or kmod-ssb
-  DEPENDS += \
-	@PCI_SUPPORT +kmod-mac80211 \
-	$(if $(CONFIG_PACKAGE_B43_USE_SSB),+kmod-ssb) \
-	$(if $(CONFIG_PACKAGE_B43_USE_BCMA),+kmod-bcma)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/broadcom/b43/b43.ko
-  AUTOLOAD:=$(call AutoProbe,b43)
-  MENU:=1
+  TITLE:=Realtek RTL8192CE/RTL8192CU common support module
+  DEPENDS+= +kmod-rtlwifi
+  FILES:= $(PKG_BUILD_DIR)/drivers/net/wireless/rtlwifi/rtl8192c/rtl8192c-common.ko
+  HIDDEN:=1
 endef
 
-define KernelPackage/b43/config
-
-config PACKAGE_B43_USE_SSB
-	select PACKAGE_kmod-ssb
-	tristate
-	depends on !TARGET_brcm47xx && !TARGET_brcm63xx
-	default PACKAGE_kmod-b43 if PACKAGE_B43_BUSES_BCMA_AND_SSB
-	default PACKAGE_kmod-b43 if PACKAGE_B43_BUSES_SSB
-
-config PACKAGE_B43_USE_BCMA
-	select PACKAGE_kmod-bcma
-	tristate
-	depends on !TARGET_brcm47xx && !TARGET_bcm53xx
-	default PACKAGE_kmod-b43 if PACKAGE_B43_BUSES_BCMA_AND_SSB
-	default PACKAGE_kmod-b43 if PACKAGE_B43_BUSES_BCMA
-
-  if PACKAGE_kmod-b43
+define KernelPackage/rtl8192ce
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTL8192CE/RTL8188CE support
+  DEPENDS+= +kmod-rtlwifi-pci +kmod-rtl8192c-common
+  FILES:= $(PKG_BUILD_DIR)/drivers/net/wireless/rtlwifi/rtl8192ce/rtl8192ce.ko
+  AUTOLOAD:=$(call AutoProbe,rtl8192ce)
+endef
 
-	choice
-		prompt "b43 firmware version"
-		default B43_FW_5_100_138
-		help
-		  This option allows you to select the version of the b43 firmware.
+define KernelPackage/rtl8192ce/install
+	$(INSTALL_DIR) $(1)/lib/firmware/rtlwifi
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/rtlwifi/rtl8192cfw.bin $(1)/lib/firmware/rtlwifi
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/rtlwifi/rtl8192cfwU.bin $(1)/lib/firmware/rtlwifi
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/rtlwifi/rtl8192cfwU_B.bin $(1)/lib/firmware/rtlwifi
+endef
 
-	config B43_FW_4_150
-		bool "Firmware 410.2160 from driver 4.150.10.5 (old stable)"
-		help
-		  Old stable firmware for BCM43xx devices.
+define KernelPackage/rtl8192se
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTL8192SE/RTL8191SE support
+  DEPENDS+= +kmod-rtlwifi-pci
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rtlwifi/rtl8192se/rtl8192se.ko
+  AUTOLOAD:=$(call AutoProbe,rtl8192se)
+endef
 
-		  If unsure, select this.
+define KernelPackage/rtl8192se/install
+	$(INSTALL_DIR) $(1)/lib/firmware/rtlwifi
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/rtlwifi/rtl8192sefw.bin $(1)/lib/firmware/rtlwifi
+endef
 
-	config B43_FW_4_178
-		bool "Firmware 478.104 from driver 4.178.10.4"
-		help
-		  Older firmware for BCM43xx devices.
+define KernelPackage/rtl8192de
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTL8192DE/RTL8188DE support
+  DEPENDS+= +kmod-rtlwifi-pci
+  FILES:= $(PKG_BUILD_DIR)/drivers/net/wireless/rtlwifi/rtl8192de/rtl8192de.ko
+  AUTOLOAD:=$(call AutoProbe,rtl8192de)
+endef
 
-		  If unsure, select the "stable" firmware.
+define KernelPackage/rtl8192de/install
+	$(INSTALL_DIR) $(1)/lib/firmware/rtlwifi
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/rtlwifi/rtl8192defw.bin $(1)/lib/firmware/rtlwifi
+endef
 
-	config B43_FW_5_10
-		bool "Firmware 508.1084 from driver 5.10.56.27"
-		help
-		  Older firmware for BCM43xx devices.
+define KernelPackage/rtl8192cu
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Realtek RTL8192CU/RTL8188CU support
+  DEPENDS+= +kmod-rtlwifi-usb +kmod-rtl8192c-common
+  FILES:= $(PKG_BUILD_DIR)/drivers/net/wireless/rtlwifi/rtl8192cu/rtl8192cu.ko
+  AUTOLOAD:=$(call AutoProbe,rtl8192cu)
+endef
 
-		  If unsure, select the "stable" firmware.
+define KernelPackage/rtl8192cu/install
+	$(INSTALL_DIR) $(1)/lib/firmware/rtlwifi
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/rtlwifi/rtl8192cufw.bin $(1)/lib/firmware/rtlwifi
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/rtlwifi/rtl8192cufw_A.bin $(1)/lib/firmware/rtlwifi
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/rtlwifi/rtl8192cufw_B.bin $(1)/lib/firmware/rtlwifi
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/rtlwifi/rtl8192cufw_TMSC.bin $(1)/lib/firmware/rtlwifi
+endef
 
-	config B43_FW_5_100_138
-		bool "Firmware 666.2 from driver 5.100.138 (stable)"
-		help
-		  The currently default firmware for BCM43xx devices.
+ZD1211FW_NAME:=zd1211-firmware
+ZD1211FW_VERSION:=1.4
+define Download/zd1211rw
+  FILE:=$(ZD1211FW_NAME)-$(ZD1211FW_VERSION).tar.bz2
+  URL:=@SF/zd1211/
+  MD5SUM:=19f28781d76569af8551c9d11294c870
+endef
+$(eval $(call Download,zd1211rw))
 
-		  This firmware currently gets most of the testing and is needed for some N-PHY devices.
+define KernelPackage/zd1211rw
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Zydas ZD1211 support
+  DEPENDS+= @USB_SUPPORT +kmod-usb-core +kmod-mac80211
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/zd1211rw/zd1211rw.ko
+  AUTOLOAD:=$(call AutoProbe,zd1211rw)
+endef
 
-		  If unsure, select the this firmware.
+define KernelPackage/adm8211
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=ADMTek 8211 support
+  DEPENDS+=@PCI_SUPPORT +kmod-mac80211 +kmod-eeprom-93cx6
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/adm8211.ko
+  AUTOLOAD:=$(call AutoProbe,adm8211)
+endef
 
-	config B43_FW_6_30
-		bool "Firmware 784.2 from driver 6.30.163.46 (experimental)"
+define KernelPackage/ath/config
+  if PACKAGE_kmod-ath
+	config ATH_USER_REGD
+		bool "Force Atheros drivers to respect the user's regdomain settings"
 		help
-		  Newer experimental firmware for BCM43xx devices.
-
-		  This firmware is mostly untested.
+		  Atheros' idea of regulatory handling is that the EEPROM of the card defines
+		  the regulatory limits and the user is only allowed to restrict the settings
+		  even further, even if the country allows frequencies or power levels that
+		  are forbidden by the EEPROM settings.
 
-		  If unsure, select the "stable" firmware.
+		  Select this option if you want the driver to respect the user's decision about
+		  regulatory settings.
 
-	config B43_OPENFIRMWARE
-		bool "Open FirmWare for WiFi networks"
+	config PACKAGE_ATH_DEBUG
+		bool "Atheros wireless debugging"
 		help
-		  Opensource firmware for BCM43xx devices.
-
-		  Do _not_ select this, unless you know what you are doing.
-		  The Opensource firmware is not suitable for embedded devices, yet.
-		  It does not support QoS, which is bad for AccessPoints.
-		  It does not support hardware crypto acceleration, which is a showstopper
-		  for embedded devices with low CPU resources.
-
-		  If unsure, select the "stable" firmware.
-
-	endchoice
+		  Say Y, if you want to debug atheros wireless drivers.
+		  Right now only ath9k makes use of this.
 
-	config B43_FW_SQUASH
-		bool "Remove unnecessary firmware files"
-		depends on !B43_OPENFIRMWARE
+	config PACKAGE_ATH_DFS
+		bool "Enable DFS support"
 		default y
 		help
-		  This options allows you to remove unnecessary b43 firmware files
-		  from the final rootfs image. This can reduce the rootfs size by
-		  up to 200k.
-
-		  If unsure, say Y.
-
-	config B43_FW_SQUASH_COREREVS
-		string "Core revisions to include"
-		depends on B43_FW_SQUASH
-		default "5,6,7,8,9,10,11,13,15" if TARGET_brcm47xx_legacy
-		default "16,28,29,30" if TARGET_brcm47xx_mips74k
-		default "5,6,7,8,9,10,11,13,15,16,28,29,30"
-		help
-		  This is a comma seperated list of core revision numbers.
-
-		  Example (keep files for rev5 only):
-		    5
-
-		  Example (keep files for rev5 and rev11):
-		    5,11
-
-	config B43_FW_SQUASH_PHYTYPES
-		string "PHY types to include"
-		depends on B43_FW_SQUASH
-		default "G,N,LP" if TARGET_brcm47xx_legacy
-		default "N,HT" if TARGET_brcm47xx_mips74k
-		default "G,N,LP,HT"
-		help
-		  This is a comma seperated list of PHY types:
-		    A  => A-PHY
-		    AG => Dual A-PHY G-PHY
-		    G  => G-PHY
-		    LP => LP-PHY
-		    N  => N-PHY
-		    HT  => HT-PHY
-		    LCN  => LCN-PHY
-		    LCN40  => LCN40-PHY
-		    AC  => AC-PHY
-
-		  Example (keep files for G-PHY only):
-		    G
-
-		  Example (keep files for G-PHY and N-PHY):
-		    G,N
+		  Dynamic frequency selection (DFS) is required for most of the 5 GHz band
+		  channels in Europe, US, and Japan.
 
-	choice
-		prompt "Supported buses"
-		default PACKAGE_B43_BUSES_BCMA_AND_SSB
-		help
-		  This allows choosing buses that b43 should support.
+		  Select this option if you want to use such channels.
 
-	config PACKAGE_B43_BUSES_BCMA_AND_SSB
-		depends on !TARGET_brcm47xx_legacy && !TARGET_brcm47xx_mips74k && !TARGET_bcm53xx
-		bool "BCMA and SSB"
+  endif
+endef
 
-	config PACKAGE_B43_BUSES_BCMA
-		depends on !TARGET_brcm47xx_legacy
-		bool "BCMA only"
+define KernelPackage/ath
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Atheros common driver part
+  DEPENDS+= @PCI_SUPPORT||USB_SUPPORT||TARGET_ar71xx||TARGET_ath25 +kmod-mac80211
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath.ko
+  MENU:=1
+endef
 
-	config PACKAGE_B43_BUSES_SSB
-		depends on !TARGET_brcm47xx_mips74k && !TARGET_bcm53xx
-		bool "SSB only"
+define KernelPackage/ath/description
+ This module contains some common parts needed by Atheros Wireless drivers.
+endef
 
-	endchoice
+define KernelPackage/ath5k
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Atheros 5xxx wireless cards support
+  URL:=https://wireless.wiki.kernel.org/en/users/drivers/ath5k
+  DEPENDS+= @PCI_SUPPORT||@TARGET_ath25 +kmod-ath
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath5k/ath5k.ko
+  AUTOLOAD:=$(call AutoProbe,ath5k)
+endef
 
-	config PACKAGE_B43_DEBUG
-		bool "Enable debug output and debugfs for b43"
-		default n
-		help
-		  Enable additional debug output and runtime sanity checks for b43
-		  and enables the debugfs interface.
+define KernelPackage/ath5k/description
+ This module adds support for wireless adapters based on
+ Atheros 5xxx chipset.
+endef
 
-		  If unsure, say N.
+define KernelPackage/ath9k-common
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Atheros 802.11n wireless devices (common code for ath9k and ath9k_htc)
+  URL:=https://wireless.wiki.kernel.org/en/users/drivers/ath9k
+  DEPENDS+= @PCI_SUPPORT||USB_SUPPORT||TARGET_ar71xx +kmod-ath +@DRIVER_11N_SUPPORT +@KERNEL_RELAY
+  FILES:= \
+	$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath9k/ath9k_common.ko \
+	$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath9k/ath9k_hw.ko
+endef
 
-	config PACKAGE_B43_PIO
-		bool "Enable support for PIO transfer mode"
-		default n
-		help
-		  Enable support for using PIO instead of DMA. Unless you have DMA
-		  transfer problems you don't need this.
+define KernelPackage/ath9k
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Atheros 802.11n PCI wireless cards support
+  URL:=https://wireless.wiki.kernel.org/en/users/drivers/ath9k
+  DEPENDS+= @PCI_SUPPORT||TARGET_ar71xx +kmod-ath9k-common
+  FILES:= \
+	$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath9k/ath9k.ko
+  AUTOLOAD:=$(call AutoProbe,ath9k)
+endef
 
-		  If unsure, say N.
+define KernelPackage/ath9k/description
+This module adds support for wireless adapters based on
+Atheros IEEE 802.11n AR5008 and AR9001 family of chipsets.
+endef
 
-	config PACKAGE_B43_PHY_G
-		bool "Enable support for G-PHYs"
-		default n if TARGET_brcm47xx_mips74k
-		default y
-		help
-		  Enable support for G-PHY. This includes support for the following devices:
-		  PCI: BCM4306, BCM4311, BCM4318
-		  SoC: BCM5352E, BCM4712
+define KernelPackage/ath9k/config
 
-		  If unsure, say Y.
+	config ATH9K_SUPPORT_PCOEM
+		bool "Support chips used in PC OEM cards"
+		depends on PACKAGE_kmod-ath9k
+	
+endef
 
-	config PACKAGE_B43_PHY_N
-		bool "Enable support for N-PHYs"
-		default y
-		help
-		  Enable support for N-PHY. This includes support for the following devices:
-		  PCI: BCM4321, BCM4322, BCM43222, BCM43224, BCM43225
-		  SoC: BCM4716, BCM4717, BCM4718
+define KernelPackage/ath9k-htc
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Atheros 802.11n USB device support
+  URL:=https://wireless.wiki.kernel.org/en/users/drivers/ath9k
+  DEPENDS+= @USB_SUPPORT +kmod-ath9k-common +kmod-usb-core
+  FILES:= \
+	$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath9k/ath9k_htc.ko
+  AUTOLOAD:=$(call AutoProbe,ath9k_htc)
+endef
 
-		  Currently only 11g speed is available.
+define KernelPackage/ath9k-htc/description
+This module adds support for wireless adapters based on
+Atheros USB AR9271 and AR7010 family of chipsets.
+endef
 
-		  If unsure, say Y.
+define KernelPackage/ath10k
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Atheros 802.11ac wireless cards support
+  URL:=https://wireless.wiki.kernel.org/en/users/Drivers/ath10k
+  DEPENDS+= @PCI_SUPPORT +kmod-ath +@DRIVER_11N_SUPPORT
+  FILES:= \
+	$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath10k/ath10k_core.ko \
+	$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath10k/ath10k_pci.ko
+  AUTOLOAD:=$(call AutoLoad,55,ath10k_core ath10k_pci)
+endef
 
-	config PACKAGE_B43_PHY_LP
-		bool "Enable support for LP-PHYs"
-		default n if TARGET_brcm47xx_mips74k
-		default y
-		help
-		  Enable support for LP-PHY. This includes support for the following devices:
-		  PCI: BCM4312
-		  SoC: BCM5354
+define KernelPackage/ath10k/description
+This module adds support for wireless adapters based on
+Atheros IEEE 802.11ac family of chipsets. For now only
+PCI is supported.
+endef
 
-		  If unsure, say Y.
+define KernelPackage/ath10k/config
+  if PACKAGE_kmod-ath10k
 
-	config PACKAGE_B43_PHY_HT
-		bool "Enable support for HT-PHYs"
-		default n if TARGET_brcm47xx_legacy
-		default y
+	config ATH10K_STA_FW
+		bool "Firmware optimized for STA operation"
+		default n
 		help
-		  Enable support for HT-PHY. This includes support for the following devices:
-		  PCI: BCM4331
-
-		  Currently only 11g speed is available.
-
-		  If unsure, say Y.
+		  Use the ath10k firmware optimized for wireless client instead
+		  of access point operation.
 
-	config PACKAGE_B43_PHY_LCN
-		bool "Enable support for LCN-PHYs"
-		depends on BROKEN
+	config ATH10K_API2_FW
+		bool "Firmware optimized for AP operation (v10.1 / API v2)"
 		default n
+		depends on !ATH10K_STA_FW
 		help
-		  Currently broken.
-
-		  If unsure, say N.
+		  Use the ath10k firmware from the 10.1 SDK using API v2 optimized
+		  for access point operation if the default firmware keeps crashing.
 
   endif
 endef
 
-define KernelPackage/b43/description
-Kernel module for Broadcom 43xx wireless support (mac80211 stack) new
+define KernelPackage/carl9170
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Driver for Atheros AR9170 USB sticks
+  DEPENDS:=@USB_SUPPORT +kmod-mac80211 +kmod-ath +kmod-usb-core +kmod-input-core +@DRIVER_11N_SUPPORT
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ath/carl9170/carl9170.ko
+  AUTOLOAD:=$(call AutoProbe,carl9170)
 endef
 
-define KernelPackage/b43legacy
+define KernelPackage/lib80211
   $(call KernelPackage/mac80211/Default)
-  TITLE:=Broadcom 43xx-legacy wireless support
-  URL:=https://wireless.wiki.kernel.org/en/users/drivers/b43
+  TITLE:=802.11 Networking stack
+  DEPENDS:=+kmod-cfg80211
   KCONFIG:= \
-  	CONFIG_HW_RANDOM=y
-  DEPENDS+= +kmod-mac80211 +!(TARGET_brcm47xx||TARGET_brcm63xx):kmod-ssb +b43legacy-firmware
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/broadcom/b43legacy/b43legacy.ko
-  AUTOLOAD:=$(call AutoProbe,b43legacy)
-  MENU:=1
+	CONFIG_WIRELESS=y \
+	CONFIG_LIB80211=m \
+	CONFIG_LIB80211_CRYPT_WEP=m \
+	CONFIG_LIB80211_CRYPT_CCMP=m \
+	CONFIG_LIB80211_CRYPT_TKIP=m
+  FILES:= \
+	$(LINUX_DIR)/net/wireless/lib80211.ko \
+	$(LINUX_DIR)/net/wireless/lib80211_crypt_wep.ko \
+	$(LINUX_DIR)/net/wireless/lib80211_crypt_ccmp.ko \
+	$(LINUX_DIR)/net/wireless/lib80211_crypt_tkip.ko
+  AUTOLOAD:=$(call AutoProbe, \
+	lib80211 \
+	lib80211_crypt_wep \
+	lib80211_crypt_ccmp \
+	lib80211_crypt_tkip \
+  )
 endef
 
-define KernelPackage/b43legacy/description
-Kernel module for Broadcom 43xx-legacy wireless support (mac80211 stack) new
+define KernelPackage/lib80211/description
+ Kernel modules for 802.11 Networking stack
+ Includes:
+ - lib80211
+ - lib80211_crypt_wep
+ - lib80211_crypt_tkip
+ - lib80211_crytp_ccmp
 endef
 
-
-define KernelPackage/brcmutil
+define KernelPackage/libertas-usb
   $(call KernelPackage/mac80211/Default)
-  TITLE:=Broadcom IEEE802.11n common driver parts
-  URL:=https://wireless.wiki.kernel.org/en/users/drivers/brcm80211
-  DEPENDS+=@PCI_SUPPORT||USB_SUPPORT
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/broadcom/brcm80211/brcmutil/brcmutil.ko
-  AUTOLOAD:=$(call AutoProbe,brcmutil)
-  MENU:=1
-endef
-
-define KernelPackage/brcmutil/description
- This module contains some common parts needed by Broadcom Wireless drivers brcmsmac and brcmfmac.
+  DEPENDS+= @USB_SUPPORT +kmod-cfg80211 +kmod-usb-core +kmod-lib80211 +@DRIVER_WEXT_SUPPORT
+  TITLE:=Marvell 88W8015 Wireless Driver
+  FILES:= \
+	$(PKG_BUILD_DIR)/drivers/net/wireless/libertas/libertas.ko \
+	$(PKG_BUILD_DIR)/drivers/net/wireless/libertas/usb8xxx.ko
+  AUTOLOAD:=$(call AutoProbe,libertas usb8xxx)
 endef
 
-define KernelPackage/brcmutil/config
-  if PACKAGE_kmod-brcmutil
-
-	config PACKAGE_BRCM80211_DEBUG
-		bool "Broadcom wireless driver debugging"
-		help
-		  Say Y, if you want to debug brcmsmac and brcmfmac wireless driver.
-
-  endif
+define KernelPackage/libertas-sdio
+  $(call KernelPackage/mac80211/Default)
+  DEPENDS+= +kmod-cfg80211 +kmod-lib80211 +kmod-mmc +@DRIVER_WEXT_SUPPORT @!TARGET_uml
+  TITLE:=Marvell 88W8686 Wireless Driver
+  FILES:= \
+	$(PKG_BUILD_DIR)/drivers/net/wireless/libertas/libertas.ko \
+	$(PKG_BUILD_DIR)/drivers/net/wireless/libertas/libertas_sdio.ko
+  AUTOLOAD:=$(call AutoProbe,libertas libertas_sdio)
 endef
 
-PKG_BRCMSMAC_FW_NAME:=broadcom-wl
-PKG_BRCMSMAC_FW_VERSION:=5.100.138
-PKG_BRCMSMAC_FW_OBJECT:=$(PKG_BRCMSMAC_FW_NAME)-$(PKG_BRCMSMAC_FW_VERSION)/linux/wl_apsta.o
-PKG_BRCMSMAC_FW_SOURCE:=$(PKG_BRCMSMAC_FW_NAME)-$(PKG_BRCMSMAC_FW_VERSION).tar.bz2
-PKG_BRCMSMAC_FW_SOURCE_URL:=http://www.lwfinger.com/b43-firmware/
-PKG_BRCMSMAC_FW_MD5SUM:=f4e357b09eaf5d8b1f1920cf3493a555
-
-define Download/brcmsmac
-  FILE:=$(PKG_BRCMSMAC_FW_SOURCE)
-  URL:=$(PKG_BRCMSMAC_FW_SOURCE_URL)
-  MD5SUM:=$(PKG_BRCMSMAC_FW_MD5SUM)
+define KernelPackage/mac80211-hwsim
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=mac80211 HW simulation device
+  DEPENDS+= +kmod-mac80211 +@DRIVER_11N_SUPPORT
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/mac80211_hwsim.ko
+  AUTOLOAD:=$(call AutoProbe,mac80211_hwsim)
 endef
-$(eval $(call Download,brcmsmac))
 
-define KernelPackage/brcmsmac
+define KernelPackage/net-libipw
   $(call KernelPackage/mac80211/Default)
-  TITLE:=Broadcom IEEE802.11n PCIe SoftMAC WLAN driver
-  URL:=https://wireless.wiki.kernel.org/en/users/drivers/brcm80211
-  DEPENDS+= +kmod-mac80211 +@DRIVER_11N_SUPPORT +!TARGET_brcm47xx:kmod-bcma +kmod-lib-cordic +kmod-lib-crc8 +kmod-brcmutil +!BRCMSMAC_USE_FW_FROM_WL:brcmsmac-firmware
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/broadcom/brcm80211/brcmsmac/brcmsmac.ko
-  AUTOLOAD:=$(call AutoProbe,brcmsmac)
-  MENU:=1
+  TITLE:=libipw for ipw2100 and ipw2200
+  DEPENDS:=@PCI_SUPPORT +kmod-crypto-core +kmod-crypto-arc4 +kmod-crypto-aes +kmod-crypto-michael-mic +kmod-lib80211 +kmod-cfg80211 +@DRIVER_WEXT_SUPPORT @!BIG_ENDIAN
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ipw2x00/libipw.ko
+  AUTOLOAD:=$(call AutoProbe,libipw)
 endef
 
-define KernelPackage/brcmsmac/description
- Kernel module for Broadcom IEEE802.11n PCIe Wireless cards
+define KernelPackage/net-libipw/description
+ Hardware independent IEEE 802.11 networking stack for ipw2100 and ipw2200.
 endef
 
-define KernelPackage/brcmsmac/config
-  if PACKAGE_kmod-brcmsmac
-
-	config BRCMSMAC_USE_FW_FROM_WL
-		bool "Use firmware extracted from broadcom proprietary driver"
-		default y
-		help
-		  Instead of using the official brcmsmac firmware a firmware
-		  version 666.2 extracted from the proprietary Broadcom driver
-		  is used. This is needed to get core rev 17 used in bcm4716
-		  to work.
-
-		  If unsure, say Y.
+IPW2100_NAME:=ipw2100-fw
+IPW2100_VERSION:=1.3
 
-  endif
+define Download/net-ipw2100
+  URL:=http://bughost.org/firmware/
+  FILE:=$(IPW2100_NAME)-$(IPW2100_VERSION).tgz
+  MD5SUM=46aa75bcda1a00efa841f9707bbbd113
 endef
+$(eval $(call Download,net-ipw2100))
 
-
-define KernelPackage/brcmfmac
+define KernelPackage/net-ipw2100
   $(call KernelPackage/mac80211/Default)
-  TITLE:=Broadcom IEEE802.11n USB FullMAC WLAN driver
-  URL:=https://wireless.wiki.kernel.org/en/users/drivers/brcm80211
-  DEPENDS+= @USB_SUPPORT +kmod-cfg80211 +@DRIVER_11N_SUPPORT +kmod-brcmutil \
-	+BRCMFMAC_PCIE:brcmfmac-firmware-pcie \
-	+BRCMFMAC_SDIO:kmod-mmc +BRCMFMAC_SDIO:brcmfmac-firmware-sdio \
-	+BRCMFMAC_USB:kmod-usb-core +BRCMFMAC_USB:brcmfmac-firmware-usb
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/broadcom/brcm80211/brcmfmac/brcmfmac.ko
-  AUTOLOAD:=$(call AutoProbe,brcmfmac)
+  TITLE:=Intel IPW2100 driver
+  DEPENDS:=@PCI_SUPPORT +kmod-net-libipw
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ipw2x00/ipw2100.ko
+  AUTOLOAD:=$(call AutoProbe,ipw2100)
 endef
 
-define KernelPackage/brcmfmac/description
- Kernel module for Broadcom IEEE802.11n USB Wireless cards
+define KernelPackage/net-ipw2100/description
+ Kernel support for Intel IPW2100
+ Includes:
+ - ipw2100
 endef
 
-define KernelPackage/brcmfmac/config
-  if PACKAGE_kmod-brcmfmac
-
-	config BRCMFMAC_SDIO
-		bool "Enable SDIO bus interface support"
-		default y if TARGET_brcm2708
-		default n
-		help
-		  Enable support for cards attached to an SDIO bus.
-		  Select this option only if you are sure that your
-		  board has a Broadcom wireless chip atacched to
-		  that bus.
-
-	config BRCMFMAC_USB
-		bool "Enable USB bus interface support"
-		depends on USB_SUPPORT
-		default y
-		help
-		  Supported USB connected chipsets:
-		  BCM43235, BCM43236, BCM43238 (all in revision 3 only)
-		  BCM43143, BCM43242, BCM43566, BCM43569
-
-	config BRCMFMAC_PCIE
-		bool "Enable PCIE bus interface support"
-		depends on PCI_SUPPORT
-		default y
-		help
-		  Supported PCIe connected chipsets:
-		  BCM4354, BCM4356, BCM43567, BCM43570, BCM43602
+IPW2200_NAME:=ipw2200-fw
+IPW2200_VERSION:=3.1
 
-  endif
+define Download/net-ipw2200
+  URL:=http://bughost.org/firmware/
+  FILE:=$(IPW2200_NAME)-$(IPW2200_VERSION).tgz
+  MD5SUM=eaba788643c7cc7483dd67ace70f6e99
 endef
+$(eval $(call Download,net-ipw2200))
 
-
-define KernelPackage/carl9170
+define KernelPackage/net-ipw2200
   $(call KernelPackage/mac80211/Default)
-  TITLE:=Driver for Atheros AR9170 USB sticks
-  DEPENDS:=@USB_SUPPORT +kmod-mac80211 +kmod-ath +kmod-usb-core +kmod-input-core +@DRIVER_11N_SUPPORT +carl9170-firmware
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ath/carl9170/carl9170.ko
-  AUTOLOAD:=$(call AutoProbe,carl9170)
+  TITLE:=Intel IPW2200 driver
+  DEPENDS:=@PCI_SUPPORT +kmod-net-libipw
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ipw2x00/ipw2200.ko
+  AUTOLOAD:=$(call AutoProbe,ipw2200)
+endef
+
+define KernelPackage/net-ipw2200/description
+ Kernel support for Intel IPW2200
+ Includes:
+ - ipw2200
 endef
 
 
-define KernelPackage/hermes
+define KernelPackage/net-hermes
   $(call KernelPackage/mac80211/Default)
   TITLE:=Hermes 802.11b chipset support
-  DEPENDS:=@PCI_SUPPORT||PCMCIA_SUPPORT +kmod-cfg80211 +@DRIVER_WEXT_SUPPORT +kmod-crypto-michael-mic
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/intersil/orinoco/orinoco.ko
+  DEPENDS:=@PCI_SUPPORT||PCMCIA_SUPPORT +kmod-cfg80211 +@DRIVER_WEXT_SUPPORT
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/orinoco/orinoco.ko
   AUTOLOAD:=$(call AutoProbe,orinoco)
 endef
 
-define KernelPackage/hermes/description
+define KernelPackage/net-hermes/description
  Kernel support for Hermes 802.11b chipsets
 endef
 
-define KernelPackage/hermes-pci
+define KernelPackage/net-hermes-pci
   $(call KernelPackage/mac80211/Default)
   TITLE:=Intersil Prism 2.5 PCI support
-  DEPENDS:=@PCI_SUPPORT +kmod-hermes
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/intersil/orinoco/orinoco_pci.ko
+  DEPENDS:=@PCI_SUPPORT +kmod-net-hermes
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/orinoco/orinoco_pci.ko
   AUTOLOAD:=$(call AutoProbe,orinoco_pci)
 endef
 
-define KernelPackage/hermes-pci/description
+define KernelPackage/net-hermes-pci/description
  Kernel modules for Intersil Prism 2.5 PCI support
 endef
 
-define KernelPackage/hermes-plx
+define KernelPackage/net-hermes-plx
   $(call KernelPackage/mac80211/Default)
   TITLE:=PLX9052 based PCI adaptor
-  DEPENDS:=@PCI_SUPPORT +kmod-hermes
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/intersil/orinoco/orinoco_plx.ko
+  DEPENDS:=@PCI_SUPPORT +kmod-net-hermes
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/orinoco/orinoco_plx.ko
   AUTOLOAD:=$(call AutoProbe,orinoco_plx)
 endef
 
-define KernelPackage/hermes-plx/description
+define KernelPackage/net-hermes-plx/description
  Kernel modules for Hermes in PLX9052 based PCI adaptors
 endef
 
-define KernelPackage/hermes-pcmcia
+define KernelPackage/net-hermes-pcmcia
   $(call KernelPackage/mac80211/Default)
   TITLE:=Hermes based PCMCIA adaptors
-  DEPENDS:=@PCMCIA_SUPPORT +kmod-hermes @BROKEN
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/intersil/orinoco/orinoco_cs.ko
+  DEPENDS:=@PCMCIA_SUPPORT +kmod-net-hermes @BROKEN
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/orinoco/orinoco_cs.ko
   AUTOLOAD:=$(call AutoProbe,orinoco_cs)
 endef
 
-define KernelPackage/hermes-pcmcia/description
+define KernelPackage/net-hermes-pcmcia/description
  Kernel modules for Hermes based PCMCIA adaptors
 endef
 
-
-define KernelPackage/iwlwifi
+define KernelPackage/iwlagn
   $(call KernelPackage/mac80211/Default)
-  DEPENDS:= +kmod-mac80211 @PCI_SUPPORT +@DRIVER_11N_SUPPORT +iwlwifi-firmware
+  DEPENDS:= +kmod-mac80211 @PCI_SUPPORT +@DRIVER_11N_SUPPORT
   TITLE:=Intel AGN Wireless support
   FILES:= \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/intel/iwlwifi/iwlwifi.ko \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/intel/iwlwifi/dvm/iwldvm.ko \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/intel/iwlwifi/mvm/iwlmvm.ko
-  AUTOLOAD:=$(call AutoProbe,iwlwifi iwldvm iwlmvm)
+	$(PKG_BUILD_DIR)/drivers/net/wireless/iwlwifi/iwlwifi.ko \
+	$(PKG_BUILD_DIR)/drivers/net/wireless/iwlwifi/dvm/iwldvm.ko
+  AUTOLOAD:=$(call AutoProbe,iwlwifi iwldvm)
   MENU:=1
 endef
 
-define KernelPackage/iwlwifi/description
- iwlwifi kernel module for
- Intel Wireless WiFi Link 6250AGN Adapter
- Intel 6000 Series Wi-Fi Adapters (6200AGN and 6300AGN)
- Intel WiFi Link 1000BGN
- Intel Wireless WiFi 5150AGN
- Intel Wireless WiFi 5100AGN, 5300AGN, and 5350AGN
- Intel 6005 Series Wi-Fi Adapters
- Intel 6030 Series Wi-Fi Adapters
- Intel Wireless WiFi Link 6150BGN 2 Adapter
- Intel 100 Series Wi-Fi Adapters (100BGN and 130BGN)
- Intel 2000 Series Wi-Fi Adapters
- Intel 7260 Wi-Fi Adapter
- Intel 3160 Wi-Fi Adapter
- Intel 7265 Wi-Fi Adapter
- Intel 8260 Wi-Fi Adapter
- Intel 3165 Wi-Fi Adapter
-endef
-
-define KernelPackage/iwlwifi/config
-  if PACKAGE_kmod-iwlwifi
-
-	config PACKAGE_IWLWIFI_DEBUG
-		bool "Enable full debugging output in the iwlwifi driver"
-		default n
+define KernelPackage/iwlagn/description
+ iwlagn kernel module for Intel 5000/5150/1000/6000/6050/6005/6030/100 support
+endef
+
+define KernelPackage/iwlagn/config
+  if PACKAGE_kmod-iwlagn
+
+	config IWL5000_FW
+		bool "Intel 5000 Firmware"
+		default y
+		help
+		  Download and install firmware for:
+		    Intel Wireless WiFi 5100AGN, 5300AGN, and 5350AGN
+
+	config IWL5150_FW
+		bool "Intel 5150 Firmware"
+		default y
+		help
+		  Download and install firmware for:
+		    Intel Wireless WiFi 5150AGN
+
+	config IWL1000_FW
+		bool "Intel 1000 Firmware"
+		default y
+		help
+		  Download and install firmware for:
+		    Intel Centrino Wireless-N 1000
+
+	config IWL6000_FW
+		bool "Intel 6000 Firmware"
+		default y
 		help
-		  This option will enable debug tracing output for the iwlwifi drivers
+		  Download and install firmware for:
+		    Intel Centrino Ultimate-N 6300 and Advanced-N 6200
 
-		  This will result in the kernel module being ~100k larger.  You can
-		  control which debug output is sent to the kernel log by setting the
-		  value in
+	config IWL6050_FW
+		bool "Intel 6050 Firmware"
+		default y
+		help
+		  Download and install firmware for:
+		    Intel Centrino Advanced-N + WiMAX 6250 and Wireless-N + WiMAX 6150
+
+	config IWL6005_FW
+		bool "Intel 6005 Firmware"
+		default y
+		help
+		  Download and install firmware for:
+		    Intel Centrino Advanced-N 6205
+
+	config IWL6030_FW
+		bool "Intel 6030 Firmware"
+		default y
+		help
+		  Download and install firmware for:
+		    Intel Centrino Advanced-N 6230, Wireless-N 1030, Wireless-N 130 and Advanced-N 6235
 
-			/sys/module/iwlwifi/parameters/debug
+	config IWL7260_FW
+		bool "Intel 7260 Firmware"
+		default y
+		help
+		  Download and install firmware for:
+		    Intel Dual Band Wireless-N 7260 and Intel Dual Band Wireless-AC 7260
 
-		  This entry will only exist if this option is enabled.
+	config IWL7265_FW
+		bool "Intel 7265 Firmware"
+		default y
+		help
+		  Download and install firmware for:
+		    Intel Wireless 7265
 
-		  To set a value, simply echo an 8-byte hex value to the same file:
+	config IWL100_FW
+		bool "Intel 100 Firmware"
+		default y
+		help
+		  Download and install firmware for:
+		    Intel Centrino Wireless-N 100
 
-			  % echo 0x43fff > /sys/module/iwlwifi/parameters/debug
+	config IWL2000_FW
+		bool "Intel 2000 Firmware"
+		default y
+		help
+		  Download and install firmware for:
+		    Intel Centrino Wireless-N 2200
 
-		  You can find the list of debug mask values in:
-			  drivers/net/wireless/intel/iwlwifi/iwl-debug.h
+	config IWL2030_FW
+		bool "Intel 2030 Firmware"
+		default y
+		help
+		  Download and install firmware for:
+		    Intel Centrino Wireless-N 2230
 
-		  If this is your first time using this driver, you should say Y here
-		  as the debug information can assist others in helping you resolve
-		  any problems you may encounter.
+	config IWL105_FW
+		bool "Intel 105 Firmware"
+		default y
+		help
+		  Download and install firmware for:
+		    Intel Centrino Wireless-N 105
 
-	config PACKAGE_IWLWIFI_DEBUGFS
-	        bool "iwlwifi debugfs support"
-		depends on PACKAGE_MAC80211_DEBUGFS
-		default n
+	config IWL135_FW
+		bool "Intel 135 Firmware"
+		default y
 		help
-		  Enable creation of debugfs files for the iwlwifi drivers. This
-		  is a low-impact option that allows getting insight into the
-		  driver's state at runtime.
+		  Download and install firmware for:
+		    Intel Centrino Wireless-N 135
 
+	config IWL3160_FW
+		bool "Intel 3160 Firmware"
+		default y
+		help
+		  Download and install firmware for:
+		    Intel Wireless 3160
   endif
 endef
 
@@ -854,7 +950,7 @@ define KernelPackage/iwl-legacy
   $(call KernelPackage/mac80211/Default)
   DEPENDS:= +kmod-mac80211 @PCI_SUPPORT
   TITLE:=Intel legacy Wireless support
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/intel/iwlegacy/iwlegacy.ko
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/iwlegacy/iwlegacy.ko
   AUTOLOAD:=$(call AutoProbe,iwlegacy)
 endef
 
@@ -864,9 +960,9 @@ endef
 
 define KernelPackage/iwl3945
   $(call KernelPackage/mac80211/Default)
-  DEPENDS:= +kmod-mac80211 +kmod-iwl-legacy +iwl3945-firmware
+  DEPENDS:= +kmod-mac80211 +kmod-iwl-legacy
   TITLE:=Intel iwl3945 Wireless support
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/intel/iwlegacy/iwl3945.ko
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/iwlegacy/iwl3945.ko
   AUTOLOAD:=$(call AutoProbe,iwl3945)
 endef
 
@@ -876,560 +972,577 @@ endef
 
 define KernelPackage/iwl4965
   $(call KernelPackage/mac80211/Default)
-  DEPENDS:= +kmod-mac80211 +kmod-iwl-legacy +@DRIVER_11N_SUPPORT +iwl4965-firmware
+  DEPENDS:= +kmod-mac80211 +kmod-iwl-legacy +@DRIVER_11N_SUPPORT
   TITLE:=Intel iwl4965 Wireless support
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/intel/iwlegacy/iwl4965.ko
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/iwlegacy/iwl4965.ko
   AUTOLOAD:=$(call AutoProbe,iwl4965)
 endef
 
-define KernelPackage/iwl4965/description
- iwl4965 kernel module for Intel 4965 support
+define KernelPackage/iwl4965/description
+ iwl4965 kernel module for Intel 4965 support
+endef
+
+
+define KernelPackage/mwl8k
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Driver for Marvell TOPDOG 802.11 Wireless cards
+  URL:=http://wireless.kernel.org/en/users/Drivers/mwl8k
+  DEPENDS+= @PCI_SUPPORT +kmod-mac80211 +@DRIVER_11N_SUPPORT
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/mwl8k.ko
+  AUTOLOAD:=$(call AutoProbe,mwl8k)
+endef
+
+define KernelPackage/mwl8k/description
+ Kernel modules for Marvell TOPDOG 802.11 Wireless cards
+endef
+
+
+define KernelPackage/mwifiex-pcie
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Driver for Marvell 802.11n/802.11ac PCIe Wireless cards
+  URL:=http://wireless.kernel.org/en/users/Drivers/mwifiex
+  DEPENDS+= @PCI_SUPPORT +kmod-mac80211 +@DRIVER_11N_SUPPORT
+  FILES:= \
+	$(PKG_BUILD_DIR)/drivers/net/wireless/mwifiex/mwifiex.ko \
+	$(PKG_BUILD_DIR)/drivers/net/wireless/mwifiex/mwifiex_pcie.ko
+  AUTOLOAD:=$(call AutoProbe,mwifiex_pcie)
+endef
+
+define KernelPackage/mwifiex-pcie/description
+ Kernel modules for Marvell 802.11n/802.11ac PCIe Wireless cards
+endef
+
+
+define KernelPackage/wlcore
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=TI common driver part
+  DEPENDS+= +kmod-mac80211 +@DRIVER_11N_SUPPORT
+  KCONFIG:= \
+	CONFIG_WL_TI=y \
+	CONFIG_WILINK_PLATFORM_DATA=y \
+	CONFIG_WLCORE=m \
+	CONFIG_WLCORE_SDIO=m
+  FILES:= \
+	$(LINUX_DIR)/drivers/net/wireless/ti/wlcore/wlcore.ko \
+	$(LINUX_DIR)/drivers/net/wireless/ti/wlcore/wlcore_sdio.ko
+  AUTOLOAD:=$(call AutoProbe,wlcore wlcore_sdio)
+endef
+
+define KernelPackage/wlcore/description
+ This module contains some common parts needed by TI Wireless drivers.
+endef
+
+define KernelPackage/wl12xx
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Driver for TI WL12xx
+  URL:=http://wireless.kernel.org/en/users/Drivers/wl12xx
+  DEPENDS+= +kmod-wlcore
+  KCONFIG:= \
+	CONFIG_WL12XX=m
+  FILES:=$(LINUX_DIR)/drivers/net/wireless/ti/wl12xx/wl12xx.ko
+   AUTOLOAD:=$(call AutoProbe,wl12xx)
+endef
+
+define KernelPackage/wl12xx/description
+ Kernel modules for TI WL12xx
+endef
+
+define KernelPackage/wl18xx
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Driver for TI WL18xx
+  URL:=http://wireless.kernel.org/en/users/Drivers/wl18xx
+  DEPENDS+= +kmod-wlcore
+  KCONFIG:= \
+	CONFIG_WL18XX=m
+  FILES:=$(LINUX_DIR)/drivers/net/wireless/ti/wl18xx/wl18xx.ko
+  AUTOLOAD:=$(call AutoProbe,wl18xx)
+endef
+
+define KernelPackage/wl18xx/description
+ Kernel modules for TI WL18xx
+endef
+
+
+#Broadcom firmware
+ifneq ($(CONFIG_B43_FW_6_30),)
+  PKG_B43_FWV4_NAME:=broadcom-wl
+  PKG_B43_FWV4_VERSION:=6.30.163.46
+  PKG_B43_FWV4_OBJECT:=$(PKG_B43_FWV4_NAME)-$(PKG_B43_FWV4_VERSION).wl_apsta.o
+  PKG_B43_FWV4_SOURCE:=$(PKG_B43_FWV4_NAME)-$(PKG_B43_FWV4_VERSION).tar.bz2
+  PKG_B43_FWV4_SOURCE_URL:=http://www.lwfinger.com/b43-firmware/
+  PKG_B43_FWV4_MD5SUM:=6fe97e9368d25342a1ab943d3cf3496d
+else
+ifneq ($(CONFIG_B43_FW_5_10),)
+  PKG_B43_FWV4_NAME:=broadcom-wl
+  PKG_B43_FWV4_VERSION:=5.10.56.27.3
+  PKG_B43_FWV4_OBJECT:=$(PKG_B43_FWV4_NAME)-$(PKG_B43_FWV4_VERSION)/driver/wl_apsta/wl_prebuilt.o
+  PKG_B43_FWV4_SOURCE:=$(PKG_B43_FWV4_NAME)-$(PKG_B43_FWV4_VERSION)_mipsel.tar.bz2
+  PKG_B43_FWV4_SOURCE_URL:=http://mirror2.openwrt.org/sources/
+  PKG_B43_FWV4_MD5SUM:=3363e3a6b3d9d73c49dea870c7834eac
+else
+ifneq ($(CONFIG_B43_FW_4_178),)
+  PKG_B43_FWV4_NAME:=broadcom-wl
+  PKG_B43_FWV4_VERSION:=4.178.10.4
+  PKG_B43_FWV4_OBJECT:=$(PKG_B43_FWV4_NAME)-$(PKG_B43_FWV4_VERSION)/linux/wl_apsta.o
+  PKG_B43_FWV4_SOURCE:=$(PKG_B43_FWV4_NAME)-$(PKG_B43_FWV4_VERSION).tar.bz2
+  PKG_B43_FWV4_SOURCE_URL:=http://mirror2.openwrt.org/sources/
+  PKG_B43_FWV4_MD5SUM:=14477e8cbbb91b11896affac9b219fdb
+else
+ifneq ($(CONFIG_B43_FW_5_100_138),)
+  PKG_B43_FWV4_NAME:=broadcom-wl
+  PKG_B43_FWV4_VERSION:=5.100.138
+  PKG_B43_FWV4_OBJECT:=$(PKG_B43_FWV4_NAME)-$(PKG_B43_FWV4_VERSION)/linux/wl_apsta.o
+  PKG_B43_FWV4_SOURCE:=$(PKG_B43_FWV4_NAME)-$(PKG_B43_FWV4_VERSION).tar.bz2
+  PKG_B43_FWV4_SOURCE_URL:=http://www.lwfinger.com/b43-firmware/
+  PKG_B43_FWV4_MD5SUM:=f4e357b09eaf5d8b1f1920cf3493a555
+else
+  PKG_B43_FWV4_NAME:=broadcom-wl
+  PKG_B43_FWV4_VERSION:=4.150.10.5
+  PKG_B43_FWV4_OBJECT:=$(PKG_B43_FWV4_NAME)-$(PKG_B43_FWV4_VERSION)/driver/wl_apsta_mimo.o
+  PKG_B43_FWV4_SOURCE:=$(PKG_B43_FWV4_NAME)-$(PKG_B43_FWV4_VERSION).tar.bz2
+  PKG_B43_FWV4_SOURCE_URL:=http://mirror2.openwrt.org/sources/
+  PKG_B43_FWV4_MD5SUM:=0c6ba9687114c6b598e8019e262d9a60
+endif
+endif
+endif
+endif
+ifneq ($(CONFIG_B43_OPENFIRMWARE),)
+  PKG_B43_FWV4_NAME:=broadcom-wl
+  PKG_B43_FWV4_VERSION:=5.2
+  PKG_B43_FWV4_OBJECT:=openfwwf-$(PKG_B43_FWV4_VERSION)
+  PKG_B43_FWV4_SOURCE:=openfwwf-$(PKG_B43_FWV4_VERSION).tar.gz
+  PKG_B43_FWV4_SOURCE_URL:=http://www.ing.unibs.it/openfwwf/firmware/
+  PKG_B43_FWV4_MD5SUM:=e045a135453274e439ae183f8498b0fa
+endif
+
+
+PKG_B43_FWV3_NAME:=wl_apsta
+PKG_B43_FWV3_VERSION:=3.130.20.0
+PKG_B43_FWV3_SOURCE:=$(PKG_B43_FWV3_NAME)-$(PKG_B43_FWV3_VERSION).o
+PKG_B43_FWV3_SOURCE_URL:=http://downloads.openwrt.org/sources/
+PKG_B43_FWV3_MD5SUM:=e08665c5c5b66beb9c3b2dd54aa80cb3
+
+define Download/b43
+  FILE:=$(PKG_B43_FWV4_SOURCE)
+  URL:=$(PKG_B43_FWV4_SOURCE_URL)
+  MD5SUM:=$(PKG_B43_FWV4_MD5SUM)
+endef
+$(eval $(call Download,b43))
+
+define Download/b43legacy
+  FILE:=$(PKG_B43_FWV3_SOURCE)
+  URL:=$(PKG_B43_FWV3_SOURCE_URL)
+  MD5SUM:=$(PKG_B43_FWV3_MD5SUM)
 endef
+$(eval $(call Download,b43legacy))
 
 
-define KernelPackage/lib80211
+define KernelPackage/b43
   $(call KernelPackage/mac80211/Default)
-  TITLE:=802.11 Networking stack
-  DEPENDS:=+kmod-cfg80211 +kmod-crypto-hash
-  FILES:= \
-	$(PKG_BUILD_DIR)/net/wireless/lib80211.ko \
-	$(PKG_BUILD_DIR)/net/wireless/lib80211_crypt_wep.ko \
-	$(PKG_BUILD_DIR)/net/wireless/lib80211_crypt_ccmp.ko \
-	$(PKG_BUILD_DIR)/net/wireless/lib80211_crypt_tkip.ko
-  AUTOLOAD:=$(call AutoProbe, \
-	lib80211 \
-	lib80211_crypt_wep \
-	lib80211_crypt_ccmp \
-	lib80211_crypt_tkip \
-  )
-endef
-
-define KernelPackage/lib80211/description
- Kernel modules for 802.11 Networking stack
- Includes:
- - lib80211
- - lib80211_crypt_wep
- - lib80211_crypt_tkip
- - lib80211_crytp_ccmp
+  TITLE:=Broadcom 43xx wireless support
+  URL:=https://wireless.wiki.kernel.org/en/users/drivers/b43
+  KCONFIG:= \
+  	CONFIG_HW_RANDOM=y
+  # Depend on PCI_SUPPORT to make sure we can select kmod-bcma or kmod-ssb
+  DEPENDS += \
+	@PCI_SUPPORT +kmod-mac80211 \
+	$(if $(CONFIG_PACKAGE_B43_USE_SSB),+kmod-ssb) \
+	$(if $(CONFIG_PACKAGE_B43_USE_BCMA),+kmod-bcma)
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/b43/b43.ko
+  AUTOLOAD:=$(call AutoProbe,b43)
+  MENU:=1
 endef
 
+define KernelPackage/b43/config
 
-define KernelPackage/libipw
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=libipw for ipw2100 and ipw2200
-  DEPENDS:=@PCI_SUPPORT +kmod-crypto-michael-mic +kmod-lib80211 +kmod-cfg80211 +@DRIVER_WEXT_SUPPORT @!BIG_ENDIAN
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/intel/ipw2x00/libipw.ko
-  AUTOLOAD:=$(call AutoProbe,libipw)
-endef
+config PACKAGE_B43_USE_SSB
+	select PACKAGE_kmod-ssb
+	tristate
+	depends on !TARGET_brcm47xx && !TARGET_brcm63xx
+	default PACKAGE_kmod-b43 if PACKAGE_B43_BUSES_BCMA_AND_SSB
+	default PACKAGE_kmod-b43 if PACKAGE_B43_BUSES_SSB
 
-define KernelPackage/libipw/description
- Hardware independent IEEE 802.11 networking stack for ipw2100 and ipw2200.
-endef
+config PACKAGE_B43_USE_BCMA
+	select PACKAGE_kmod-bcma
+	tristate
+	depends on !TARGET_brcm47xx && !TARGET_bcm53xx
+	default PACKAGE_kmod-b43 if PACKAGE_B43_BUSES_BCMA_AND_SSB
+	default PACKAGE_kmod-b43 if PACKAGE_B43_BUSES_BCMA
 
-IPW2100_NAME:=ipw2100-fw
-IPW2100_VERSION:=1.3
+  if PACKAGE_kmod-b43
 
-define Download/ipw2100
-  URL:=http://bughost.org/firmware/
-  FILE:=$(IPW2100_NAME)-$(IPW2100_VERSION).tgz
-  MD5SUM=46aa75bcda1a00efa841f9707bbbd113
-endef
-$(eval $(call Download,ipw2100))
+	choice
+		prompt "b43 firmware version"
+		default B43_FW_5_100_138
+		help
+		  This option allows you to select the version of the b43 firmware.
 
-define KernelPackage/ipw2100
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Intel IPW2100 driver
-  DEPENDS:=@PCI_SUPPORT +kmod-libipw
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/intel/ipw2x00/ipw2100.ko
-  AUTOLOAD:=$(call AutoProbe,ipw2100)
-endef
+	config B43_FW_4_150
+		bool "Firmware 410.2160 from driver 4.150.10.5 (old stable)"
+		help
+		  Old stable firmware for BCM43xx devices.
 
-define KernelPackage/ipw2100/description
- Kernel support for Intel IPW2100
- Includes:
- - ipw2100
-endef
+		  If unsure, select this.
 
-IPW2200_NAME:=ipw2200-fw
-IPW2200_VERSION:=3.1
+	config B43_FW_4_178
+		bool "Firmware 478.104 from driver 4.178.10.4"
+		help
+		  Older firmware for BCM43xx devices.
 
-define Download/ipw2200
-  URL:=http://bughost.org/firmware/
-  FILE:=$(IPW2200_NAME)-$(IPW2200_VERSION).tgz
-  MD5SUM=eaba788643c7cc7483dd67ace70f6e99
-endef
-$(eval $(call Download,ipw2200))
+		  If unsure, select the "stable" firmware.
 
-define KernelPackage/ipw2200
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Intel IPW2200 driver
-  DEPENDS:=@PCI_SUPPORT +kmod-libipw
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/intel/ipw2x00/ipw2200.ko
-  AUTOLOAD:=$(call AutoProbe,ipw2200)
-endef
+	config B43_FW_5_10
+		bool "Firmware 508.1084 from driver 5.10.56.27"
+		help
+		  Older firmware for BCM43xx devices.
 
-define KernelPackage/ipw2200/description
- Kernel support for Intel IPW2200
- Includes:
- - ipw2200
-endef
+		  If unsure, select the "stable" firmware.
 
+	config B43_FW_5_100_138
+		bool "Firmware 666.2 from driver 5.100.138 (stable)"
+		help
+		  The currently default firmware for BCM43xx devices.
 
-define KernelPackage/libertas-usb
-  $(call KernelPackage/mac80211/Default)
-  DEPENDS+= @USB_SUPPORT +kmod-cfg80211 +kmod-usb-core +kmod-lib80211 +@DRIVER_WEXT_SUPPORT +libertas-usb-firmware
-  TITLE:=Marvell 88W8015 Wireless Driver
-  FILES:= \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/marvell/libertas/libertas.ko \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/marvell/libertas/usb8xxx.ko
-  AUTOLOAD:=$(call AutoProbe,libertas usb8xxx)
-endef
+		  This firmware currently gets most of the testing and is needed for some N-PHY devices.
 
-define KernelPackage/libertas-sdio
-  $(call KernelPackage/mac80211/Default)
-  DEPENDS+= +kmod-cfg80211 +kmod-lib80211 +kmod-mmc +@DRIVER_WEXT_SUPPORT @!TARGET_uml +libertas-sdio-firmware
-  TITLE:=Marvell 88W8686 Wireless Driver
-  FILES:= \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/marvell/libertas/libertas.ko \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/marvell/libertas/libertas_sdio.ko
-  AUTOLOAD:=$(call AutoProbe,libertas libertas_sdio)
-endef
+		  If unsure, select the this firmware.
 
-define KernelPackage/libertas-spi
-  $(call KernelPackage/mac80211/Default)
-  SUBMENU:=Wireless Drivers
-  DEPENDS+= +kmod-cfg80211 +kmod-lib80211 +@DRIVER_WEXT_SUPPORT @!TARGET_uml +libertas-spi-firmware
-  KCONFIG := \
-	CONFIG_SPI=y \
-	CONFIG_SPI_MASTER=y
-  TITLE:=Marvell 88W8686 SPI Wireless Driver
-  FILES:= \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/marvell/libertas/libertas.ko \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/marvell/libertas/libertas_spi.ko
-  AUTOLOAD:=$(call AutoProbe,libertas libertas_spi)
-endef
+	config B43_FW_6_30
+		bool "Firmware 784.2 from driver 6.30.163.46 (experimental)"
+		help
+		  Newer experimental firmware for BCM43xx devices.
 
-define KernelPackage/mac80211-hwsim
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=mac80211 HW simulation device
-  DEPENDS+= +kmod-mac80211 +@DRIVER_11N_SUPPORT
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/mac80211_hwsim.ko
-  AUTOLOAD:=$(call AutoProbe,mac80211_hwsim)
-endef
+		  This firmware is mostly untested.
 
+		  If unsure, select the "stable" firmware.
 
-define KernelPackage/mt7601u
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=MT7601U-based USB dongles Wireless Driver
-  DEPENDS+= +kmod-mac80211 +@DRIVER_11N_SUPPORT @USB_SUPPORT +kmod-usb-core +mt7601u-firmware
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/mediatek/mt7601u/mt7601u.ko
-  AUTOLOAD:=$(call AutoProbe,mt7601u)
-endef
+	config B43_OPENFIRMWARE
+		bool "Open FirmWare for WiFi networks"
+		help
+		  Opensource firmware for BCM43xx devices.
 
+		  Do _not_ select this, unless you know what you are doing.
+		  The Opensource firmware is not suitable for embedded devices, yet.
+		  It does not support QoS, which is bad for AccessPoints.
+		  It does not support hardware crypto acceleration, which is a showstopper
+		  for embedded devices with low CPU resources.
 
-define KernelPackage/mwl8k
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Driver for Marvell TOPDOG 802.11 Wireless cards
-  URL:=http://wireless.kernel.org/en/users/Drivers/mwl8k
-  DEPENDS+= @PCI_SUPPORT +kmod-mac80211 +@DRIVER_11N_SUPPORT +mwl8k-firmware
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/marvell/mwl8k.ko
-  AUTOLOAD:=$(call AutoProbe,mwl8k)
-endef
+		  If unsure, select the "stable" firmware.
 
-define KernelPackage/mwl8k/description
- Kernel modules for Marvell TOPDOG 802.11 Wireless cards
-endef
+	endchoice
 
+	config B43_FW_SQUASH
+		bool "Remove unnecessary firmware files"
+		depends on !B43_OPENFIRMWARE
+		default y
+		help
+		  This options allows you to remove unnecessary b43 firmware files
+		  from the final rootfs image. This can reduce the rootfs size by
+		  up to 200k.
 
-define KernelPackage/mwifiex-pcie
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Driver for Marvell 802.11n/802.11ac PCIe Wireless cards
-  URL:=http://wireless.kernel.org/en/users/Drivers/mwifiex
-  DEPENDS+= @PCI_SUPPORT +kmod-mac80211 +@DRIVER_11N_SUPPORT +mwifiex-pcie-firmware
-  FILES:= \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/marvell/mwifiex/mwifiex.ko \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/marvell/mwifiex/mwifiex_pcie.ko
-  AUTOLOAD:=$(call AutoProbe,mwifiex_pcie)
-endef
+		  If unsure, say Y.
 
-define KernelPackage/mwifiex-pcie/description
- Kernel modules for Marvell 802.11n/802.11ac PCIe Wireless cards
-endef
+	config B43_FW_SQUASH_COREREVS
+		string "Core revisions to include"
+		depends on B43_FW_SQUASH
+		default "5,6,7,8,9,10,11,13,15" if TARGET_brcm47xx_legacy
+		default "16,28,29,30" if TARGET_brcm47xx_mips74k
+		default "5,6,7,8,9,10,11,13,15,16,28,29,30"
+		help
+		  This is a comma seperated list of core revision numbers.
 
-define KernelPackage/p54/Default
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Prism54 Drivers
-endef
+		  Example (keep files for rev5 only):
+		    5
 
-define KernelPackage/p54/description
-  Kernel module for Prism54 chipsets (mac80211)
-endef
+		  Example (keep files for rev5 and rev11):
+		    5,11
 
-define KernelPackage/p54-common
-  $(call KernelPackage/p54/Default)
-  DEPENDS+= @PCI_SUPPORT||@USB_SUPPORT||@TARGET_omap24xx +kmod-mac80211 +kmod-lib-crc-ccitt
-  TITLE+= (COMMON)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/intersil/p54/p54common.ko
-endef
+	config B43_FW_SQUASH_PHYTYPES
+		string "PHY types to include"
+		depends on B43_FW_SQUASH
+		default "G,N,LP" if TARGET_brcm47xx_legacy
+		default "N,HT" if TARGET_brcm47xx_mips74k
+		default "G,N,LP,HT"
+		help
+		  This is a comma seperated list of PHY types:
+		    A  => A-PHY
+		    AG => Dual A-PHY G-PHY
+		    G  => G-PHY
+		    LP => LP-PHY
+		    N  => N-PHY
+		    HT  => HT-PHY
+		    LCN  => LCN-PHY
+		    LCN40  => LCN40-PHY
+		    AC  => AC-PHY
 
-define KernelPackage/p54-pci
-  $(call KernelPackage/p54/Default)
-  TITLE+= (PCI)
-  DEPENDS+= @PCI_SUPPORT +kmod-p54-common +p54-pci-firmware
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/intersil/p54/p54pci.ko
-  AUTOLOAD:=$(call AutoProbe,p54pci)
-endef
+		  Example (keep files for G-PHY only):
+		    G
 
-define KernelPackage/p54-usb
-  $(call KernelPackage/p54/Default)
-  TITLE+= (USB)
-  DEPENDS+= @USB_SUPPORT +kmod-usb-core +kmod-p54-common +p54-usb-firmware
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/intersil/p54/p54usb.ko
-  AUTOLOAD:=$(call AutoProbe,p54usb)
-endef
+		  Example (keep files for G-PHY and N-PHY):
+		    G,N
 
-define KernelPackage/p54-spi
-  $(call KernelPackage/p54/Default)
-  TITLE+= (SPI)
-  DEPENDS+= @TARGET_omap24xx +kmod-p54-common +p54-spi-firmware
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/intersil/p54/p54spi.ko
-  AUTOLOAD:=$(call AutoProbe,p54spi)
-endef
+	choice
+		prompt "Supported buses"
+		default PACKAGE_B43_BUSES_BCMA_AND_SSB
+		help
+		  This allows choosing buses that b43 should support.
 
-define KernelPackage/rt2x00/Default
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Ralink Drivers for RT2x00 cards
-endef
+	config PACKAGE_B43_BUSES_BCMA_AND_SSB
+		depends on !TARGET_brcm47xx_legacy && !TARGET_brcm47xx_mips74k && !TARGET_bcm53xx
+		bool "BCMA and SSB"
 
-define KernelPackage/rt2x00-lib
-$(call KernelPackage/rt2x00/Default)
-  DEPENDS+= @(PCI_SUPPORT||USB_SUPPORT||TARGET_ramips) +kmod-mac80211 +kmod-lib-crc-itu-t
-  TITLE+= (LIB)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ralink/rt2x00/rt2x00lib.ko
-  MENU:=1
-endef
+	config PACKAGE_B43_BUSES_BCMA
+		depends on !TARGET_brcm47xx_legacy
+		bool "BCMA only"
 
-define KernelPackage/rt2x00-lib/config
-  if PACKAGE_kmod-rt2x00-lib
+	config PACKAGE_B43_BUSES_SSB
+		depends on !TARGET_brcm47xx_mips74k && !TARGET_bcm53xx
+		bool "SSB only"
 
-	config PACKAGE_RT2X00_LIB_DEBUGFS
-		bool "Enable rt2x00 debugfs support"
-		depends on PACKAGE_MAC80211_DEBUGFS
+	endchoice
+
+	config PACKAGE_B43_DEBUG
+		bool "Enable debug output and debugfs for b43"
+		default n
 		help
-		  Enable creation of debugfs files for the rt2x00 drivers.
-		  These debugfs files support both reading and writing of the
-		  most important register types of the rt2x00 hardware.
+		  Enable additional debug output and runtime sanity checks for b43
+		  and enables the debugfs interface.
 
-	config PACKAGE_RT2X00_DEBUG
-		bool "Enable rt2x00 debug output"
+		  If unsure, say N.
+
+	config PACKAGE_B43_PIO
+		bool "Enable support for PIO transfer mode"
+		default n
 		help
-		  Enable debugging output for all rt2x00 modules
+		  Enable support for using PIO instead of DMA. Unless you have DMA
+		  transfer problems you don't need this.
 
-  endif
-endef
+		  If unsure, say N.
 
-define KernelPackage/rt2x00-mmio
-$(call KernelPackage/rt2x00/Default)
-  DEPENDS+= @(PCI_SUPPORT||TARGET_ramips) +kmod-rt2x00-lib +kmod-eeprom-93cx6
-  HIDDEN:=1
-  TITLE+= (MMIO)
-  FILES:= $(PKG_BUILD_DIR)/drivers/net/wireless/ralink/rt2x00/rt2x00mmio.ko
-endef
+	config PACKAGE_B43_PHY_G
+		bool "Enable support for G-PHYs"
+		default n if TARGET_brcm47xx_mips74k
+		default y
+		help
+		  Enable support for G-PHY. This includes support for the following devices:
+		  PCI: BCM4306, BCM4311, BCM4318
+		  SoC: BCM5352E, BCM4712
 
-define KernelPackage/rt2x00-pci
-$(call KernelPackage/rt2x00/Default)
-  DEPENDS+= @PCI_SUPPORT +kmod-rt2x00-mmio +kmod-rt2x00-lib
-  HIDDEN:=1
-  TITLE+= (PCI)
-  FILES:= $(PKG_BUILD_DIR)/drivers/net/wireless/ralink/rt2x00/rt2x00pci.ko
-  AUTOLOAD:=$(call AutoProbe,rt2x00pci)
-endef
+		  If unsure, say Y.
 
-define KernelPackage/rt2x00-usb
-$(call KernelPackage/rt2x00/Default)
-  DEPENDS+= @USB_SUPPORT +kmod-rt2x00-lib +kmod-usb-core
-  HIDDEN:=1
-  TITLE+= (USB)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ralink/rt2x00/rt2x00usb.ko
-  AUTOLOAD:=$(call AutoProbe,rt2x00usb)
-endef
+	config PACKAGE_B43_PHY_N
+		bool "Enable support for N-PHYs"
+		default y
+		help
+		  Enable support for N-PHY. This includes support for the following devices:
+		  PCI: BCM4321, BCM4322, BCM43222, BCM43224, BCM43225
+		  SoC: BCM4716, BCM4717, BCM4718
 
-define KernelPackage/rt2800-lib
-$(call KernelPackage/rt2x00/Default)
-  DEPENDS+= @(PCI_SUPPORT||USB_SUPPORT||TARGET_ramips) +kmod-rt2x00-lib +kmod-lib-crc-ccitt +@DRIVER_11N_SUPPORT
-  HIDDEN:=1
-  TITLE+= (rt2800 LIB)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ralink/rt2x00/rt2800lib.ko
-endef
+		  Currently only 11g speed is available.
 
-define KernelPackage/rt2400-pci
-$(call KernelPackage/rt2x00/Default)
-  DEPENDS+= @PCI_SUPPORT +kmod-rt2x00-pci
-  TITLE+= (RT2400 PCI)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ralink/rt2x00/rt2400pci.ko
-  AUTOLOAD:=$(call AutoProbe,rt2400pci)
-endef
+		  If unsure, say Y.
 
-define KernelPackage/rt2500-pci
-$(call KernelPackage/rt2x00/Default)
-  DEPENDS+= @PCI_SUPPORT +kmod-rt2x00-pci
-  TITLE+= (RT2500 PCI)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ralink/rt2x00/rt2500pci.ko
-  AUTOLOAD:=$(call AutoProbe,rt2500pci)
-endef
+	config PACKAGE_B43_PHY_LP
+		bool "Enable support for LP-PHYs"
+		default n if TARGET_brcm47xx_mips74k
+		default y
+		help
+		  Enable support for LP-PHY. This includes support for the following devices:
+		  PCI: BCM4312
+		  SoC: BCM5354
 
-define KernelPackage/rt2500-usb
-$(call KernelPackage/rt2x00/Default)
-  DEPENDS+= @USB_SUPPORT +kmod-rt2x00-usb
-  TITLE+= (RT2500 USB)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ralink/rt2x00/rt2500usb.ko
-  AUTOLOAD:=$(call AutoProbe,rt2500usb)
-endef
+		  If unsure, say Y.
 
-define KernelPackage/rt2800-mmio
-$(call KernelPackage/rt2x00/Default)
-  TITLE += (RT28xx/RT3xxx MMIO)
-  DEPENDS += +kmod-rt2800-lib +kmod-rt2x00-mmio
-  HIDDEN:=1
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ralink/rt2x00/rt2800mmio.ko
-endef
+	config PACKAGE_B43_PHY_HT
+		bool "Enable support for HT-PHYs"
+		default n if TARGET_brcm47xx_legacy
+		default y
+		help
+		  Enable support for HT-PHY. This includes support for the following devices:
+		  PCI: BCM4331
 
-define KernelPackage/rt2800-soc
-$(call KernelPackage/rt2x00/Default)
-  DEPENDS += @(TARGET_ramips_rt288x||TARGET_ramips_rt305x||TARGET_ramips_rt3883||TARGET_ramips_mt7620) +kmod-rt2800-mmio +kmod-rt2800-lib
-  TITLE += (RT28xx/RT3xxx SoC)
-  FILES := \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/ralink/rt2x00/rt2x00soc.ko \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/ralink/rt2x00/rt2800soc.ko
-  AUTOLOAD:=$(call AutoProbe,rt2800soc)
-endef
+		  Currently only 11g speed is available.
 
-define KernelPackage/rt2800-pci
-$(call KernelPackage/rt2x00/Default)
-  DEPENDS+= @PCI_SUPPORT +kmod-rt2x00-pci +kmod-rt2800-lib +kmod-rt2800-mmio +rt2800-pci-firmware
-  TITLE+= (RT2860 PCI)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ralink/rt2x00/rt2800pci.ko
-  AUTOLOAD:=$(call AutoProbe,rt2800pci)
-endef
+		  If unsure, say Y.
 
-define KernelPackage/rt2800-usb
-$(call KernelPackage/rt2x00/Default)
-  DEPENDS+= @USB_SUPPORT +kmod-rt2x00-usb +kmod-rt2800-lib +kmod-lib-crc-ccitt +rt2800-usb-firmware
-  TITLE+= (RT2870 USB)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ralink/rt2x00/rt2800usb.ko
-  AUTOLOAD:=$(call AutoProbe,rt2800usb)
-endef
+	config PACKAGE_B43_PHY_LCN
+		bool "Enable support for LCN-PHYs"
+		depends on BROKEN
+		default n
+		help
+		  Currently broken.
 
+		  If unsure, say N.
 
-define KernelPackage/rt61-pci
-$(call KernelPackage/rt2x00/Default)
-  DEPENDS+= @PCI_SUPPORT +kmod-rt2x00-pci +rt61-pci-firmware
-  TITLE+= (RT2x61 PCI)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ralink/rt2x00/rt61pci.ko
-  AUTOLOAD:=$(call AutoProbe,rt61pci)
+  endif
 endef
 
-define KernelPackage/rt73-usb
-  $(call KernelPackage/rt2x00/Default)
-  DEPENDS+= @USB_SUPPORT +kmod-rt2x00-usb +rt73-usb-firmware
-  TITLE+= (RT73 USB)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ralink/rt2x00/rt73usb.ko
-  AUTOLOAD:=$(call AutoProbe,rt73usb)
+define KernelPackage/b43/description
+Kernel module for Broadcom 43xx wireless support (mac80211 stack) new
 endef
 
-
-define KernelPackage/rtl818x/Default
+define KernelPackage/b43legacy
   $(call KernelPackage/mac80211/Default)
-  TITLE:=Realtek Drivers for RTL818x devices
-  URL:=http://wireless.kernel.org/en/users/Drivers/rtl8187
-  DEPENDS+= +kmod-eeprom-93cx6 +kmod-mac80211
+  TITLE:=Broadcom 43xx-legacy wireless support
+  URL:=https://wireless.wiki.kernel.org/en/users/drivers/b43
+  KCONFIG:= \
+  	CONFIG_HW_RANDOM=y
+  DEPENDS+= +kmod-mac80211 +!(TARGET_brcm47xx||TARGET_brcm63xx):kmod-ssb
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/b43legacy/b43legacy.ko
+  AUTOLOAD:=$(call AutoProbe,b43legacy)
+  MENU:=1
 endef
 
-define KernelPackage/rtl8180
-  $(call KernelPackage/rtl818x/Default)
-  DEPENDS+= @PCI_SUPPORT
-  TITLE+= (RTL8180 PCI)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtl818x/rtl8180/rtl818x_pci.ko
-  AUTOLOAD:=$(call AutoProbe,rtl818x_pci)
-endef
+define KernelPackage/b43legacy/config
+  if PACKAGE_kmod-b43legacy
 
-define KernelPackage/rtl8187
-$(call KernelPackage/rtl818x/Default)
-  DEPENDS+= @USB_SUPPORT +kmod-usb-core
-  TITLE+= (RTL8187 USB)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtl818x/rtl8187/rtl8187.ko
-  AUTOLOAD:=$(call AutoProbe,rtl8187)
-endef
+	config B43LEGACY_FW_SQUASH
+		bool "Remove unnecessary firmware files"
+		default y
+		help
+		  This options allows you to remove unnecessary b43legacy firmware files
+		  from the final rootfs image. This can reduce the rootfs size by
+		  up to 50k.
 
-define KernelPackage/rtlwifi/config
-	config PACKAGE_RTLWIFI_DEBUG
-		bool "Realtek wireless debugging"
-		depends on PACKAGE_kmod-rtlwifi
+		  If unsure, say Y.
+
+	config B43LEGACY_FW_SQUASH_COREREVS
+		string "Core revisions to include"
+		depends on B43LEGACY_FW_SQUASH
+		default "1,2,3,4"
 		help
-		  Say Y, if you want to debug realtek wireless drivers.
+		  This is a comma seperated list of core revision numbers.
 
-endef
+		  Example (keep files for rev4 only):
+		    4
 
-define KernelPackage/rtlwifi
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Realtek common driver part
-  DEPENDS+= @(PCI_SUPPORT||USB_SUPPORT) +kmod-mac80211 +@DRIVER_11N_SUPPORT
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtlwifi/rtlwifi.ko
-  HIDDEN:=1
-endef
+		  Example (keep files for rev2 and rev4):
+		    2,4
 
-define KernelPackage/rtlwifi-pci
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Realtek common driver part (PCI support)
-  DEPENDS+= @PCI_SUPPORT +kmod-rtlwifi
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtlwifi/rtl_pci.ko
-  AUTOLOAD:=$(call AutoProbe,rtl_pci)
-  HIDDEN:=1
+  endif
 endef
 
-define KernelPackage/rtlwifi-usb
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Realtek common driver part (USB support)
-  DEPENDS+= @USB_SUPPORT +kmod-usb-core +kmod-rtlwifi
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtlwifi/rtl_usb.ko
-  AUTOLOAD:=$(call AutoProbe,rtl_usb)
-  HIDDEN:=1
+define KernelPackage/b43legacy/description
+Kernel module for Broadcom 43xx-legacy wireless support (mac80211 stack) new
 endef
 
-define KernelPackage/rtl8192c-common
+
+define KernelPackage/brcmutil
   $(call KernelPackage/mac80211/Default)
-  TITLE:=Realtek RTL8192CE/RTL8192CU common support module
-  DEPENDS+= +kmod-rtlwifi
-  FILES:= $(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtlwifi/rtl8192c/rtl8192c-common.ko
-  HIDDEN:=1
+  TITLE:=Broadcom IEEE802.11n common driver parts
+  URL:=https://wireless.wiki.kernel.org/en/users/drivers/brcm80211
+  DEPENDS+=@PCI_SUPPORT||USB_SUPPORT
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/brcm80211/brcmutil/brcmutil.ko
+  AUTOLOAD:=$(call AutoProbe,brcmutil)
+  MENU:=1
 endef
 
-define KernelPackage/rtl8192ce
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Realtek RTL8192CE/RTL8188CE support
-  DEPENDS+= +kmod-rtlwifi-pci +kmod-rtl8192c-common +rtl8192ce-firmware
-  FILES:= $(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtlwifi/rtl8192ce/rtl8192ce.ko
-  AUTOLOAD:=$(call AutoProbe,rtl8192ce)
+define KernelPackage/brcmutil/description
+ This module contains some common parts needed by Broadcom Wireless drivers brcmsmac and brcmfmac.
 endef
 
-define KernelPackage/rtl8192se
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Realtek RTL8192SE/RTL8191SE support
-  DEPENDS+= +kmod-rtlwifi-pci +rtl8192se-firmware
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtlwifi/rtl8192se/rtl8192se.ko
-  AUTOLOAD:=$(call AutoProbe,rtl8192se)
+define KernelPackage/brcmutil/config
+  if PACKAGE_kmod-brcmutil
+
+	config PACKAGE_BRCM80211_DEBUG
+		bool "Broadcom wireless driver debugging"
+		help
+		  Say Y, if you want to debug brcmsmac and brcmfmac wireless driver.
+
+  endif
 endef
 
-define KernelPackage/rtl8192de
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Realtek RTL8192DE/RTL8188DE support
-  DEPENDS+= +kmod-rtlwifi-pci +rtl8192de-firmware
-  FILES:= $(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtlwifi/rtl8192de/rtl8192de.ko
-  AUTOLOAD:=$(call AutoProbe,rtl8192de)
+PKG_BRCMSMAC_FW_NAME:=broadcom-wl
+PKG_BRCMSMAC_FW_VERSION:=5.100.138
+PKG_BRCMSMAC_FW_OBJECT:=$(PKG_BRCMSMAC_FW_NAME)-$(PKG_BRCMSMAC_FW_VERSION)/linux/wl_apsta.o
+PKG_BRCMSMAC_FW_SOURCE:=$(PKG_BRCMSMAC_FW_NAME)-$(PKG_BRCMSMAC_FW_VERSION).tar.bz2
+PKG_BRCMSMAC_FW_SOURCE_URL:=http://www.lwfinger.com/b43-firmware/
+PKG_BRCMSMAC_FW_MD5SUM:=f4e357b09eaf5d8b1f1920cf3493a555
+
+define Download/brcmsmac
+  FILE:=$(PKG_BRCMSMAC_FW_SOURCE)
+  URL:=$(PKG_BRCMSMAC_FW_SOURCE_URL)
+  MD5SUM:=$(PKG_BRCMSMAC_FW_MD5SUM)
 endef
+$(eval $(call Download,brcmsmac))
 
-define KernelPackage/rtl8192cu
+define KernelPackage/brcmsmac
   $(call KernelPackage/mac80211/Default)
-  TITLE:=Realtek RTL8192CU/RTL8188CU support
-  DEPENDS+= +kmod-rtlwifi-usb +kmod-rtl8192c-common +rtl8192cu-firmware
-  FILES:= $(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtlwifi/rtl8192cu/rtl8192cu.ko
-  AUTOLOAD:=$(call AutoProbe,rtl8192cu)
+  TITLE:=Broadcom IEEE802.11n PCIe SoftMAC WLAN driver
+  URL:=https://wireless.wiki.kernel.org/en/users/drivers/brcm80211
+  DEPENDS+= +kmod-mac80211 +@DRIVER_11N_SUPPORT +!TARGET_brcm47xx:kmod-bcma +kmod-lib-cordic +kmod-lib-crc8 +kmod-brcmutil
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/brcm80211/brcmsmac/brcmsmac.ko
+  AUTOLOAD:=$(call AutoProbe,brcmsmac)
+  MENU:=1
 endef
 
-
-define KernelPackage/rtl8xxxu
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=alternative Realtek RTL8XXXU support
-  DEPENDS+= @USB_SUPPORT +kmod-usb-core +kmod-mac80211
-  FILES:= $(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu.ko
-  AUTOLOAD:=$(call AutoProbe,rtl8xxxu)
+define KernelPackage/brcmsmac/description
+ Kernel module for Broadcom IEEE802.11n PCIe Wireless cards
 endef
 
-define KernelPackage/rtl8xxxu/description
-  This is an alternative driver for various Realtek RTL8XXX
-  parts written to utilize the Linux mac80211 stack.
-  The driver is known to work with a number of RTL8723AU,
-  RL8188CU, RTL8188RU, RTL8191CU, and RTL8192CU devices
-
-  This driver is under development and has a limited feature
-  set. In particular it does not yet support 40MHz channels
-  and power management. However it should have a smaller
-  memory footprint than the vendor drivers and benetifs
-  from the in kernel mac80211 stack.
-
-  It can coexist with drivers from drivers/staging/rtl8723au,
-  drivers/staging/rtl8192u, and drivers/net/wireless/rtlwifi,
-  but you will need to control which module you wish to load.
-
-  RTL8XXXU_UNTESTED is enabled
-  This option enables detection of Realtek 8723/8188/8191/8192 WiFi
-  USB devices which have not been tested directly by the driver
-  author or reported to be working by third parties.
+define KernelPackage/brcmsmac/config
+  if PACKAGE_kmod-brcmsmac
 
-  Please report your results!
-endef
+	config BRCMSMAC_USE_FW_FROM_WL
+		bool "Use firmware extracted from broadcom proprietary driver"
+		default y
+		help
+		  Instead of using the official brcmsmac firmware a firmware
+		  version 666.2 extracted from the proprietary Broadcom driver
+		  is used. This is needed to get core rev 17 used in bcm4716
+		  to work.
 
+		  If unsure, say Y.
 
-define KernelPackage/wlcore
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=TI common driver part
-  DEPENDS+= @TARGET_omap||@TARGET_baltos +kmod-mac80211 +@DRIVER_11N_SUPPORT
-  FILES:= \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/ti/wlcore/wlcore.ko \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/ti/wlcore/wlcore_sdio.ko
-  AUTOLOAD:=$(call AutoProbe,wlcore wlcore_sdio)
+  endif
 endef
 
-define KernelPackage/wlcore/description
- This module contains some common parts needed by TI Wireless drivers.
-endef
 
-define KernelPackage/wl12xx
+define KernelPackage/brcmfmac
   $(call KernelPackage/mac80211/Default)
-  TITLE:=Driver for TI WL12xx
-  URL:=http://wireless.kernel.org/en/users/Drivers/wl12xx
-  DEPENDS+= +kmod-wlcore +wl12xx-firmware
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ti/wl12xx/wl12xx.ko
-  AUTOLOAD:=$(call AutoProbe,wl12xx)
+  TITLE:=Broadcom IEEE802.11n USB FullMAC WLAN driver
+  URL:=https://wireless.wiki.kernel.org/en/users/drivers/brcm80211
+  DEPENDS+= @USB_SUPPORT +kmod-cfg80211 +@DRIVER_11N_SUPPORT +kmod-brcmutil +BRCMFMAC_SDIO:kmod-mmc +BRCMFMAC_USB:kmod-usb-core
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/brcm80211/brcmfmac/brcmfmac.ko
+  AUTOLOAD:=$(call AutoProbe,brcmfmac)
 endef
 
-define KernelPackage/wl12xx/description
- Kernel modules for TI WL12xx
+define KernelPackage/brcmfmac/description
+ Kernel module for Broadcom IEEE802.11n USB Wireless cards
 endef
 
-define KernelPackage/wl18xx
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Driver for TI WL18xx
-  URL:=http://wireless.kernel.org/en/users/Drivers/wl18xx
-  DEPENDS+= +kmod-wlcore +wl18xx-firmware
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ti/wl18xx/wl18xx.ko
-  AUTOLOAD:=$(call AutoProbe,wl18xx)
-endef
+define KernelPackage/brcmfmac/config
+  if PACKAGE_kmod-brcmfmac
 
-define KernelPackage/wl18xx/description
- Kernel modules for TI WL18xx
-endef
+	config BRCMFMAC_SDIO
+		bool "Enable SDIO bus interface support"
+		default n
+		help
+		  Enable support for cards attached to an SDIO bus.
+		  Select this option only if you are sure that your
+		  board has a Broadcom wireless chip atacched to
+		  that bus.
 
+	config BRCMFMAC_USB
+		bool "Enable USB bus interface support"
+		depends on USB_SUPPORT
+		default y
+		help
+		  Supported USB connected chipsets:
+		  BCM43235, BCM43236, BCM43238 (all in revision 3 only)
+		  BCM43143, BCM43242, BCM43566, BCM43569
 
-ZD1211FW_NAME:=zd1211-firmware
-ZD1211FW_VERSION:=1.4
-define Download/zd1211rw
-  FILE:=$(ZD1211FW_NAME)-$(ZD1211FW_VERSION).tar.bz2
-  URL:=@SF/zd1211/
-  MD5SUM:=19f28781d76569af8551c9d11294c870
-endef
-$(eval $(call Download,zd1211rw))
+	config BRCMFMAC_PCIE
+		bool "Enable PCIE bus interface support"
+		depends on PCI_SUPPORT
+		default y
+		help
+		  Supported PCIe connected chipsets:
+		  BCM4354, BCM4356, BCM43567, BCM43570, BCM43602
 
-define KernelPackage/zd1211rw
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Zydas ZD1211 support
-  DEPENDS+= @USB_SUPPORT +kmod-usb-core +kmod-mac80211
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/zydas/zd1211rw/zd1211rw.ko
-  AUTOLOAD:=$(call AutoProbe,zd1211rw)
+  endif
 endef
 
-
-
 config_package=$(if $(CONFIG_PACKAGE_kmod-$(1)),m)
 
 config-y:= \
@@ -1442,21 +1555,6 @@ config-y:= \
 	MAC80211_RC_MINSTREL_HT \
 	MAC80211_RC_MINSTREL_VHT \
 	MAC80211_RC_DEFAULT_MINSTREL \
-	WLAN_VENDOR_ADMTEK \
-	WLAN_VENDOR_ATH \
-	WLAN_VENDOR_ATMEL \
-	WLAN_VENDOR_BROADCOM \
-	WLAN_VENDOR_CISCO \
-	WLAN_VENDOR_INTEL \
-	WLAN_VENDOR_INTERSIL \
-	WLAN_VENDOR_MARVELL \
-	WLAN_VENDOR_MEDIATEK \
-	WLAN_VENDOR_RALINK \
-	WLAN_VENDOR_REALTEK \
-	WLAN_VENDOR_RSI \
-	WLAN_VENDOR_ST \
-	WLAN_VENDOR_TI \
-	WLAN_VENDOR_ZYDAS \
 
 config-$(call config_package,cfg80211) += CFG80211
 
@@ -1473,20 +1571,8 @@ ifdef CONFIG_PACKAGE_MAC80211_DEBUGFS
 	ATH5K_DEBUG
 endif
 
-ifdef CONFIG_PACKAGE_MAC80211_TRACING
-  config-y += \
-	ATH10K_TRACING \
-	ATH6KL_TRACING \
-	ATH_TRACEPOINTS \
-	WIL6210_TRACING \
-	ATH5K_TRACER \
-	IWLWIFI_DEVICE_TRACING
-endif
-
 config-$(call config_package,lib80211) += LIB80211 LIB80211_CRYPT_WEP LIB80211_CRYPT_CCMP LIB80211_CRYPT_TKIP
 
-config-$(call config_package,airo) += AIRO
-
 config-$(call config_package,ath) += ATH_CARDS ATH_COMMON
 config-$(CONFIG_PACKAGE_ATH_DEBUG) += ATH_DEBUG ATH10K_DEBUG
 config-$(CONFIG_PACKAGE_ATH_DFS) += ATH9K_DFS_CERTIFIED ATH10K_DFS_CERTIFIED
@@ -1533,8 +1619,6 @@ config-$(CONFIG_BRCMFMAC_PCIE) += BRCMFMAC_PCIE
 config-$(CONFIG_PACKAGE_BRCM80211_DEBUG) += BRCMDBG
 
 config-$(call config_package,mac80211-hwsim) += MAC80211_HWSIM
-config-$(call config_package,mt7601u) += MT7601U
-config-y += WL_MEDIATEK
 
 config-$(call config_package,rt2x00-lib) += RT2X00 RT2X00_LIB
 config-$(call config_package,rt2x00-pci) += RT2X00_LIB_PCI
@@ -1556,34 +1640,31 @@ config-$(call config_package,rt2800-pci) += RT2800PCI
 config-y += RT2800PCI_RT33XX RT2800PCI_RT35XX RT2800PCI_RT53XX RT2800PCI_RT3290
 
 config-$(call config_package,rt2800-usb) += RT2800USB
-config-y += RT2800USB_RT33XX RT2800USB_RT35XX RT2800USB_RT3573 RT2800USB_RT53XX RT2800USB_RT55XX RT2800USB_UNKNOWN
+config-y += RT2800USB_RT33XX RT2800USB_RT35XX RT2800USB_RT3573 RT2800USB_RT53XX RT2800USB_RT55XX
 
 config-$(call config_package,iwl-legacy) += IWLEGACY
 config-$(call config_package,iwl3945) += IWL3945
 config-$(call config_package,iwl4965) += IWL4965
-config-$(call config_package,iwlwifi) += IWLWIFI IWLDVM IWLMVM
-config-$(CONFIG_PACKAGE_IWLWIFI_DEBUG)+= IWLWIFI_DEBUG
-config-$(CONFIG_PACKAGE_IWLWIFI_DEBUGFS)+= IWLWIFI_DEBUGFS
+config-$(call config_package,iwlagn) += IWLWIFI IWLDVM
 
-config-$(call config_package,libipw) += LIBIPW
-config-$(call config_package,ipw2100) += IPW2100
-config-$(call config_package,ipw2200) += IPW2200
+config-$(call config_package,net-libipw) += LIBIPW
+config-$(call config_package,net-ipw2100) += IPW2100
+config-$(call config_package,net-ipw2200) += IPW2200
 
 config-$(call config_package,p54-common) += P54_COMMON
 config-$(call config_package,p54-pci) += P54_PCI
 config-$(call config_package,p54-usb) += P54_USB
 config-$(call config_package,p54-spi) += P54_SPI
 
-config-$(call config_package,hermes) += HERMES
-config-$(call config_package,hermes-pci) += PCI_HERMES
-config-$(call config_package,hermes-plx) += PLX_HERMES
-config-$(call config_package,hermes-pcmcia) += PCMCIA_HERMES
+config-$(call config_package,net-hermes) += HERMES
+config-$(call config_package,net-hermes-pci) += PCI_HERMES
+config-$(call config_package,net-hermes-plx) += PLX_HERMES
+config-$(call config_package,net-hermes-pcmcia) += PCMCIA_HERMES
 config-y += HERMES_PRISM
 
 config-$(call config_package,adm8211) += ADM8211
 config-$(call config_package,libertas-sdio) += LIBERTAS LIBERTAS_SDIO
 config-$(call config_package,libertas-usb) += LIBERTAS LIBERTAS_USB
-config-$(call config_package,libertas-spi) += LIBERTAS LIBERTAS_SPI
 config-$(call config_package,mwl8k) += MWL8K
 config-$(call config_package,mwifiex-pcie) += MWIFIEX MWIFIEX_PCIE
 config-$(call config_package,rtl8180) += RTL8180
@@ -1604,15 +1685,12 @@ config-$(call config_package,rtl8192de) += RTL8192DE
 config-$(call config_package,rtl8192cu) += RTL8192CU
 config-$(CONFIG_PACKAGE_RTLWIFI_DEBUG) += RTLWIFI_DEBUG
 
-config-$(call config_package,rtl8xxxu) += RTL8XXXU
-config-y += RTL8XXXU_UNTESTED
-
 config-$(CONFIG_LEDS_TRIGGERS) += MAC80211_LEDS B43_LEDS B43LEGACY_LEDS
 
 MAKE_OPTS:= -C "$(PKG_BUILD_DIR)" \
 	CROSS_COMPILE="$(KERNEL_CROSS)" \
 	ARCH="$(LINUX_KARCH)" \
-	EXTRA_CFLAGS="-I$(PKG_BUILD_DIR)/include $(IREMAP_CFLAGS)" \
+	EXTRA_CFLAGS="-I$(PKG_BUILD_DIR)/include" \
 	KLIB_BUILD="$(LINUX_DIR)" \
 	MODPROBE=true \
 	KLIB=$(TARGET_MODULES_DIR) \
@@ -1634,48 +1712,49 @@ endef
 $(eval $(call shexport,mac80211_config))
 
 define Build/Prepare
-	rm -rf $(PKG_BUILD_DIR)
-	mkdir -p $(PKG_BUILD_DIR)
+	#rm -rf $(PKG_BUILD_DIR)
+	#mkdir -p $(PKG_BUILD_DIR)
 	$(PKG_UNPACK)
 	$(Build/Patch)
 	$(TAR) -C $(PKG_BUILD_DIR) -xzf $(DL_DIR)/$(IPW2100_NAME)-$(IPW2100_VERSION).tgz
 	$(TAR) -C $(PKG_BUILD_DIR) -xzf $(DL_DIR)/$(IPW2200_NAME)-$(IPW2200_VERSION).tgz
 	$(TAR) -C $(PKG_BUILD_DIR) -xjf $(DL_DIR)/$(ZD1211FW_NAME)-$(ZD1211FW_VERSION).tar.bz2
-	rm -rf \
-		$(PKG_BUILD_DIR)/include/linux/ssb \
-		$(PKG_BUILD_DIR)/include/linux/bcma \
-		$(PKG_BUILD_DIR)/include/net/bluetooth
+	$(TAR) -C $(PKG_BUILD_DIR) -xjf $(DL_DIR)/$(PKG_LINUX_FIRMWARE_SOURCE)
+	$(TAR) -C $(PKG_BUILD_DIR) -xjf $(DL_DIR)/$(PKG_ATH10K_LINUX_FIRMWARE_SOURCE)
+	#rm -rf \
+		#$(PKG_BUILD_DIR)/include/linux/ssb \
+		#$(PKG_BUILD_DIR)/include/linux/bcma \
+		#$(PKG_BUILD_DIR)/include/net/bluetooth
 
-	rm -f \
-		$(PKG_BUILD_DIR)/include/linux/cordic.h \
-		$(PKG_BUILD_DIR)/include/linux/crc8.h \
-		$(PKG_BUILD_DIR)/include/linux/eeprom_93cx6.h \
-		$(PKG_BUILD_DIR)/include/linux/wl12xx.h \
-		$(PKG_BUILD_DIR)/include/linux/spi/libertas_spi.h \
-		$(PKG_BUILD_DIR)/include/net/ieee80211.h \
-		$(PKG_BUILD_DIR)/backport-include/linux/bcm47xx_nvram.h
+	#rm -f \
+		#$(PKG_BUILD_DIR)/include/linux/cordic.h \
+		#$(PKG_BUILD_DIR)/include/linux/crc8.h \
+		#$(PKG_BUILD_DIR)/include/linux/eeprom_93cx6.h \
+		#$(PKG_BUILD_DIR)/include/linux/wl12xx.h \
+		#$(PKG_BUILD_DIR)/include/linux/spi/libertas_spi.h \
+		#$(PKG_BUILD_DIR)/include/net/ieee80211.h
 
-	echo 'compat-wireless-$(PKG_VERSION)-$(PKG_RELEASE)-$(REVISION)' > $(PKG_BUILD_DIR)/compat_version
-	$(CP) ./files/regdb.txt $(PKG_BUILD_DIR)/net/wireless/db.txt
+	#echo 'compat-wireless-$(PKG_VERSION)-$(PKG_RELEASE)-$(REVISION)' > $(PKG_BUILD_DIR)/compat_version
+	$(CP) ./files/regdb.txt $(LINUX_DIR)/net/wireless/db.txt
 endef
 
 ifneq ($(CONFIG_PACKAGE_kmod-cfg80211)$(CONFIG_PACKAGE_kmod-lib80211),)
  define Build/Compile/kmod
-	rm -rf $(PKG_BUILD_DIR)/modules
-	+$(MAKE) $(PKG_JOBS) $(MAKE_OPTS) modules
+	#rm -rf $(PKG_BUILD_DIR)/modules
+	#+$(MAKE) $(PKG_JOBS) $(MAKE_OPTS) modules
  endef
 endif
 
 define Build/Configure
-	cmp $(PKG_BUILD_DIR)/include/linux/ath9k_platform.h $(LINUX_DIR)/include/linux/ath9k_platform.h
-	cmp $(PKG_BUILD_DIR)/include/linux/ath5k_platform.h $(LINUX_DIR)/include/linux/ath5k_platform.h
-	cmp $(PKG_BUILD_DIR)/include/linux/rt2x00_platform.h $(LINUX_DIR)/include/linux/rt2x00_platform.h
+	#cmp $(PKG_BUILD_DIR)/include/linux/ath9k_platform.h $(LINUX_DIR)/include/linux/ath9k_platform.h
+	#cmp $(PKG_BUILD_DIR)/include/linux/ath5k_platform.h $(LINUX_DIR)/include/linux/ath5k_platform.h
+	#cmp $(PKG_BUILD_DIR)/include/linux/rt2x00_platform.h $(LINUX_DIR)/include/linux/rt2x00_platform.h
 endef
 
 define Build/Compile
-	$(SH_FUNC) var2file "$(call shvar,mac80211_config)" $(PKG_BUILD_DIR)/.config
-	$(MAKE) $(MAKE_OPTS) allnoconfig
-	$(call Build/Compile/kmod)
+	#$(SH_FUNC) var2file "$(call shvar,mac80211_config)" $(PKG_BUILD_DIR)/.config
+	#$(MAKE) $(MAKE_OPTS) allnoconfig
+	#$(call Build/Compile/kmod)
 endef
 
 define Build/InstallDev
@@ -1684,13 +1763,226 @@ define Build/InstallDev
 		$(1)/usr/include/mac80211-backport \
 		$(1)/usr/include/mac80211/ath \
 		$(1)/usr/include/net/mac80211
-	$(CP) $(PKG_BUILD_DIR)/net/mac80211/*.h $(PKG_BUILD_DIR)/include/* $(1)/usr/include/mac80211/
-	$(CP) $(PKG_BUILD_DIR)/backport-include/* $(1)/usr/include/mac80211-backport/
-	$(CP) $(PKG_BUILD_DIR)/net/mac80211/rate.h $(1)/usr/include/net/mac80211/
-	$(CP) $(PKG_BUILD_DIR)/drivers/net/wireless/ath/*.h $(1)/usr/include/mac80211/ath/
-	rm -f $(1)/usr/include/mac80211-backport/linux/module.h
+	$(CP) $(LINUX_DIR)/net/mac80211/*.h $(LINUX_DIR)/include/* $(1)/usr/include/mac80211/
+	#$(CP) $(PKG_BUILD_DIR)/backport-include/* $(1)/usr/include/mac80211-backport/
+	$(CP) $(LINUX_DIR)/net/mac80211/rate.h $(1)/usr/include/net/mac80211/
+	$(CP) $(LINUX_DIR)/drivers/net/wireless/ath/*.h $(1)/usr/include/mac80211/ath/
+	#rm -f $(1)/usr/include/mac80211-backport/linux/module.h
+endef
+
+define KernelPackage/libertas-usb/install
+	$(INSTALL_DIR) $(1)/lib/firmware/libertas
+	$(INSTALL_DATA) \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/libertas/usb8388_v9.bin \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/libertas/usb8682.bin \
+		$(1)/lib/firmware/libertas/
+endef
+
+define KernelPackage/libertas-sdio/install
+	$(INSTALL_DIR) $(1)/lib/firmware/libertas
+	$(INSTALL_DATA) \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/libertas/sd8385_helper.bin \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/libertas/sd8385.bin \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/libertas/sd8686_v9_helper.bin \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/libertas/sd8686_v9.bin \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/libertas/sd8688_helper.bin \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/libertas/sd8688.bin \
+		$(1)/lib/firmware/libertas
+endef
+
+define KernelPackage/cfg80211/install
+	$(INSTALL_DIR) $(1)/lib/wifi $(1)/lib/netifd/wireless
+	$(INSTALL_DATA) ./files/lib/wifi/mac80211.sh $(1)/lib/wifi
+	$(INSTALL_BIN) ./files/lib/netifd/wireless/mac80211.sh $(1)/lib/netifd/wireless
+endef
+
+define KernelPackage/p54-pci/install
+	$(INSTALL_DIR) $(1)/lib/firmware
+	$(INSTALL_DATA) $(DL_DIR)/$(P54PCIFW) $(1)/lib/firmware/isl3886pci
+endef
+
+define KernelPackage/p54-usb/install
+	$(INSTALL_DIR) $(1)/lib/firmware
+	$(INSTALL_DATA) $(DL_DIR)/$(P54USBFW) $(1)/lib/firmware/isl3887usb
+endef
+
+define KernelPackage/p54-spi/install
+	$(INSTALL_DIR) $(1)/lib/firmware
+	$(INSTALL_DATA) $(DL_DIR)/$(P54SPIFW) $(1)/lib/firmware/3826.arm
+endef
+
+define KernelPackage/rt61-pci/install
+	$(INSTALL_DIR) $(1)/lib/firmware
+	$(INSTALL_DATA) \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/rt2561.bin \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/rt2561s.bin \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/rt2661.bin \
+		$(1)/lib/firmware/
+endef
+
+define KernelPackage/rt73-usb/install
+	$(INSTALL_DIR) $(1)/lib/firmware
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/rt73.bin $(1)/lib/firmware/
+endef
+
+define KernelPackage/rt2800-pci/install
+	$(INSTALL_DIR) $(1)/lib/firmware
+	$(INSTALL_DATA) \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/rt2860.bin \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/rt3290.bin \
+		$(1)/lib/firmware
+endef
+
+define KernelPackage/rt2800-usb/install
+	$(INSTALL_DIR) $(1)/lib/firmware
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/rt2870.bin $(1)/lib/firmware/
+endef
+
+define KernelPackage/wl12xx/install
+	$(INSTALL_DIR) $(1)/lib/firmware/ti-connectivity
+	$(INSTALL_DATA) \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/ti-connectivity/wl127x-fw-5-mr.bin \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/ti-connectivity/wl127x-fw-5-plt.bin \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/ti-connectivity/wl127x-fw-5-sr.bin \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/ti-connectivity/wl1271-nvs.bin \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/ti-connectivity/wl128x-fw-5-mr.bin \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/ti-connectivity/wl128x-fw-5-plt.bin \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/ti-connectivity/wl128x-fw-5-sr.bin \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/ti-connectivity/wl128x-nvs.bin \
+		$(1)/lib/firmware/ti-connectivity
+endef
+
+define KernelPackage/wl18xx/install
+	$(INSTALL_DIR) $(1)/lib/firmware/ti-connectivity
+	$(INSTALL_DATA) \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/ti-connectivity/wl18xx-fw-3.bin \
+		$(1)/lib/firmware/ti-connectivity
+endef
+
+define KernelPackage/zd1211rw/install
+	$(INSTALL_DIR) $(1)/lib/firmware/zd1211
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(ZD1211FW_NAME)/zd1211* $(1)/lib/firmware/zd1211
+endef
+
+define KernelPackage/carl9170/install
+	$(INSTALL_DIR) $(1)/lib/firmware
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/carl9170-1.fw $(1)/lib/firmware
+endef
+
+define KernelPackage/ath9k-htc/install
+	$(INSTALL_DIR) $(1)/lib/firmware
+	$(INSTALL_DATA) \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/htc_9271.fw \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/htc_7010.fw \
+		$(1)/lib/firmware/
+endef
+
+define KernelPackage/ath10k/install
+	$(INSTALL_DIR) $(1)/lib/firmware/ath10k/QCA988X/hw2.0
+	$(INSTALL_DATA) \
+		$(PKG_BUILD_DIR)/$(PKG_ATH10K_LINUX_FIRMWARE_SUBDIR)/ath10k/QCA988X/hw2.0/board.bin \
+		$(1)/lib/firmware/ath10k/QCA988X/hw2.0/
+ifeq ($(CONFIG_ATH10K_STA_FW),y)
+	$(INSTALL_DATA) \
+		$(PKG_BUILD_DIR)/$(PKG_ATH10K_LINUX_FIRMWARE_SUBDIR)/main/firmware-2.bin_999.999.0.636 \
+		$(1)/lib/firmware/ath10k/QCA988X/hw2.0/firmware-2.bin
+else ifeq ($(CONFIG_ATH10K_API2_FW),y)
+	$(INSTALL_DATA) \
+		$(PKG_BUILD_DIR)/$(PKG_ATH10K_LINUX_FIRMWARE_SUBDIR)/10.1/firmware-2.bin_10.1.467.2-1 \
+		$(1)/lib/firmware/ath10k/QCA988X/hw2.0/firmware-2.bin
+else
+	$(INSTALL_DATA) \
+		$(PKG_BUILD_DIR)/$(PKG_ATH10K_LINUX_FIRMWARE_SUBDIR)/10.2.4/firmware-4.bin_10.2.4.45 \
+		$(1)/lib/firmware/ath10k/QCA988X/hw2.0/firmware-4.bin
+endif
+endef
+
+define KernelPackage/mwl8k/install
+	$(INSTALL_DIR) $(1)/lib/firmware/mwl8k
+	$(INSTALL_DATA) \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/mwl8k/fmimage_8366_ap-3.fw \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/mwl8k/fmimage_8366.fw \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/mwl8k/helper_8366.fw \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/mwl8k/fmimage_8687.fw \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/mwl8k/helper_8687.fw \
+		$(1)/lib/firmware/mwl8k/
+endef
+
+define KernelPackage/mwifiex-pcie/install
+	$(INSTALL_DIR) $(1)/lib/firmware/mrvl
+	$(INSTALL_DATA) \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/mrvl/pcie8897_uapsta.bin \
+		$(1)/lib/firmware/mrvl/
+endef
+
+define KernelPackage/net-ipw2100/install
+	$(INSTALL_DIR) $(1)/lib/firmware
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/ipw2100-$(IPW2100_VERSION)*.fw $(1)/lib/firmware
+endef
+
+define KernelPackage/net-ipw2200/install
+	$(INSTALL_DIR) $(1)/lib/firmware
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(IPW2200_NAME)-$(IPW2200_VERSION)/ipw2200*.fw $(1)/lib/firmware
+endef
+
+define KernelPackage/iwlagn/install
+	$(INSTALL_DIR) $(1)/lib/firmware
+ifneq ($(CONFIG_IWL5000_FW),)
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-5000-5.ucode $(1)/lib/firmware
+endif
+ifneq ($(CONFIG_IWL5150_FW),)
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-5150-2.ucode $(1)/lib/firmware
+endif
+ifneq ($(CONFIG_IWL1000_FW),)
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-1000-5.ucode $(1)/lib/firmware
+endif
+ifneq ($(CONFIG_IWL6000_FW),)
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-6000-4.ucode $(1)/lib/firmware
+endif
+ifneq ($(CONFIG_IWL6050_FW),)
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-6050-5.ucode $(1)/lib/firmware
+endif
+ifneq ($(CONFIG_IWL6005_FW),)
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-6000g2a-6.ucode $(1)/lib/firmware
+endif
+ifneq ($(CONFIG_IWL6030_FW),)
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-6000g2b-6.ucode $(1)/lib/firmware
+endif
+ifneq ($(CONFIG_IWL7260_FW),)
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-7260-9.ucode $(1)/lib/firmware
+endif
+ifneq ($(CONFIG_IWL7265_FW),)
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-7265-9.ucode $(1)/lib/firmware
+endif
+ifneq ($(CONFIG_IWL100_FW),)
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-100-5.ucode $(1)/lib/firmware
+endif
+ifneq ($(CONFIG_IWL2000_FW),)
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-2000-6.ucode $(1)/lib/firmware
+endif
+ifneq ($(CONFIG_IWL2030_FW),)
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-2030-6.ucode $(1)/lib/firmware
+endif
+ifneq ($(CONFIG_IWL105_FW),)
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-105-6.ucode $(1)/lib/firmware
+endif
+ifneq ($(CONFIG_IWL135_FW),)
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-135-6.ucode $(1)/lib/firmware
+endif
+ifneq ($(CONFIG_IWL3160_FW),)
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-3160-9.ucode $(1)/lib/firmware
+endif
+endef
+
+define KernelPackage/iwl3945/install
+	$(INSTALL_DIR) $(1)/lib/firmware
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-3945-2.ucode $(1)/lib/firmware
 endef
 
+define KernelPackage/iwl4965/install
+	$(INSTALL_DIR) $(1)/lib/firmware
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-4965-2.ucode $(1)/lib/firmware
+endef
 
 define KernelPackage/b43/install
 	rm -rf $(1)/lib/firmware/
@@ -1714,71 +2006,51 @@ ifneq ($(CONFIG_B43_FW_SQUASH),)
 endif
 endef
 
+define KernelPackage/b43legacy/install
+	$(INSTALL_DIR) $(1)/lib/firmware/
+	b43-fwcutter --unsupported -w $(1)/lib/firmware/ $(DL_DIR)/$(PKG_B43_FWV3_SOURCE)
+ifneq ($(CONFIG_B43LEGACY_FW_SQUASH),)
+	b43-fwsquash.py "G" "$(CONFIG_B43LEGACY_FW_SQUASH_COREREVS)" "$(1)/lib/firmware/b43legacy"
+endif
+endef
+
 define KernelPackage/brcmsmac/install
 	$(INSTALL_DIR) $(1)/lib/firmware/brcm
 ifeq ($(CONFIG_BRCMSMAC_USE_FW_FROM_WL),y)
 	tar xjf "$(DL_DIR)/$(PKG_BRCMSMAC_FW_SOURCE)" -C "$(PKG_BUILD_DIR)"
 	b43-fwcutter --brcmsmac -w $(1)/lib/firmware/ $(PKG_BUILD_DIR)/$(PKG_BRCMSMAC_FW_OBJECT)
+else
+	$(INSTALL_DATA) \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/brcm/bcm43xx-0.fw \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/brcm/bcm43xx_hdr-0.fw \
+		$(1)/lib/firmware/brcm/
 endif
 endef
 
-define KernelPackage/cfg80211/install
-	$(INSTALL_DIR) $(1)/lib/wifi $(1)/lib/netifd/wireless
-	$(INSTALL_DATA) ./files/lib/wifi/mac80211.sh $(1)/lib/wifi
-	$(INSTALL_BIN) ./files/lib/netifd/wireless/mac80211.sh $(1)/lib/netifd/wireless
-endef
-
-define KernelPackage/ipw2100/install
-	$(INSTALL_DIR) $(1)/lib/firmware
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/ipw2100-$(IPW2100_VERSION)*.fw $(1)/lib/firmware
-endef
-
-define KernelPackage/ipw2200/install
-	$(INSTALL_DIR) $(1)/lib/firmware
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(IPW2200_NAME)-$(IPW2200_VERSION)/ipw2200*.fw $(1)/lib/firmware
-endef
-
-define KernelPackage/zd1211rw/install
-	$(INSTALL_DIR) $(1)/lib/firmware/zd1211
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(ZD1211FW_NAME)/zd1211* $(1)/lib/firmware/zd1211
+define KernelPackage/brcmfmac/install
+	$(INSTALL_DIR) $(1)/lib/firmware/brcm
+ifneq ($(CONFIG_BRCMFMAC_USB),)
+	$(INSTALL_DATA) \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/brcm/brcmfmac43236b.bin \
+		$(1)/lib/firmware/brcm/
+	$(INSTALL_DATA) \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/brcm/brcmfmac43143.bin \
+		$(1)/lib/firmware/brcm/
+endif
+ifneq ($(CONFIG_BRCMFMAC_PCIE),)
+	$(INSTALL_DATA) \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/brcm/brcmfmac43602-pcie.ap.bin \
+		$(1)/lib/firmware/brcm/brcmfmac43602-pcie.bin
+endif
 endef
 
-
 $(eval $(call KernelPackage,adm8211))
-$(eval $(call KernelPackage,airo))
-$(eval $(call KernelPackage,ath))
-$(eval $(call KernelPackage,ath10k))
 $(eval $(call KernelPackage,ath5k))
-$(eval $(call KernelPackage,ath9k))
-$(eval $(call KernelPackage,ath9k-common))
-$(eval $(call KernelPackage,ath9k-htc))
-$(eval $(call KernelPackage,b43))
-$(eval $(call KernelPackage,b43legacy))
-$(eval $(call KernelPackage,brcmsmac))
-$(eval $(call KernelPackage,brcmfmac))
-$(eval $(call KernelPackage,brcmutil))
-$(eval $(call KernelPackage,carl9170))
-$(eval $(call KernelPackage,cfg80211))
-$(eval $(call KernelPackage,hermes))
-$(eval $(call KernelPackage,hermes-pci))
-$(eval $(call KernelPackage,hermes-plx))
-$(eval $(call KernelPackage,hermes-pcmcia))
-$(eval $(call KernelPackage,iwlwifi))
-$(eval $(call KernelPackage,iwl-legacy))
-$(eval $(call KernelPackage,iwl4965))
-$(eval $(call KernelPackage,iwl3945))
 $(eval $(call KernelPackage,lib80211))
 $(eval $(call KernelPackage,libertas-usb))
 $(eval $(call KernelPackage,libertas-sdio))
-$(eval $(call KernelPackage,libertas-spi))
-$(eval $(call KernelPackage,libipw))
-$(eval $(call KernelPackage,ipw2100))
-$(eval $(call KernelPackage,ipw2200))
+$(eval $(call KernelPackage,cfg80211))
 $(eval $(call KernelPackage,mac80211))
-$(eval $(call KernelPackage,mac80211-hwsim))
-$(eval $(call KernelPackage,mt7601u))
-$(eval $(call KernelPackage,mwl8k))
-$(eval $(call KernelPackage,mwifiex-pcie))
 $(eval $(call KernelPackage,p54-common))
 $(eval $(call KernelPackage,p54-pci))
 $(eval $(call KernelPackage,p54-usb))
@@ -1791,12 +2063,12 @@ $(eval $(call KernelPackage,rt2800-lib))
 $(eval $(call KernelPackage,rt2400-pci))
 $(eval $(call KernelPackage,rt2500-pci))
 $(eval $(call KernelPackage,rt2500-usb))
+$(eval $(call KernelPackage,rt61-pci))
+$(eval $(call KernelPackage,rt73-usb))
 $(eval $(call KernelPackage,rt2800-mmio))
 $(eval $(call KernelPackage,rt2800-soc))
 $(eval $(call KernelPackage,rt2800-pci))
 $(eval $(call KernelPackage,rt2800-usb))
-$(eval $(call KernelPackage,rt61-pci))
-$(eval $(call KernelPackage,rt73-usb))
 $(eval $(call KernelPackage,rtl8180))
 $(eval $(call KernelPackage,rtl8187))
 $(eval $(call KernelPackage,rtlwifi))
@@ -1807,8 +2079,32 @@ $(eval $(call KernelPackage,rtl8192ce))
 $(eval $(call KernelPackage,rtl8192se))
 $(eval $(call KernelPackage,rtl8192de))
 $(eval $(call KernelPackage,rtl8192cu))
-$(eval $(call KernelPackage,rtl8xxxu))
+$(eval $(call KernelPackage,zd1211rw))
+$(eval $(call KernelPackage,mac80211-hwsim))
+$(eval $(call KernelPackage,ath9k-common))
+$(eval $(call KernelPackage,ath9k))
+$(eval $(call KernelPackage,ath9k-htc))
+$(eval $(call KernelPackage,ath10k))
+$(eval $(call KernelPackage,ath))
+$(eval $(call KernelPackage,carl9170))
+$(eval $(call KernelPackage,b43))
+$(eval $(call KernelPackage,b43legacy))
+$(eval $(call KernelPackage,brcmutil))
+$(eval $(call KernelPackage,brcmsmac))
+$(eval $(call KernelPackage,brcmfmac))
+$(eval $(call KernelPackage,net-libipw))
+$(eval $(call KernelPackage,net-ipw2100))
+$(eval $(call KernelPackage,net-ipw2200))
+$(eval $(call KernelPackage,iwlagn))
+$(eval $(call KernelPackage,iwl-legacy))
+$(eval $(call KernelPackage,iwl4965))
+$(eval $(call KernelPackage,iwl3945))
+$(eval $(call KernelPackage,mwl8k))
+$(eval $(call KernelPackage,mwifiex-pcie))
+$(eval $(call KernelPackage,net-hermes))
+$(eval $(call KernelPackage,net-hermes-pci))
+$(eval $(call KernelPackage,net-hermes-plx))
+$(eval $(call KernelPackage,net-hermes-pcmcia))
 $(eval $(call KernelPackage,wlcore))
 $(eval $(call KernelPackage,wl12xx))
 $(eval $(call KernelPackage,wl18xx))
-$(eval $(call KernelPackage,zd1211rw))
diff --git a/package/kernel/mac80211/files/lib/wifi/mac80211.sh b/package/kernel/mac80211/files/lib/wifi/mac80211.sh
index 06f3b8b..c50e950 100644
--- a/package/kernel/mac80211/files/lib/wifi/mac80211.sh
+++ b/package/kernel/mac80211/files/lib/wifi/mac80211.sh
@@ -60,6 +60,7 @@ check_mac80211_device() {
 
 detect_mac80211() {
 	devidx=0
+	local mac_addr = $(onrisctool -s | grep MAC3 | cut -d " " -f 2 | sed 's/..\B/&:/g')
 	config_load wireless
 	while :; do
 		config_get type "radio$devidx" type
@@ -105,8 +106,8 @@ detect_mac80211() {
 				platform*/pci*) path="${path##platform/}";;
 			esac
 			dev_id="	option path	'$path'"
-		else
-			dev_id="	option macaddr	$(cat /sys/class/ieee80211/${dev}/macaddress)"
+		#else
+			#dev_id="	option macaddr	$(cat /sys/class/ieee80211/${dev}/macaddress)"
 		fi
 
 		cat <<EOF
@@ -121,6 +122,7 @@ $ht_capab
 
 config wifi-iface
 	option device   radio$devidx
+	option macaddr  '$mac_addr'
 	option network  lan
 	option mode     ap
 	option ssid     OpenWrt
diff --git a/package/kernel/mac80211/patches/000-fix_kconfig.patch b/package/kernel/mac80211/patches/000-fix_kconfig.patch
deleted file mode 100644
index 3987aae..0000000
--- a/package/kernel/mac80211/patches/000-fix_kconfig.patch
+++ /dev/null
@@ -1,14 +0,0 @@
---- a/kconf/Makefile
-+++ b/kconf/Makefile
-@@ -1,9 +1,9 @@
--CFLAGS=-Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer
-+CFLAGS=-Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer -DKBUILD_NO_NLS
- 
- LXDIALOG := lxdialog/checklist.o lxdialog/inputbox.o lxdialog/menubox.o lxdialog/textbox.o lxdialog/util.o lxdialog/yesno.o
- 
- conf: conf.o zconf.tab.o
--mconf_CFLAGS := $(shell ./lxdialog/check-lxdialog.sh -ccflags) -DLOCALE
-+mconf_CFLAGS := $(shell ./lxdialog/check-lxdialog.sh -ccflags)
- mconf_LDFLAGS := $(shell ./lxdialog/check-lxdialog.sh -ldflags $(CC))
- mconf: CFLAGS += $(mconf_CFLAGS)
- 
diff --git a/package/kernel/mac80211/patches/001-fix_build.patch b/package/kernel/mac80211/patches/001-fix_build.patch
deleted file mode 100644
index 402649d..0000000
--- a/package/kernel/mac80211/patches/001-fix_build.patch
+++ /dev/null
@@ -1,167 +0,0 @@
---- a/Makefile
-+++ b/Makefile
-@@ -5,7 +5,7 @@
- ifeq ($(KERNELRELEASE),)
- 
- MAKEFLAGS += --no-print-directory
--SHELL := /bin/bash
-+SHELL := /usr/bin/env bash
- BACKPORT_DIR := $(shell pwd)
- 
- KMODDIR ?= updates
-@@ -19,6 +19,7 @@ KLIB_BUILD ?= $(KLIB)/build/
- KERNEL_CONFIG := $(KLIB_BUILD)/.config
- KERNEL_MAKEFILE := $(KLIB_BUILD)/Makefile
- CONFIG_MD5 := $(shell md5sum $(KERNEL_CONFIG) 2>/dev/null | sed 's/\s.*//')
-+STAMP_KERNEL_CONFIG := .kernel_config_md5_$(CONFIG_MD5)
- 
- export KLIB KLIB_BUILD BACKPORT_DIR KMODDIR KMODPATH_ARG
- 
-@@ -36,7 +37,8 @@ mrproper:
- 	@rm -f .kernel_config_md5 Kconfig.versions Kconfig.kernel
- 	@rm -f backport-include/backport/autoconf.h
- 
--.DEFAULT:
-+.SILENT: $(STAMP_KERNEL_CONFIG)
-+$(STAMP_KERNEL_CONFIG):
- 	@set -e ; test -f .local-symbols || (						\
- 	echo "/--------------"								;\
- 	echo "| You shouldn't run make in the backports tree, but only in"		;\
-@@ -60,57 +62,61 @@ mrproper:
- 	echo "| (that isn't currently running.)"					;\
- 	echo "\\--"									;\
- 	false)
--	@set -e ; if [ "$$(cat .kernel_config_md5 2>/dev/null)" != "$(CONFIG_MD5)" ]	;\
--	then 										\
--		echo -n "Generating local configuration database from kernel ..."	;\
--		grep -v -f .local-symbols $(KERNEL_CONFIG) | grep = | (			\
--			while read l ; do						\
--				if [ "$${l:0:7}" != "CONFIG_" ] ; then			\
--					continue					;\
--				fi							;\
--				l=$${l:7}						;\
--				n=$${l%%=*}						;\
--				v=$${l#*=}						;\
--				if [ "$$v" = "m" ] ; then				\
--					echo config $$n					;\
--					echo '    tristate' 				;\
--				elif [ "$$v" = "y" ] ; then				\
--					echo config $$n					;\
--					echo '    bool'					;\
--				else							\
--					continue					;\
--				fi							;\
--				echo "    default $$v"					;\
--				echo ""							;\
--			done								\
--		) > Kconfig.kernel							;\
--		kver=$$($(MAKE) --no-print-directory -C $(KLIB_BUILD) kernelversion |	\
--			sed 's/^\(\([3-4]\|2\.6\)\.[0-9]\+\).*/\1/;t;d')		;\
--		test "$$kver" != "" || echo "Kernel version parse failed!"		;\
--		test "$$kver" != ""							;\
--		kvers="$$(seq 14 39 | sed 's/^/2.6./')"					;\
--		kvers="$$kvers $$(seq 0 19 | sed 's/^/3./')"				;\
--		kvers="$$kvers $$(seq 0 99 | sed 's/^/4./')"				;\
--		print=0									;\
--		for v in $$kvers ; do							\
--			if [ "$$print" = "1" ] ; then					\
--				echo config KERNEL_$$(echo $$v | tr . _)	;\
--				echo "    def_bool y"					;\
--			fi								;\
--			if [ "$$v" = "$$kver" ] ; then print=1 ; fi			;\
--		done > Kconfig.versions							;\
--		# RHEL as well, sadly we need to grep for it				;\
--		RHEL_MAJOR=$$(grep '^RHEL_MAJOR' $(KERNEL_MAKEFILE) | 			\
--					sed 's/.*=\s*\([0-9]*\)/\1/;t;d')		;\
--		RHEL_MINOR=$$(grep '^RHEL_MINOR' $(KERNEL_MAKEFILE) | 			\
--					sed 's/.*=\s*\([0-9]*\)/\1/;t;d')		;\
--		for v in $$(seq 0 $$RHEL_MINOR) ; do 					\
--			echo config BACKPORT_RHEL_KERNEL_$${RHEL_MAJOR}_$$v		;\
--			echo "    def_bool y"						;\
--		done >> Kconfig.versions						;\
--		echo " done."								;\
--	fi										;\
--	echo "$(CONFIG_MD5)" > .kernel_config_md5
-+	@rm -f .kernel_config_md5_*
-+	@touch $@
-+
-+Kconfig.kernel: $(STAMP_KERNEL_CONFIG) .local-symbols
-+	@printf "Generating local configuration database from kernel ..."
-+	@grep -v -f .local-symbols $(KERNEL_CONFIG) | grep = | (			\
-+		while read l ; do						\
-+			if [ "$${l:0:7}" != "CONFIG_" ] ; then			\
-+				continue					;\
-+			fi							;\
-+			l=$${l:7}						;\
-+			n=$${l%%=*}						;\
-+			v=$${l#*=}						;\
-+			if [ "$$v" = "m" ] ; then				\
-+				echo config $$n					;\
-+				echo '    tristate' 				;\
-+			elif [ "$$v" = "y" ] ; then				\
-+				echo config $$n					;\
-+				echo '    bool'					;\
-+			else							\
-+				continue					;\
-+			fi							;\
-+			echo "    default $$v"					;\
-+			echo ""							;\
-+		done								\
-+	) > $@
-+	@echo " done."
-+
-+Kconfig.versions: Kconfig.kernel
-+	@kver=$$($(MAKE) --no-print-directory -C $(KLIB_BUILD) kernelversion |	\
-+		sed 's/^\(\([3-4]\|2\.6\)\.[0-9]\+\).*/\1/;t;d')		;\
-+	test "$$kver" != "" || echo "Kernel version parse failed!"		;\
-+	test "$$kver" != ""							;\
-+	kvers="$$(seq 14 39 | sed 's/^/2.6./')"					;\
-+	kvers="$$kvers $$(seq 0 19 | sed 's/^/3./')"				;\
-+	kvers="$$kvers $$(seq 0 99 | sed 's/^/4./')"				;\
-+	print=0									;\
-+	for v in $$kvers ; do							\
-+		if [ "$$print" = "1" ] ; then					\
-+			echo config KERNEL_$$(echo $$v | tr . _)	;\
-+			echo "    def_bool y"					;\
-+		fi								;\
-+		if [ "$$v" = "$$kver" ] ; then print=1 ; fi			;\
-+	done > $@
-+	@RHEL_MAJOR=$$(grep '^RHEL_MAJOR' $(KERNEL_MAKEFILE) | 			\
-+				sed 's/.*=\s*\([0-9]*\)/\1/;t;d')		;\
-+	RHEL_MINOR=$$(grep '^RHEL_MINOR' $(KERNEL_MAKEFILE) | 			\
-+				sed 's/.*=\s*\([0-9]*\)/\1/;t;d')		;\
-+	for v in $$(seq 0 $$RHEL_MINOR) ; do 					\
-+		echo config BACKPORT_RHEL_KERNEL_$${RHEL_MAJOR}_$$v		;\
-+		echo "    def_bool y"						;\
-+	done >> $@
-+
-+.DEFAULT:
-+	@$(MAKE) Kconfig.versions
- 	@$(MAKE) -f Makefile.real "$@"
- 
- .PHONY: defconfig-help
---- a/Makefile.real
-+++ b/Makefile.real
-@@ -59,7 +59,7 @@ defconfig-%::
- 
- backport-include/backport/autoconf.h: .config Kconfig.versions Kconfig.kernel
- 	@$(MAKE) oldconfig
--	@echo -n "Building backport-include/backport/autoconf.h ..."
-+	@printf "Building backport-include/backport/autoconf.h ..."
- 	@grep -f .local-symbols .config | (				\
- 		echo "#ifndef COMPAT_AUTOCONF_INCLUDED"			;\
- 		echo "#define COMPAT_AUTOCONF_INCLUDED"			;\
-@@ -80,7 +80,12 @@ backport-include/backport/autoconf.h: .c
- 			esac						;\
- 		done							;\
- 		echo "#endif /* COMPAT_AUTOCONF_INCLUDED */"		;\
--	) > backport-include/backport/autoconf.h
-+	) > $@.new
-+	@if cmp -s $@ $@.new; then \
-+		rm -f $@.new; \
-+	else \
-+		mv $@.new $@; \
-+	fi
- 	@echo " done."
- 
- .PHONY: modules
diff --git a/package/kernel/mac80211/patches/002-change_allconfig.patch b/package/kernel/mac80211/patches/002-change_allconfig.patch
deleted file mode 100644
index bd5bebf..0000000
--- a/package/kernel/mac80211/patches/002-change_allconfig.patch
+++ /dev/null
@@ -1,64 +0,0 @@
---- a/kconf/conf.c
-+++ b/kconf/conf.c
-@@ -593,40 +593,12 @@ int main(int ac, char **av)
- 	case oldconfig:
- 	case listnewconfig:
- 	case olddefconfig:
--		conf_read(NULL);
--		break;
- 	case allnoconfig:
- 	case allyesconfig:
- 	case allmodconfig:
- 	case alldefconfig:
- 	case randconfig:
--		name = getenv("KCONFIG_ALLCONFIG");
--		if (!name)
--			break;
--		if ((strcmp(name, "") != 0) && (strcmp(name, "1") != 0)) {
--			if (conf_read_simple(name, S_DEF_USER)) {
--				fprintf(stderr,
--					_("*** Can't read seed configuration \"%s\"!\n"),
--					name);
--				exit(1);
--			}
--			break;
--		}
--		switch (input_mode) {
--		case allnoconfig:	name = "allno.config"; break;
--		case allyesconfig:	name = "allyes.config"; break;
--		case allmodconfig:	name = "allmod.config"; break;
--		case alldefconfig:	name = "alldef.config"; break;
--		case randconfig:	name = "allrandom.config"; break;
--		default: break;
--		}
--		if (conf_read_simple(name, S_DEF_USER) &&
--		    conf_read_simple("all.config", S_DEF_USER)) {
--			fprintf(stderr,
--				_("*** KCONFIG_ALLCONFIG set, but no \"%s\" or \"all.config\" file found\n"),
--				name);
--			exit(1);
--		}
-+		conf_read(NULL);
- 		break;
- 	default:
- 		break;
---- a/kconf/confdata.c
-+++ b/kconf/confdata.c
-@@ -1169,6 +1169,8 @@ bool conf_set_all_new_symbols(enum conf_
- 	}
- 	bool has_changed = false;
- 
-+	sym_clear_all_valid();
-+
- 	for_all_symbols(i, sym) {
- 		if (sym_has_value(sym) || (sym->flags & SYMBOL_VALID))
- 			continue;
-@@ -1212,8 +1214,6 @@ bool conf_set_all_new_symbols(enum conf_
- 
- 	}
- 
--	sym_clear_all_valid();
--
- 	/*
- 	 * We have different type of choice blocks.
- 	 * If curr.tri equals to mod then we can select several
diff --git a/package/kernel/mac80211/patches/003-remove_bogus_modparams.patch b/package/kernel/mac80211/patches/003-remove_bogus_modparams.patch
deleted file mode 100644
index 8fa465a..0000000
--- a/package/kernel/mac80211/patches/003-remove_bogus_modparams.patch
+++ /dev/null
@@ -1,34 +0,0 @@
---- a/compat/main.c
-+++ b/compat/main.c
-@@ -20,31 +20,6 @@ MODULE_LICENSE("GPL");
- #error "You need a CPTCFG_VERSION"
- #endif
- 
--static char *backported_kernel_name = CPTCFG_KERNEL_NAME;
--
--module_param(backported_kernel_name, charp, 0400);
--MODULE_PARM_DESC(backported_kernel_name,
--		 "The kernel tree name that was used for this backport (" CPTCFG_KERNEL_NAME ")");
--
--#ifdef BACKPORTS_GIT_TRACKED
--static char *backports_tracker_id = BACKPORTS_GIT_TRACKED;
--module_param(backports_tracker_id, charp, 0400);
--MODULE_PARM_DESC(backports_tracker_id,
--		 "The version of the tree containing this backport (" BACKPORTS_GIT_TRACKED ")");
--#else
--static char *backported_kernel_version = CPTCFG_KERNEL_VERSION;
--static char *backports_version = CPTCFG_VERSION;
--
--module_param(backported_kernel_version, charp, 0400);
--MODULE_PARM_DESC(backported_kernel_version,
--		 "The kernel version that was used for this backport (" CPTCFG_KERNEL_VERSION ")");
--
--module_param(backports_version, charp, 0400);
--MODULE_PARM_DESC(backports_version,
--		 "The git version of the backports tree used to generate this backport (" CPTCFG_VERSION ")");
--
--#endif
--
- void backport_dependency_symbol(void)
- {
- }
diff --git a/package/kernel/mac80211/patches/004-header-backport-GENL_UNS_ADMIN_PERM.patch b/package/kernel/mac80211/patches/004-header-backport-GENL_UNS_ADMIN_PERM.patch
deleted file mode 100644
index 38d655f..0000000
--- a/package/kernel/mac80211/patches/004-header-backport-GENL_UNS_ADMIN_PERM.patch
+++ /dev/null
@@ -1,21 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sat, 14 May 2016 16:39:35 +0200
-Subject: [PATCH] header: backport GENL_UNS_ADMIN_PERM
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- create mode 100644 backport-include/uapi/linux/genetlink.h
-
---- /dev/null
-+++ b/backport-include/uapi/linux/genetlink.h
-@@ -0,0 +1,10 @@
-+#ifndef __COMPAT_UAPI_LINUX_GENETLINK_H
-+#define __COMPAT_UAPI_LINUX_GENETLINK_H
-+
-+#include_next <uapi/linux/genetlink.h>
-+
-+#ifndef GENL_UNS_ADMIN_PERM
-+#define GENL_UNS_ADMIN_PERM GENL_ADMIN_PERM
-+#endif
-+
-+#endif
diff --git a/package/kernel/mac80211/patches/005-header-backport-nla_put_u64_64bit-and-nla_put_64bit.patch b/package/kernel/mac80211/patches/005-header-backport-nla_put_u64_64bit-and-nla_put_64bit.patch
deleted file mode 100644
index e20d87a..0000000
--- a/package/kernel/mac80211/patches/005-header-backport-nla_put_u64_64bit-and-nla_put_64bit.patch
+++ /dev/null
@@ -1,158 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sat, 14 May 2016 16:40:16 +0200
-Subject: [PATCH] header: backport nla_put_u64_64bit and nla_put_64bit
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/backport-include/net/netlink.h
-+++ b/backport-include/net/netlink.h
-@@ -189,4 +189,148 @@ static inline __le64 nla_get_le64(const
- }
- #endif /* < 4.4 */
- 
-+
-+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0)
-+
-+/**
-+ * nla_need_padding_for_64bit - test 64-bit alignment of the next attribute
-+ * @skb: socket buffer the message is stored in
-+ *
-+ * Return true if padding is needed to align the next attribute (nla_data()) to
-+ * a 64-bit aligned area.
-+ */
-+static inline bool nla_need_padding_for_64bit(struct sk_buff *skb)
-+{
-+#ifndef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS
-+	/* The nlattr header is 4 bytes in size, that's why we test
-+	 * if the skb->data _is_ aligned.  A NOP attribute, plus
-+	 * nlattr header for next attribute, will make nla_data()
-+	 * 8-byte aligned.
-+	 */
-+	if (IS_ALIGNED((unsigned long)skb_tail_pointer(skb), 8))
-+		return true;
-+#endif
-+	return false;
-+}
-+
-+/**
-+ * nla_align_64bit - 64-bit align the nla_data() of next attribute
-+ * @skb: socket buffer the message is stored in
-+ * @padattr: attribute type for the padding
-+ *
-+ * Conditionally emit a padding netlink attribute in order to make
-+ * the next attribute we emit have a 64-bit aligned nla_data() area.
-+ * This will only be done in architectures which do not have
-+ * CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS defined.
-+ *
-+ * Returns zero on success or a negative error code.
-+ */
-+static inline int nla_align_64bit(struct sk_buff *skb, int padattr)
-+{
-+	if (nla_need_padding_for_64bit(skb) &&
-+	    !nla_reserve(skb, padattr, 0))
-+		return -EMSGSIZE;
-+
-+	return 0;
-+}
-+
-+/**
-+ * __nla_reserve_64bit - reserve room for attribute on the skb and align it
-+ * @skb: socket buffer to reserve room on
-+ * @attrtype: attribute type
-+ * @attrlen: length of attribute payload
-+ * @padattr: attribute type for the padding
-+ *
-+ * Adds a netlink attribute header to a socket buffer and reserves
-+ * room for the payload but does not copy it. It also ensure that this
-+ * attribute will have a 64-bit aligned nla_data() area.
-+ *
-+ * The caller is responsible to ensure that the skb provides enough
-+ * tailroom for the attribute header and payload.
-+ */
-+static inline struct nlattr *__nla_reserve_64bit(struct sk_buff *skb, int attrtype,
-+						 int attrlen, int padattr)
-+{
-+	if (nla_need_padding_for_64bit(skb))
-+		nla_align_64bit(skb, padattr);
-+
-+	return __nla_reserve(skb, attrtype, attrlen);
-+}
-+
-+/**
-+ * __nla_put_64bit - Add a netlink attribute to a socket buffer and align it
-+ * @skb: socket buffer to add attribute to
-+ * @attrtype: attribute type
-+ * @attrlen: length of attribute payload
-+ * @data: head of attribute payload
-+ * @padattr: attribute type for the padding
-+ *
-+ * The caller is responsible to ensure that the skb provides enough
-+ * tailroom for the attribute header and payload.
-+ */
-+static inline void __nla_put_64bit(struct sk_buff *skb, int attrtype, int attrlen,
-+				   const void *data, int padattr)
-+{
-+	struct nlattr *nla;
-+
-+	nla = __nla_reserve_64bit(skb, attrtype, attrlen, padattr);
-+	memcpy(nla_data(nla), data, attrlen);
-+}
-+
-+/**
-+ * nla_total_size_64bit - total length of attribute including padding
-+ * @payload: length of payload
-+ */
-+static inline int nla_total_size_64bit(int payload)
-+{
-+	return NLA_ALIGN(nla_attr_size(payload))
-+#ifndef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS
-+		+ NLA_ALIGN(nla_attr_size(0))
-+#endif
-+		;
-+}
-+
-+/**
-+ * nla_put_64bit - Add a netlink attribute to a socket buffer and align it
-+ * @skb: socket buffer to add attribute to
-+ * @attrtype: attribute type
-+ * @attrlen: length of attribute payload
-+ * @data: head of attribute payload
-+ * @padattr: attribute type for the padding
-+ *
-+ * Returns -EMSGSIZE if the tailroom of the skb is insufficient to store
-+ * the attribute header and payload.
-+ */
-+static inline int nla_put_64bit(struct sk_buff *skb, int attrtype, int attrlen,
-+				const void *data, int padattr)
-+{
-+	size_t len;
-+
-+	if (nla_need_padding_for_64bit(skb))
-+		len = nla_total_size_64bit(attrlen);
-+	else
-+		len = nla_total_size(attrlen);
-+	if (unlikely(skb_tailroom(skb) < len))
-+		return -EMSGSIZE;
-+
-+	__nla_put_64bit(skb, attrtype, attrlen, data, padattr);
-+	return 0;
-+}
-+
-+/**
-+ * nla_put_u64_64bit - Add a u64 netlink attribute to a skb and align it
-+ * @skb: socket buffer to add attribute to
-+ * @attrtype: attribute type
-+ * @value: numeric value
-+ * @padattr: attribute type for the padding
-+ */
-+static inline int nla_put_u64_64bit(struct sk_buff *skb, int attrtype,
-+				    u64 value, int padattr)
-+{
-+	return nla_put_64bit(skb, attrtype, sizeof(u64), &value, padattr);
-+}
-+
-+
-+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0) */
-+
- #endif /* __BACKPORT_NET_NETLINK_H */
diff --git a/package/kernel/mac80211/patches/006-compat-bump-rhashtable-backport-version-due-to-API-c.patch b/package/kernel/mac80211/patches/006-compat-bump-rhashtable-backport-version-due-to-API-c.patch
deleted file mode 100644
index 1fdad3c..0000000
--- a/package/kernel/mac80211/patches/006-compat-bump-rhashtable-backport-version-due-to-API-c.patch
+++ /dev/null
@@ -1,18 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sat, 14 May 2016 16:44:57 +0200
-Subject: [PATCH] compat: bump rhashtable backport version due to API changes
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/compat/Kconfig
-+++ b/compat/Kconfig
-@@ -139,7 +139,7 @@ config BPAUTO_BUILD_WANT_DEV_COREDUMP
- config BPAUTO_RHASHTABLE
- 	bool
- 	# current API of rhashtable was introduced in version 4.1
--	depends on KERNEL_4_1
-+	depends on KERNEL_4_7
- 	# not very nice - but better than always having it
- 	default y if MAC80211
- 	#h-file linux/rhashtable.h
diff --git a/package/kernel/mac80211/patches/007-fix_duplicate_skcipher_backport.patch b/package/kernel/mac80211/patches/007-fix_duplicate_skcipher_backport.patch
deleted file mode 100644
index 38b3179..0000000
--- a/package/kernel/mac80211/patches/007-fix_duplicate_skcipher_backport.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/compat/Makefile
-+++ b/compat/Makefile
-@@ -35,8 +35,6 @@ compat-$(CPTCFG_KERNEL_4_6) += backport-
- 
- compat-$(CPTCFG_BPAUTO_BUILD_CRYPTO_CCM) += crypto-ccm.o
- compat-$(CPTCFG_BPAUTO_CRYPTO_SKCIPHER) += crypto-skcipher.o
--skcipher-objs += crypto-skcipher.o
--obj-$(CPTCFG_BPAUTO_CRYPTO_SKCIPHER) += skcipher.o
- compat-$(CPTCFG_BPAUTO_BUILD_WANT_DEV_COREDUMP) += drivers-base-devcoredump.o
- compat-$(CPTCFG_BPAUTO_RHASHTABLE) += lib-rhashtable.o
- cordic-objs += lib-cordic.o
diff --git a/package/kernel/mac80211/patches/010-disable_rfkill.patch b/package/kernel/mac80211/patches/010-disable_rfkill.patch
deleted file mode 100644
index c5a92d6..0000000
--- a/package/kernel/mac80211/patches/010-disable_rfkill.patch
+++ /dev/null
@@ -1,13 +0,0 @@
---- a/backport-include/linux/rfkill.h
-+++ b/backport-include/linux/rfkill.h
-@@ -2,6 +2,10 @@
- #define __COMPAT_RFKILL_H
- #include <linux/version.h>
- 
-+#undef CONFIG_RFKILL
-+#undef CONFIG_RFKILL_LEDS
-+#undef CONFIG_RFKILL_MODULE
-+
- #if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
- #include_next <linux/rfkill.h>
- #else
diff --git a/package/kernel/mac80211/patches/030-rt2x00_options.patch b/package/kernel/mac80211/patches/030-rt2x00_options.patch
deleted file mode 100644
index a4ca884..0000000
--- a/package/kernel/mac80211/patches/030-rt2x00_options.patch
+++ /dev/null
@@ -1,47 +0,0 @@
---- a/drivers/net/wireless/ralink/rt2x00/Kconfig
-+++ b/drivers/net/wireless/ralink/rt2x00/Kconfig
-@@ -225,36 +225,37 @@ config RT2800SOC
- 
- 
- config RT2800_LIB
--	tristate
-+	tristate "RT2800 USB/PCI support"
- 	depends on m
- 
- config RT2800_LIB_MMIO
--	tristate
-+	tristate "RT2800 MMIO support"
- 	depends on m
- 	select RT2X00_LIB_MMIO
- 	select RT2800_LIB
- 
- config RT2X00_LIB_MMIO
--	tristate
-+	tristate "RT2x00 MMIO support"
- 	depends on m
- 
- config RT2X00_LIB_PCI
--	tristate
-+	tristate "RT2x00 PCI support"
- 	depends on m
- 	select RT2X00_LIB
- 
- config RT2X00_LIB_SOC
--	tristate
-+	tristate "RT2x00 SoC support"
-+	depends on SOC_RT288X || SOC_RT305X
- 	depends on m
- 	select RT2X00_LIB
- 
- config RT2X00_LIB_USB
--	tristate
-+	tristate "RT2x00 USB support"
- 	depends on m
- 	select RT2X00_LIB
- 
- config RT2X00_LIB
--	tristate
-+	tristate "RT2x00 support"
- 	depends on m
- 
- config RT2X00_LIB_FIRMWARE
diff --git a/package/kernel/mac80211/patches/040-brcmutil_option.patch b/package/kernel/mac80211/patches/040-brcmutil_option.patch
deleted file mode 100644
index 167332d..0000000
--- a/package/kernel/mac80211/patches/040-brcmutil_option.patch
+++ /dev/null
@@ -1,9 +0,0 @@
---- a/drivers/net/wireless/broadcom/brcm80211/Kconfig
-+++ b/drivers/net/wireless/broadcom/brcm80211/Kconfig
-@@ -1,5 +1,5 @@
- config BRCMUTIL
--	tristate
-+	tristate "Broadcom 802.11 driver utility functions"
- 	depends on m
- 
- config BRCMSMAC
diff --git a/package/kernel/mac80211/patches/050-lib80211_option.patch b/package/kernel/mac80211/patches/050-lib80211_option.patch
deleted file mode 100644
index 3fc8c05..0000000
--- a/package/kernel/mac80211/patches/050-lib80211_option.patch
+++ /dev/null
@@ -1,30 +0,0 @@
---- a/net/wireless/Kconfig
-+++ b/net/wireless/Kconfig
-@@ -171,7 +171,7 @@ config CFG80211_WEXT_EXPORT
- 	  wext compatibility symbols to be exported.
- 
- config LIB80211
--	tristate
-+	tristate "lib80211"
- 	depends on m
- 	default n
- 	help
-@@ -181,15 +181,15 @@ config LIB80211
- 	  Drivers should select this themselves if needed.
- 
- config LIB80211_CRYPT_WEP
--	tristate
-+	tristate "lib80211 WEP support"
- 	depends on m
- 
- config LIB80211_CRYPT_CCMP
--	tristate
-+	tristate "lib80211 CCMP support"
- 	depends on m
- 
- config LIB80211_CRYPT_TKIP
--	tristate
-+	tristate "lib80211 TKIP support"
- 	depends on m
- 
- config LIB80211_DEBUG
diff --git a/package/kernel/mac80211/patches/060-no_local_ssb_bcma.patch b/package/kernel/mac80211/patches/060-no_local_ssb_bcma.patch
deleted file mode 100644
index e9a140c..0000000
--- a/package/kernel/mac80211/patches/060-no_local_ssb_bcma.patch
+++ /dev/null
@@ -1,132 +0,0 @@
---- a/.local-symbols
-+++ b/.local-symbols
-@@ -481,45 +481,6 @@ USB_IPHETH=
- USB_SIERRA_NET=
- USB_VL600=
- USB_NET_CH9200=
--SSB_POSSIBLE=
--SSB=
--SSB_SPROM=
--SSB_BLOCKIO=
--SSB_PCIHOST_POSSIBLE=
--SSB_PCIHOST=
--SSB_B43_PCI_BRIDGE=
--SSB_PCMCIAHOST_POSSIBLE=
--SSB_PCMCIAHOST=
--SSB_SDIOHOST_POSSIBLE=
--SSB_SDIOHOST=
--SSB_HOST_SOC=
--SSB_SILENT=
--SSB_DEBUG=
--SSB_SERIAL=
--SSB_DRIVER_PCICORE_POSSIBLE=
--SSB_DRIVER_PCICORE=
--SSB_PCICORE_HOSTMODE=
--SSB_DRIVER_MIPS=
--SSB_SFLASH=
--SSB_EMBEDDED=
--SSB_DRIVER_EXTIF=
--SSB_DRIVER_GIGE=
--SSB_DRIVER_GPIO=
--BCMA_POSSIBLE=
--BCMA=
--BCMA_BLOCKIO=
--BCMA_HOST_PCI_POSSIBLE=
--BCMA_HOST_PCI=
--BCMA_HOST_SOC=
--BCMA_DRIVER_PCI=
--BCMA_DRIVER_PCI_HOSTMODE=
--BCMA_DRIVER_MIPS=
--BCMA_PFLASH=
--BCMA_SFLASH=
--BCMA_NFLASH=
--BCMA_DRIVER_GMAC_CMN=
--BCMA_DRIVER_GPIO=
--BCMA_DEBUG=
- NFC=
- NFC_DIGITAL=
- NFC_NCI=
---- a/drivers/net/wireless/broadcom/b43/main.c
-+++ b/drivers/net/wireless/broadcom/b43/main.c
-@@ -2866,7 +2866,7 @@ static struct ssb_device *b43_ssb_gpio_d
- {
- 	struct ssb_bus *bus = dev->dev->sdev->bus;
- 
--#ifdef CPTCFG_SSB_DRIVER_PCICORE
-+#ifdef CONFIG_SSB_DRIVER_PCICORE
- 	return (bus->chipco.dev ? bus->chipco.dev : bus->pcicore.dev);
- #else
- 	return bus->chipco.dev;
-@@ -4901,7 +4901,7 @@ static int b43_wireless_core_init(struct
- 	}
- 	if (sprom->boardflags_lo & B43_BFL_XTAL_NOSLOW)
- 		hf |= B43_HF_DSCRQ; /* Disable slowclock requests from ucode. */
--#if defined(CPTCFG_B43_SSB) && defined(CPTCFG_SSB_DRIVER_PCICORE)
-+#if defined(CPTCFG_B43_SSB) && defined(CONFIG_SSB_DRIVER_PCICORE)
- 	if (dev->dev->bus_type == B43_BUS_SSB &&
- 	    dev->dev->sdev->bus->bustype == SSB_BUSTYPE_PCI &&
- 	    dev->dev->sdev->bus->pcicore.dev->id.revision <= 10)
---- a/drivers/net/wireless/broadcom/b43legacy/main.c
-+++ b/drivers/net/wireless/broadcom/b43legacy/main.c
-@@ -1937,7 +1937,7 @@ static int b43legacy_gpio_init(struct b4
- 	if (dev->dev->id.revision >= 2)
- 		mask  |= 0x0010; /* FIXME: This is redundant. */
- 
--#ifdef CPTCFG_SSB_DRIVER_PCICORE
-+#ifdef CONFIG_SSB_DRIVER_PCICORE
- 	pcidev = bus->pcicore.dev;
- #endif
- 	gpiodev = bus->chipco.dev ? : pcidev;
-@@ -1956,7 +1956,7 @@ static void b43legacy_gpio_cleanup(struc
- 	struct ssb_bus *bus = dev->dev->bus;
- 	struct ssb_device *gpiodev, *pcidev = NULL;
- 
--#ifdef CPTCFG_SSB_DRIVER_PCICORE
-+#ifdef CONFIG_SSB_DRIVER_PCICORE
- 	pcidev = bus->pcicore.dev;
- #endif
- 	gpiodev = bus->chipco.dev ? : pcidev;
---- a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/Makefile
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/Makefile
-@@ -43,6 +43,6 @@ brcmsmac-y := \
- 	brcms_trace_events.o \
- 	debug.o
- 
--brcmsmac-$(CPTCFG_BCMA_DRIVER_GPIO) += led.o
-+brcmsmac-$(CONFIG_BCMA_DRIVER_GPIO) += led.o
- 
- obj-$(CPTCFG_BRCMSMAC)	+= brcmsmac.o
---- a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/led.h
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/led.h
-@@ -22,7 +22,7 @@ struct brcms_led {
- 	bool active_low;
- };
- 
--#ifdef CPTCFG_BCMA_DRIVER_GPIO
-+#ifdef CONFIG_BCMA_DRIVER_GPIO
- void brcms_led_unregister(struct brcms_info *wl);
- int brcms_led_register(struct brcms_info *wl);
- #else
---- a/Kconfig.sources
-+++ b/Kconfig.sources
-@@ -9,9 +9,6 @@ source "$BACKPORT_DIR/drivers/net/wirele
- source "$BACKPORT_DIR/drivers/net/ethernet/Kconfig"
- source "$BACKPORT_DIR/drivers/net/usb/Kconfig"
- 
--source "$BACKPORT_DIR/drivers/ssb/Kconfig"
--source "$BACKPORT_DIR/drivers/bcma/Kconfig"
--
- source "$BACKPORT_DIR/net/nfc/Kconfig"
- 
- source "$BACKPORT_DIR/drivers/media/Kconfig"
---- a/Makefile.kernel
-+++ b/Makefile.kernel
-@@ -38,8 +38,6 @@ obj-$(CPTCFG_MAC80211) += net/mac80211/
- obj-$(CPTCFG_WLAN) += drivers/net/wireless/
- obj-$(CPTCFG_BT) += net/bluetooth/
- obj-$(CPTCFG_BT) += drivers/bluetooth/
--obj-$(CPTCFG_SSB) += drivers/ssb/
--obj-$(CPTCFG_BCMA) += drivers/bcma/
- obj-$(CPTCFG_ETHERNET) += drivers/net/ethernet/
- obj-$(CPTCFG_USB_NET_RNDIS_WLAN) += drivers/net/usb/
- obj-$(CPTCFG_NFC) += net/nfc/
diff --git a/package/kernel/mac80211/patches/070-ath_common_config.patch b/package/kernel/mac80211/patches/070-ath_common_config.patch
deleted file mode 100644
index 41774fe..0000000
--- a/package/kernel/mac80211/patches/070-ath_common_config.patch
+++ /dev/null
@@ -1,9 +0,0 @@
---- a/drivers/net/wireless/ath/Kconfig
-+++ b/drivers/net/wireless/ath/Kconfig
-@@ -1,5 +1,5 @@
- config ATH_COMMON
--	tristate
-+	tristate "ath.ko"
- 	depends on m
- 
- config WLAN_VENDOR_ATH
diff --git a/package/kernel/mac80211/patches/100-remove-cryptoapi-dependencies.patch b/package/kernel/mac80211/patches/100-remove-cryptoapi-dependencies.patch
deleted file mode 100644
index b65b0bd..0000000
--- a/package/kernel/mac80211/patches/100-remove-cryptoapi-dependencies.patch
+++ /dev/null
@@ -1,370 +0,0 @@
---- a/net/mac80211/Kconfig
-+++ b/net/mac80211/Kconfig
-@@ -5,8 +5,6 @@ config MAC80211
- 	depends on CRYPTO
- 	depends on CRYPTO_ARC4
- 	depends on CRYPTO_AES
--	select BPAUTO_CRYPTO_CCM
--	depends on CRYPTO_GCM
- 	depends on CRC32
- 	---help---
- 	  This option enables the hardware independent IEEE 802.11
---- a/net/mac80211/Makefile
-+++ b/net/mac80211/Makefile
-@@ -16,9 +16,7 @@ mac80211-y := \
- 	michael.o \
- 	tkip.o \
- 	aes_ccm.o \
--	aes_gcm.o \
- 	aes_cmac.o \
--	aes_gmac.o \
- 	cfg.o \
- 	ethtool.o \
- 	rx.o \
---- a/net/mac80211/aes_ccm.c
-+++ b/net/mac80211/aes_ccm.c
-@@ -13,89 +13,132 @@
- #include <linux/types.h>
- #include <linux/err.h>
- #include <crypto/aead.h>
-+#include <crypto/aes.h>
- 
- #include <net/mac80211.h>
- #include "key.h"
- #include "aes_ccm.h"
- 
--void ieee80211_aes_ccm_encrypt(struct crypto_aead *tfm, u8 *b_0, u8 *aad,
-+static void aes_ccm_prepare(struct crypto_cipher *tfm, u8 *b_0, u8 *aad, u8 *s_0,
-+			    u8 *a, u8 *b)
-+{
-+	int i;
-+
-+	crypto_cipher_encrypt_one(tfm, b, b_0);
-+
-+	/* Extra Authenticate-only data (always two AES blocks) */
-+	for (i = 0; i < AES_BLOCK_SIZE; i++)
-+		aad[i] ^= b[i];
-+	crypto_cipher_encrypt_one(tfm, b, aad);
-+
-+	aad += AES_BLOCK_SIZE;
-+
-+	for (i = 0; i < AES_BLOCK_SIZE; i++)
-+		aad[i] ^= b[i];
-+	crypto_cipher_encrypt_one(tfm, a, aad);
-+
-+	/* Mask out bits from auth-only-b_0 */
-+	b_0[0] &= 0x07;
-+
-+	/* S_0 is used to encrypt T (= MIC) */
-+	b_0[14] = 0;
-+	b_0[15] = 0;
-+	crypto_cipher_encrypt_one(tfm, s_0, b_0);
-+}
-+
-+
-+void ieee80211_aes_ccm_encrypt(struct crypto_cipher *tfm, u8 *b_0, u8 *aad,
- 			       u8 *data, size_t data_len, u8 *mic,
- 			       size_t mic_len)
- {
--	struct scatterlist sg[3];
-+	int i, j, last_len, num_blocks;
-+	u8 b[AES_BLOCK_SIZE];
-+	u8 s_0[AES_BLOCK_SIZE];
-+	u8 e[AES_BLOCK_SIZE];
-+	u8 *pos, *cpos;
- 
--	char aead_req_data[sizeof(struct aead_request) +
--			   crypto_aead_reqsize(tfm)]
--		__aligned(__alignof__(struct aead_request));
--	struct aead_request *aead_req = (void *) aead_req_data;
-+	num_blocks = DIV_ROUND_UP(data_len, AES_BLOCK_SIZE);
-+	last_len = data_len % AES_BLOCK_SIZE;
-+	aes_ccm_prepare(tfm, b_0, aad, s_0, b, b);
- 
--	memset(aead_req, 0, sizeof(aead_req_data));
-+	/* Process payload blocks */
-+	pos = data;
-+	cpos = data;
-+	for (j = 1; j <= num_blocks; j++) {
-+		int blen = (j == num_blocks && last_len) ?
-+			last_len : AES_BLOCK_SIZE;
- 
--	sg_init_table(sg, 3);
--	sg_set_buf(&sg[0], &aad[2], be16_to_cpup((__be16 *)aad));
--	sg_set_buf(&sg[1], data, data_len);
--	sg_set_buf(&sg[2], mic, mic_len);
-+		/* Authentication followed by encryption */
-+		for (i = 0; i < blen; i++)
-+			b[i] ^= pos[i];
-+		crypto_cipher_encrypt_one(tfm, b, b);
- 
--	aead_request_set_tfm(aead_req, tfm);
--	aead_request_set_crypt(aead_req, sg, sg, data_len, b_0);
--	aead_request_set_ad(aead_req, sg[0].length);
-+		b_0[14] = (j >> 8) & 0xff;
-+		b_0[15] = j & 0xff;
-+		crypto_cipher_encrypt_one(tfm, e, b_0);
-+		for (i = 0; i < blen; i++)
-+			*cpos++ = *pos++ ^ e[i];
-+	}
- 
--	crypto_aead_encrypt(aead_req);
-+	for (i = 0; i < mic_len; i++)
-+		mic[i] = b[i] ^ s_0[i];
- }
- 
--int ieee80211_aes_ccm_decrypt(struct crypto_aead *tfm, u8 *b_0, u8 *aad,
-+int ieee80211_aes_ccm_decrypt(struct crypto_cipher *tfm, u8 *b_0, u8 *aad,
- 			      u8 *data, size_t data_len, u8 *mic,
- 			      size_t mic_len)
- {
--	struct scatterlist sg[3];
--	char aead_req_data[sizeof(struct aead_request) +
--			   crypto_aead_reqsize(tfm)]
--		__aligned(__alignof__(struct aead_request));
--	struct aead_request *aead_req = (void *) aead_req_data;
-+	int i, j, last_len, num_blocks;
-+	u8 *pos, *cpos;
-+	u8 a[AES_BLOCK_SIZE];
-+	u8 b[AES_BLOCK_SIZE];
-+	u8 s_0[AES_BLOCK_SIZE];
- 
--	if (data_len == 0)
--		return -EINVAL;
-+	num_blocks = DIV_ROUND_UP(data_len, AES_BLOCK_SIZE);
-+	last_len = data_len % AES_BLOCK_SIZE;
-+	aes_ccm_prepare(tfm, b_0, aad, s_0, a, b);
- 
--	memset(aead_req, 0, sizeof(aead_req_data));
-+	/* Process payload blocks */
-+	cpos = data;
-+	pos = data;
-+	for (j = 1; j <= num_blocks; j++) {
-+		int blen = (j == num_blocks && last_len) ?
-+			last_len : AES_BLOCK_SIZE;
- 
--	sg_init_table(sg, 3);
--	sg_set_buf(&sg[0], &aad[2], be16_to_cpup((__be16 *)aad));
--	sg_set_buf(&sg[1], data, data_len);
--	sg_set_buf(&sg[2], mic, mic_len);
-+		/* Decryption followed by authentication */
-+		b_0[14] = (j >> 8) & 0xff;
-+		b_0[15] = j & 0xff;
-+		crypto_cipher_encrypt_one(tfm, b, b_0);
-+		for (i = 0; i < blen; i++) {
-+			*pos = *cpos++ ^ b[i];
-+			a[i] ^= *pos++;
-+		}
-+		crypto_cipher_encrypt_one(tfm, a, a);
-+	}
- 
--	aead_request_set_tfm(aead_req, tfm);
--	aead_request_set_crypt(aead_req, sg, sg, data_len + mic_len, b_0);
--	aead_request_set_ad(aead_req, sg[0].length);
-+	for (i = 0; i < mic_len; i++) {
-+		if ((mic[i] ^ s_0[i]) != a[i])
-+			return -1;
-+	}
- 
--	return crypto_aead_decrypt(aead_req);
-+	return 0;
- }
- 
--struct crypto_aead *ieee80211_aes_key_setup_encrypt(const u8 key[],
--						    size_t key_len,
--						    size_t mic_len)
-+struct crypto_cipher *ieee80211_aes_key_setup_encrypt(const u8 key[],
-+						      size_t key_len,
-+						      size_t mic_len)
- {
--	struct crypto_aead *tfm;
--	int err;
--
--	tfm = crypto_alloc_aead("ccm(aes)", 0, CRYPTO_ALG_ASYNC);
--	if (IS_ERR(tfm))
--		return tfm;
-+	struct crypto_cipher *tfm;
- 
--	err = crypto_aead_setkey(tfm, key, key_len);
--	if (err)
--		goto free_aead;
--	err = crypto_aead_setauthsize(tfm, mic_len);
--	if (err)
--		goto free_aead;
-+	tfm = crypto_alloc_cipher("aes", 0, CRYPTO_ALG_ASYNC);
-+	if (!IS_ERR(tfm))
-+		crypto_cipher_setkey(tfm, key, key_len);
- 
- 	return tfm;
--
--free_aead:
--	crypto_free_aead(tfm);
--	return ERR_PTR(err);
- }
- 
--void ieee80211_aes_key_free(struct crypto_aead *tfm)
-+
-+void ieee80211_aes_key_free(struct crypto_cipher *tfm)
- {
--	crypto_free_aead(tfm);
-+	crypto_free_cipher(tfm);
- }
---- a/net/mac80211/aes_ccm.h
-+++ b/net/mac80211/aes_ccm.h
-@@ -12,15 +12,15 @@
- 
- #include <linux/crypto.h>
- 
--struct crypto_aead *ieee80211_aes_key_setup_encrypt(const u8 key[],
--						    size_t key_len,
--						    size_t mic_len);
--void ieee80211_aes_ccm_encrypt(struct crypto_aead *tfm, u8 *b_0, u8 *aad,
-+struct crypto_cipher *ieee80211_aes_key_setup_encrypt(const u8 key[],
-+						      size_t key_len,
-+						      size_t mic_len);
-+void ieee80211_aes_ccm_encrypt(struct crypto_cipher *tfm, u8 *b_0, u8 *aad,
- 			       u8 *data, size_t data_len, u8 *mic,
- 			       size_t mic_len);
--int ieee80211_aes_ccm_decrypt(struct crypto_aead *tfm, u8 *b_0, u8 *aad,
-+int ieee80211_aes_ccm_decrypt(struct crypto_cipher *tfm, u8 *b_0, u8 *aad,
- 			      u8 *data, size_t data_len, u8 *mic,
- 			      size_t mic_len);
--void ieee80211_aes_key_free(struct crypto_aead *tfm);
-+void ieee80211_aes_key_free(struct crypto_cipher *tfm);
- 
- #endif /* AES_CCM_H */
---- a/net/mac80211/aes_gcm.h
-+++ b/net/mac80211/aes_gcm.h
-@@ -11,12 +11,28 @@
- 
- #include <linux/crypto.h>
- 
--void ieee80211_aes_gcm_encrypt(struct crypto_aead *tfm, u8 *j_0, u8 *aad,
--			       u8 *data, size_t data_len, u8 *mic);
--int ieee80211_aes_gcm_decrypt(struct crypto_aead *tfm, u8 *j_0, u8 *aad,
--			      u8 *data, size_t data_len, u8 *mic);
--struct crypto_aead *ieee80211_aes_gcm_key_setup_encrypt(const u8 key[],
--							size_t key_len);
--void ieee80211_aes_gcm_key_free(struct crypto_aead *tfm);
-+static inline void
-+ieee80211_aes_gcm_encrypt(struct crypto_aead *tfm, u8 *j_0, u8 *aad,
-+			  u8 *data, size_t data_len, u8 *mic)
-+{
-+}
-+
-+static inline int
-+ieee80211_aes_gcm_decrypt(struct crypto_aead *tfm, u8 *j_0, u8 *aad,
-+			  u8 *data, size_t data_len, u8 *mic)
-+{
-+    return -EOPNOTSUPP;
-+}
-+
-+static inline struct crypto_aead *
-+ieee80211_aes_gcm_key_setup_encrypt(const u8 key[], size_t key_len)
-+{
-+    return NULL;
-+}
-+
-+static inline void
-+ieee80211_aes_gcm_key_free(struct crypto_aead *tfm)
-+{
-+}
- 
- #endif /* AES_GCM_H */
---- a/net/mac80211/aes_gmac.h
-+++ b/net/mac80211/aes_gmac.h
-@@ -11,10 +11,22 @@
- 
- #include <linux/crypto.h>
- 
--struct crypto_aead *ieee80211_aes_gmac_key_setup(const u8 key[],
--						 size_t key_len);
--int ieee80211_aes_gmac(struct crypto_aead *tfm, const u8 *aad, u8 *nonce,
--		       const u8 *data, size_t data_len, u8 *mic);
--void ieee80211_aes_gmac_key_free(struct crypto_aead *tfm);
-+static inline struct crypto_aead *
-+ieee80211_aes_gmac_key_setup(const u8 key[], size_t key_len)
-+{
-+	return NULL;
-+}
-+
-+static inline int
-+ieee80211_aes_gmac(struct crypto_aead *tfm, const u8 *aad, u8 *nonce,
-+		   const u8 *data, size_t data_len, u8 *mic)
-+{
-+	return -EOPNOTSUPP;
-+}
-+
-+static inline void
-+ieee80211_aes_gmac_key_free(struct crypto_aead *tfm)
-+{
-+}
- 
- #endif /* AES_GMAC_H */
---- a/net/mac80211/key.h
-+++ b/net/mac80211/key.h
-@@ -88,7 +88,7 @@ struct ieee80211_key {
- 			 * Management frames.
- 			 */
- 			u8 rx_pn[IEEE80211_NUM_TIDS + 1][IEEE80211_CCMP_PN_LEN];
--			struct crypto_aead *tfm;
-+			struct crypto_cipher *tfm;
- 			u32 replays; /* dot11RSNAStatsCCMPReplays */
- 		} ccmp;
- 		struct {
---- a/net/mac80211/wpa.c
-+++ b/net/mac80211/wpa.c
-@@ -304,7 +304,8 @@ ieee80211_crypto_tkip_decrypt(struct iee
- }
- 
- 
--static void ccmp_special_blocks(struct sk_buff *skb, u8 *pn, u8 *b_0, u8 *aad)
-+static void ccmp_special_blocks(struct sk_buff *skb, u8 *pn, u8 *b_0, u8 *aad,
-+				u16 data_len)
- {
- 	__le16 mask_fc;
- 	int a4_included, mgmt;
-@@ -334,14 +335,8 @@ static void ccmp_special_blocks(struct s
- 	else
- 		qos_tid = 0;
- 
--	/* In CCM, the initial vectors (IV) used for CTR mode encryption and CBC
--	 * mode authentication are not allowed to collide, yet both are derived
--	 * from this vector b_0. We only set L := 1 here to indicate that the
--	 * data size can be represented in (L+1) bytes. The CCM layer will take
--	 * care of storing the data length in the top (L+1) bytes and setting
--	 * and clearing the other bits as is required to derive the two IVs.
--	 */
--	b_0[0] = 0x1;
-+	/* First block, b_0 */
-+	b_0[0] = 0x59; /* flags: Adata: 1, M: 011, L: 001 */
- 
- 	/* Nonce: Nonce Flags | A2 | PN
- 	 * Nonce Flags: Priority (b0..b3) | Management (b4) | Reserved (b5..b7)
-@@ -349,6 +344,8 @@ static void ccmp_special_blocks(struct s
- 	b_0[1] = qos_tid | (mgmt << 4);
- 	memcpy(&b_0[2], hdr->addr2, ETH_ALEN);
- 	memcpy(&b_0[8], pn, IEEE80211_CCMP_PN_LEN);
-+	/* l(m) */
-+	put_unaligned_be16(data_len, &b_0[14]);
- 
- 	/* AAD (extra authenticate-only data) / masked 802.11 header
- 	 * FC | A1 | A2 | A3 | SC | [A4] | [QC] */
-@@ -460,7 +457,7 @@ static int ccmp_encrypt_skb(struct ieee8
- 		return 0;
- 
- 	pos += IEEE80211_CCMP_HDR_LEN;
--	ccmp_special_blocks(skb, pn, b_0, aad);
-+	ccmp_special_blocks(skb, pn, b_0, aad, len);
- 	ieee80211_aes_ccm_encrypt(key->u.ccmp.tfm, b_0, aad, pos, len,
- 				  skb_put(skb, mic_len), mic_len);
- 
-@@ -537,7 +534,7 @@ ieee80211_crypto_ccmp_decrypt(struct iee
- 			u8 aad[2 * AES_BLOCK_SIZE];
- 			u8 b_0[AES_BLOCK_SIZE];
- 			/* hardware didn't decrypt/verify MIC */
--			ccmp_special_blocks(skb, pn, b_0, aad);
-+			ccmp_special_blocks(skb, pn, b_0, aad, data_len);
- 
- 			if (ieee80211_aes_ccm_decrypt(
- 				    key->u.ccmp.tfm, b_0, aad,
diff --git a/package/kernel/mac80211/patches/110-mac80211_keep_keys_on_stop_ap.patch b/package/kernel/mac80211/patches/110-mac80211_keep_keys_on_stop_ap.patch
deleted file mode 100644
index 3ca166f..0000000
--- a/package/kernel/mac80211/patches/110-mac80211_keep_keys_on_stop_ap.patch
+++ /dev/null
@@ -1,12 +0,0 @@
-Used for AP+STA support in OpenWrt - preserve AP mode keys across STA reconnects
-
---- a/net/mac80211/cfg.c
-+++ b/net/mac80211/cfg.c
-@@ -850,7 +850,6 @@ static int ieee80211_stop_ap(struct wiph
- 	sdata->u.ap.driver_smps_mode = IEEE80211_SMPS_OFF;
- 
- 	__sta_info_flush(sdata, true);
--	ieee80211_free_keys(sdata, true);
- 
- 	sdata->vif.bss_conf.enable_beacon = false;
- 	sdata->vif.bss_conf.ssid_len = 0;
diff --git a/package/kernel/mac80211/patches/120-cfg80211_allow_perm_addr_change.patch b/package/kernel/mac80211/patches/120-cfg80211_allow_perm_addr_change.patch
deleted file mode 100644
index ffd8807..0000000
--- a/package/kernel/mac80211/patches/120-cfg80211_allow_perm_addr_change.patch
+++ /dev/null
@@ -1,43 +0,0 @@
---- a/net/wireless/sysfs.c
-+++ b/net/wireless/sysfs.c
-@@ -24,18 +24,35 @@ static inline struct cfg80211_registered
- 	return container_of(dev, struct cfg80211_registered_device, wiphy.dev);
- }
- 
--#define SHOW_FMT(name, fmt, member)					\
-+#define SHOW_FMT(name, fmt, member, mode)				\
- static ssize_t name ## _show(struct device *dev,			\
- 			      struct device_attribute *attr,		\
- 			      char *buf)				\
- {									\
- 	return sprintf(buf, fmt "\n", dev_to_rdev(dev)->member);	\
- }									\
--static DEVICE_ATTR_RO(name)
-+static DEVICE_ATTR_##mode(name)
- 
--SHOW_FMT(index, "%d", wiphy_idx);
--SHOW_FMT(macaddress, "%pM", wiphy.perm_addr);
--SHOW_FMT(address_mask, "%pM", wiphy.addr_mask);
-+static ssize_t macaddress_store(struct device *dev,
-+				struct device_attribute *attr,
-+				const char *buf, size_t len)
-+{
-+	u8 mac[ETH_ALEN];
-+
-+	if (!mac_pton(buf, mac))
-+		return -EINVAL;
-+
-+	if (buf[3 * ETH_ALEN - 1] && buf[3 * ETH_ALEN - 1] != '\n')
-+		return -EINVAL;
-+
-+	memcpy(dev_to_rdev(dev)->wiphy.perm_addr, mac, ETH_ALEN);
-+
-+	return strnlen(buf, len);
-+}
-+
-+SHOW_FMT(index, "%d", wiphy_idx, RO);
-+SHOW_FMT(macaddress, "%pM", wiphy.perm_addr, RW);
-+SHOW_FMT(address_mask, "%pM", wiphy.addr_mask, RO);
- 
- static ssize_t name_show(struct device *dev,
- 			 struct device_attribute *attr,
diff --git a/package/kernel/mac80211/patches/150-disable_addr_notifier.patch b/package/kernel/mac80211/patches/150-disable_addr_notifier.patch
deleted file mode 100644
index 3029598..0000000
--- a/package/kernel/mac80211/patches/150-disable_addr_notifier.patch
+++ /dev/null
@@ -1,67 +0,0 @@
---- a/net/mac80211/main.c
-+++ b/net/mac80211/main.c
-@@ -291,7 +291,7 @@ void ieee80211_restart_hw(struct ieee802
- }
- EXPORT_SYMBOL(ieee80211_restart_hw);
- 
--#ifdef CONFIG_INET
-+#ifdef __disabled__CONFIG_INET
- static int ieee80211_ifa_changed(struct notifier_block *nb,
- 				 unsigned long data, void *arg)
- {
-@@ -350,7 +350,7 @@ static int ieee80211_ifa_changed(struct
- }
- #endif
- 
--#if IS_ENABLED(CONFIG_IPV6)
-+#if IS_ENABLED(__disabled__CONFIG_IPV6)
- static int ieee80211_ifa6_changed(struct notifier_block *nb,
- 				  unsigned long data, void *arg)
- {
-@@ -1089,14 +1089,14 @@ int ieee80211_register_hw(struct ieee802
- 
- 	rtnl_unlock();
- 
--#ifdef CONFIG_INET
-+#ifdef __disabled__CONFIG_INET
- 	local->ifa_notifier.notifier_call = ieee80211_ifa_changed;
- 	result = register_inetaddr_notifier(&local->ifa_notifier);
- 	if (result)
- 		goto fail_ifa;
- #endif
- 
--#if IS_ENABLED(CONFIG_IPV6)
-+#if IS_ENABLED(__disabled__CONFIG_IPV6)
- 	local->ifa6_notifier.notifier_call = ieee80211_ifa6_changed;
- 	result = register_inet6addr_notifier(&local->ifa6_notifier);
- 	if (result)
-@@ -1105,13 +1105,13 @@ int ieee80211_register_hw(struct ieee802
- 
- 	return 0;
- 
--#if IS_ENABLED(CONFIG_IPV6)
-+#if IS_ENABLED(__disabled__CONFIG_IPV6)
-  fail_ifa6:
--#ifdef CONFIG_INET
-+#ifdef __disabled__CONFIG_INET
- 	unregister_inetaddr_notifier(&local->ifa_notifier);
- #endif
- #endif
--#if defined(CONFIG_INET) || defined(CONFIG_IPV6)
-+#if defined(__disabled__CONFIG_INET) || defined(__disabled__CONFIG_IPV6)
-  fail_ifa:
- #endif
- 	rtnl_lock();
-@@ -1139,10 +1139,10 @@ void ieee80211_unregister_hw(struct ieee
- 	tasklet_kill(&local->tx_pending_tasklet);
- 	tasklet_kill(&local->tasklet);
- 
--#ifdef CONFIG_INET
-+#ifdef __disabled__CONFIG_INET
- 	unregister_inetaddr_notifier(&local->ifa_notifier);
- #endif
--#if IS_ENABLED(CONFIG_IPV6)
-+#if IS_ENABLED(__disabled__CONFIG_IPV6)
- 	unregister_inet6addr_notifier(&local->ifa6_notifier);
- #endif
- 
diff --git a/package/kernel/mac80211/patches/201-ath5k-WAR-for-AR71xx-PCI-bug.patch b/package/kernel/mac80211/patches/201-ath5k-WAR-for-AR71xx-PCI-bug.patch
deleted file mode 100644
index 21516ff..0000000
--- a/package/kernel/mac80211/patches/201-ath5k-WAR-for-AR71xx-PCI-bug.patch
+++ /dev/null
@@ -1,38 +0,0 @@
---- a/drivers/net/wireless/ath/ath5k/initvals.c
-+++ b/drivers/net/wireless/ath/ath5k/initvals.c
-@@ -62,8 +62,14 @@ static const struct ath5k_ini ar5210_ini
- 	{ AR5K_IMR,		0 },
- 	{ AR5K_IER,		AR5K_IER_DISABLE },
- 	{ AR5K_BSR,		0, AR5K_INI_READ },
-+#if !defined(CONFIG_ATHEROS_AR71XX) && !defined(CONFIG_ATH79)
- 	{ AR5K_TXCFG,		AR5K_DMASIZE_128B },
- 	{ AR5K_RXCFG,		AR5K_DMASIZE_128B },
-+#else
-+	/* WAR for AR71xx PCI bug */
-+	{ AR5K_TXCFG,		AR5K_DMASIZE_128B },
-+	{ AR5K_RXCFG,		AR5K_DMASIZE_4B },
-+#endif
- 	{ AR5K_CFG,		AR5K_INIT_CFG },
- 	{ AR5K_TOPS,		8 },
- 	{ AR5K_RXNOFRM,		8 },
---- a/drivers/net/wireless/ath/ath5k/dma.c
-+++ b/drivers/net/wireless/ath/ath5k/dma.c
-@@ -869,10 +869,18 @@ ath5k_hw_dma_init(struct ath5k_hw *ah)
- 	 * guess we can tweak it and see how it goes ;-)
- 	 */
- 	if (ah->ah_version != AR5K_AR5210) {
-+#if !defined(CONFIG_ATHEROS_AR71XX) && !defined(CONFIG_ATH79)
- 		AR5K_REG_WRITE_BITS(ah, AR5K_TXCFG,
- 			AR5K_TXCFG_SDMAMR, AR5K_DMASIZE_128B);
- 		AR5K_REG_WRITE_BITS(ah, AR5K_RXCFG,
- 			AR5K_RXCFG_SDMAMW, AR5K_DMASIZE_128B);
-+#else
-+		/* WAR for AR71xx PCI bug */
-+		AR5K_REG_WRITE_BITS(ah, AR5K_TXCFG,
-+			AR5K_TXCFG_SDMAMR, AR5K_DMASIZE_128B);
-+		AR5K_REG_WRITE_BITS(ah, AR5K_RXCFG,
-+			AR5K_RXCFG_SDMAMW, AR5K_DMASIZE_4B);
-+#endif
- 	}
- 
- 	/* Pre-enable interrupts on 5211/5212*/
diff --git a/package/kernel/mac80211/patches/210-ap_scan.patch b/package/kernel/mac80211/patches/210-ap_scan.patch
deleted file mode 100644
index 29f05c4..0000000
--- a/package/kernel/mac80211/patches/210-ap_scan.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/net/mac80211/cfg.c
-+++ b/net/mac80211/cfg.c
-@@ -2008,7 +2008,7 @@ static int ieee80211_scan(struct wiphy *
- 		 * the  frames sent while scanning on other channel will be
- 		 * lost)
- 		 */
--		if (sdata->u.ap.beacon &&
-+		if (0 && sdata->u.ap.beacon &&
- 		    (!(wiphy->features & NL80211_FEATURE_AP_SCAN) ||
- 		     !(req->flags & NL80211_SCAN_FLAG_AP)))
- 			return -EOPNOTSUPP;
diff --git a/package/kernel/mac80211/patches/300-ath9k-force-rx_clear-when-disabling-rx.patch b/package/kernel/mac80211/patches/300-ath9k-force-rx_clear-when-disabling-rx.patch
deleted file mode 100644
index 4ba60c6..0000000
--- a/package/kernel/mac80211/patches/300-ath9k-force-rx_clear-when-disabling-rx.patch
+++ /dev/null
@@ -1,31 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sun, 7 Jun 2015 13:53:35 +0200
-Subject: [PATCH] ath9k: force rx_clear when disabling rx
-
-This makes stopping Rx more reliable and should reduce the frequency of
-Rx related DMA stop warnings
-
-Cc: stable@vger.kernel.org
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/drivers/net/wireless/ath/ath9k/mac.c
-+++ b/drivers/net/wireless/ath/ath9k/mac.c
-@@ -677,13 +677,15 @@ void ath9k_hw_startpcureceive(struct ath
- 
- 	ath9k_ani_reset(ah, is_scanning);
- 
--	REG_CLR_BIT(ah, AR_DIAG_SW, (AR_DIAG_RX_DIS | AR_DIAG_RX_ABORT));
-+	REG_CLR_BIT(ah, AR_DIAG_SW,
-+		    AR_DIAG_RX_DIS | AR_DIAG_RX_ABORT | AR_DIAG_FORCE_RX_CLEAR);
- }
- EXPORT_SYMBOL(ath9k_hw_startpcureceive);
- 
- void ath9k_hw_abortpcurecv(struct ath_hw *ah)
- {
--	REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_RX_ABORT | AR_DIAG_RX_DIS);
-+	REG_SET_BIT(ah, AR_DIAG_SW,
-+		    AR_DIAG_RX_DIS | AR_DIAG_RX_ABORT | AR_DIAG_FORCE_RX_CLEAR);
- 
- 	ath9k_hw_disable_mib_counters(ah);
- }
diff --git a/package/kernel/mac80211/patches/301-ath9k-limit-retries-for-powersave-response-frames.patch b/package/kernel/mac80211/patches/301-ath9k-limit-retries-for-powersave-response-frames.patch
deleted file mode 100644
index 358d028..0000000
--- a/package/kernel/mac80211/patches/301-ath9k-limit-retries-for-powersave-response-frames.patch
+++ /dev/null
@@ -1,121 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Thu, 2 Jul 2015 15:20:56 +0200
-Subject: [PATCH] ath9k: limit retries for powersave response frames
-
-In some cases, the channel might be busy enough that an ath9k AP's
-response to PS-Poll frames might be too slow and the station has already
-gone to sleep. To avoid wasting too much airtime on this, limit the
-number of retries on such frames and ensure that no sample rate gets
-used.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/drivers/net/wireless/ath/ath9k/xmit.c
-+++ b/drivers/net/wireless/ath/ath9k/xmit.c
-@@ -136,10 +136,25 @@ static void ath_send_bar(struct ath_atx_
- }
- 
- static void ath_set_rates(struct ieee80211_vif *vif, struct ieee80211_sta *sta,
--			  struct ath_buf *bf)
-+			  struct ath_buf *bf, bool ps)
- {
-+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(bf->bf_mpdu);
-+
-+	if (ps) {
-+		/* Clear the first rate to avoid using a sample rate for PS frames */
-+		info->control.rates[0].idx = -1;
-+		info->control.rates[0].count = 0;
-+	}
-+
- 	ieee80211_get_tx_rates(vif, sta, bf->bf_mpdu, bf->rates,
- 			       ARRAY_SIZE(bf->rates));
-+	if (!ps)
-+		return;
-+
-+	if (bf->rates[0].count > 2)
-+		bf->rates[0].count = 2;
-+
-+	bf->rates[1].idx = -1;
- }
- 
- static void ath_txq_skb_done(struct ath_softc *sc, struct ath_txq *txq,
-@@ -1419,7 +1434,7 @@ ath_tx_form_burst(struct ath_softc *sc,
- 		if (tx_info->flags & IEEE80211_TX_CTL_AMPDU)
- 			break;
- 
--		ath_set_rates(tid->an->vif, tid->an->sta, bf);
-+		ath_set_rates(tid->an->vif, tid->an->sta, bf, false);
- 	} while (1);
- }
- 
-@@ -1450,7 +1465,7 @@ static bool ath_tx_sched_aggr(struct ath
- 		return false;
- 	}
- 
--	ath_set_rates(tid->an->vif, tid->an->sta, bf);
-+	ath_set_rates(tid->an->vif, tid->an->sta, bf, false);
- 	if (aggr)
- 		last = ath_tx_form_aggr(sc, txq, tid, &bf_q, bf,
- 					tid_q, &aggr_len);
-@@ -1647,7 +1662,7 @@ void ath9k_release_buffered_frames(struc
- 
- 			__skb_unlink(bf->bf_mpdu, tid_q);
- 			list_add_tail(&bf->list, &bf_q);
--			ath_set_rates(tid->an->vif, tid->an->sta, bf);
-+			ath_set_rates(tid->an->vif, tid->an->sta, bf, true);
- 			if (bf_isampdu(bf)) {
- 				ath_tx_addto_baw(sc, tid, bf);
- 				bf->bf_state.bf_type &= ~BUF_AGGR;
-@@ -2293,7 +2308,7 @@ int ath_tx_start(struct ieee80211_hw *hw
- 	struct ath_txq *txq = txctl->txq;
- 	struct ath_atx_tid *tid = NULL;
- 	struct ath_buf *bf;
--	bool queue, skip_uapsd = false, ps_resp;
-+	bool queue, ps_resp;
- 	int q, ret;
- 
- 	if (vif)
-@@ -2346,13 +2361,13 @@ int ath_tx_start(struct ieee80211_hw *hw
- 		if (!txctl->an)
- 			txctl->an = &avp->mcast_node;
- 		queue = true;
--		skip_uapsd = true;
-+		ps_resp = false;
- 	}
- 
- 	if (txctl->an && queue)
- 		tid = ath_get_skb_tid(sc, txctl->an, skb);
- 
--	if (!skip_uapsd && ps_resp) {
-+	if (ps_resp) {
- 		ath_txq_unlock(sc, txq);
- 		txq = sc->tx.uapsdq;
- 		ath_txq_lock(sc, txq);
-@@ -2390,7 +2405,7 @@ int ath_tx_start(struct ieee80211_hw *hw
- 	if (txctl->paprd)
- 		bf->bf_state.bfs_paprd_timestamp = jiffies;
- 
--	ath_set_rates(vif, sta, bf);
-+	ath_set_rates(vif, sta, bf, ps_resp);
- 	ath_tx_send_normal(sc, txq, tid, skb);
- 
- out:
-@@ -2429,7 +2444,7 @@ void ath_tx_cabq(struct ieee80211_hw *hw
- 			break;
- 
- 		bf->bf_lastbf = bf;
--		ath_set_rates(vif, NULL, bf);
-+		ath_set_rates(vif, NULL, bf, false);
- 		ath_buf_set_rate(sc, bf, &info, fi->framelen, false);
- 		duration += info.rates[0].PktDuration;
- 		if (bf_tail)
-@@ -2932,7 +2947,7 @@ int ath9k_tx99_send(struct ath_softc *sc
- 		return -EINVAL;
- 	}
- 
--	ath_set_rates(sc->tx99_vif, NULL, bf);
-+	ath_set_rates(sc->tx99_vif, NULL, bf, false);
- 
- 	ath9k_hw_set_desc_link(sc->sc_ah, bf->bf_desc, bf->bf_daddr);
- 	ath9k_hw_tx99_start(sc->sc_ah, txctl->txq->axq_qnum);
diff --git a/package/kernel/mac80211/patches/302-Revert-ath9k-interpret-requested-txpower-in-EIRP-dom.patch b/package/kernel/mac80211/patches/302-Revert-ath9k-interpret-requested-txpower-in-EIRP-dom.patch
deleted file mode 100644
index 7caa9be..0000000
--- a/package/kernel/mac80211/patches/302-Revert-ath9k-interpret-requested-txpower-in-EIRP-dom.patch
+++ /dev/null
@@ -1,37 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sat, 14 May 2016 14:51:02 +0200
-Subject: [PATCH] Revert "ath9k: interpret requested txpower in EIRP
- domain"
-
-This reverts commit 71f5137bf010c6faffab50c0ec15374c59c4a411.
----
-
---- a/drivers/net/wireless/ath/ath9k/hw.c
-+++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -2914,7 +2914,8 @@ void ath9k_hw_apply_txpower(struct ath_h
- {
- 	struct ath_regulatory *reg = ath9k_hw_regulatory(ah);
- 	struct ieee80211_channel *channel;
--	int chan_pwr, new_pwr;
-+	int chan_pwr, new_pwr, max_gain;
-+	int ant_gain, ant_reduction = 0;
- 
- 	if (!chan)
- 		return;
-@@ -2922,10 +2923,15 @@ void ath9k_hw_apply_txpower(struct ath_h
- 	channel = chan->chan;
- 	chan_pwr = min_t(int, channel->max_power * 2, MAX_RATE_POWER);
- 	new_pwr = min_t(int, chan_pwr, reg->power_limit);
-+	max_gain = chan_pwr - new_pwr + channel->max_antenna_gain * 2;
-+
-+	ant_gain = get_antenna_gain(ah, chan);
-+	if (ant_gain > max_gain)
-+		ant_reduction = ant_gain - max_gain;
- 
- 	ah->eep_ops->set_txpower(ah, chan,
- 				 ath9k_regd_get_ctl(reg, chan),
--				 get_antenna_gain(ah, chan), new_pwr, test);
-+				 ant_reduction, new_pwr, test);
- }
- 
- void ath9k_hw_set_txpowerlimit(struct ath_hw *ah, u32 limit, bool test)
diff --git a/package/kernel/mac80211/patches/303-mac80211-mesh-flush-mesh-paths-unconditionally.patch b/package/kernel/mac80211/patches/303-mac80211-mesh-flush-mesh-paths-unconditionally.patch
deleted file mode 100644
index 518d0a3..0000000
--- a/package/kernel/mac80211/patches/303-mac80211-mesh-flush-mesh-paths-unconditionally.patch
+++ /dev/null
@@ -1,146 +0,0 @@
-From: Bob Copeland <me@bobcopeland.com>
-Date: Sun, 15 May 2016 13:19:16 -0400
-Subject: [PATCH] mac80211: mesh: flush mesh paths unconditionally
-
-Currently, the mesh paths associated with a nexthop station are cleaned
-up in the following code path:
-
-    __sta_info_destroy_part1
-    synchronize_net()
-    __sta_info_destroy_part2
-     -> cleanup_single_sta
-       -> mesh_sta_cleanup
-         -> mesh_plink_deactivate
-           -> mesh_path_flush_by_nexthop
-
-However, there are a couple of problems here:
-
-1) the paths aren't flushed at all if the MPM is running in userspace
-   (e.g. when using wpa_supplicant or authsae)
-
-2) there is no synchronize_rcu between removing the path and readers
-   accessing the nexthop, which means the following race is possible:
-
-CPU0                            CPU1
-~~~~                            ~~~~
-                                sta_info_destroy_part1()
-                                synchronize_net()
-rcu_read_lock()
-mesh_nexthop_resolve()
-  mpath = mesh_path_lookup()
-                                [...] -> mesh_path_flush_by_nexthop()
-  sta = rcu_dereference(
-    mpath->next_hop)
-                                kfree(sta)
-  access sta <-- CRASH
-
-Fix both of these by unconditionally flushing paths before destroying
-the sta, and by adding a synchronize_net() after path flush to ensure
-no active readers can still dereference the sta.
-
-Fixes this crash:
-
-[  348.529295] BUG: unable to handle kernel paging request at 00020040
-[  348.530014] IP: [<f929245d>] ieee80211_mps_set_frame_flags+0x40/0xaa [mac80211]
-[  348.530014] *pde = 00000000
-[  348.530014] Oops: 0000 [#1] PREEMPT
-[  348.530014] Modules linked in: drbg ansi_cprng ctr ccm ppp_generic slhc ipt_MASQUERADE nf_nat_masquerade_ipv4 8021q ]
-[  348.530014] CPU: 0 PID: 20597 Comm: wget Tainted: G           O 4.6.0-rc5-wt=V1 #1
-[  348.530014] Hardware name: To Be Filled By O.E.M./To be filled by O.E.M., BIOS 080016  11/07/2014
-[  348.530014] task: f64fa280 ti: f4f9c000 task.ti: f4f9c000
-[  348.530014] EIP: 0060:[<f929245d>] EFLAGS: 00010246 CPU: 0
-[  348.530014] EIP is at ieee80211_mps_set_frame_flags+0x40/0xaa [mac80211]
-[  348.530014] EAX: f4ce63e0 EBX: 00000088 ECX: f3788416 EDX: 00020008
-[  348.530014] ESI: 00000000 EDI: 00000088 EBP: f6409a4c ESP: f6409a40
-[  348.530014]  DS: 007b ES: 007b FS: 0000 GS: 0033 SS: 0068
-[  348.530014] CR0: 80050033 CR2: 00020040 CR3: 33190000 CR4: 00000690
-[  348.530014] Stack:
-[  348.530014]  00000000 f4ce63e0 f5f9bd80 f6409a64 f9291d80 0000ce67 f5d51e00 f4ce63e0
-[  348.530014]  f3788416 f6409a80 f9291dc1 f4ce8320 f4ce63e0 f5d51e00 f4ce63e0 f4ce8320
-[  348.530014]  f6409a98 f9277f6f 00000000 00000000 0000007c 00000000 f6409b2c f9278dd1
-[  348.530014] Call Trace:
-[  348.530014]  [<f9291d80>] mesh_nexthop_lookup+0xbb/0xc8 [mac80211]
-[  348.530014]  [<f9291dc1>] mesh_nexthop_resolve+0x34/0xd8 [mac80211]
-[  348.530014]  [<f9277f6f>] ieee80211_xmit+0x92/0xc1 [mac80211]
-[  348.530014]  [<f9278dd1>] __ieee80211_subif_start_xmit+0x807/0x83c [mac80211]
-[  348.530014]  [<c04df012>] ? sch_direct_xmit+0xd7/0x1b3
-[  348.530014]  [<c022a8c6>] ? __local_bh_enable_ip+0x5d/0x7b
-[  348.530014]  [<f956870c>] ? nf_nat_ipv4_out+0x4c/0xd0 [nf_nat_ipv4]
-[  348.530014]  [<f957e036>] ? iptable_nat_ipv4_fn+0xf/0xf [iptable_nat]
-[  348.530014]  [<c04c6f45>] ? netif_skb_features+0x14d/0x30a
-[  348.530014]  [<f9278e10>] ieee80211_subif_start_xmit+0xa/0xe [mac80211]
-[  348.530014]  [<c04c769c>] dev_hard_start_xmit+0x1f8/0x267
-[  348.530014]  [<c04c7261>] ?  validate_xmit_skb.isra.120.part.121+0x10/0x253
-[  348.530014]  [<c04defc6>] sch_direct_xmit+0x8b/0x1b3
-[  348.530014]  [<c04c7a9c>] __dev_queue_xmit+0x2c8/0x513
-[  348.530014]  [<c04c7cfb>] dev_queue_xmit+0xa/0xc
-[  348.530014]  [<f91bfc7a>] batadv_send_skb_packet+0xd6/0xec [batman_adv]
-[  348.530014]  [<f91bfdc4>] batadv_send_unicast_skb+0x15/0x4a [batman_adv]
-[  348.530014]  [<f91b5938>] batadv_dat_send_data+0x27e/0x310 [batman_adv]
-[  348.530014]  [<f91c30b5>] ? batadv_tt_global_hash_find.isra.11+0x8/0xa [batman_adv]
-[  348.530014]  [<f91b63f3>] batadv_dat_snoop_outgoing_arp_request+0x208/0x23d [batman_adv]
-[  348.530014]  [<f91c0cd9>] batadv_interface_tx+0x206/0x385 [batman_adv]
-[  348.530014]  [<c04c769c>] dev_hard_start_xmit+0x1f8/0x267
-[  348.530014]  [<c04c7261>] ?  validate_xmit_skb.isra.120.part.121+0x10/0x253
-[  348.530014]  [<c04defc6>] sch_direct_xmit+0x8b/0x1b3
-[  348.530014]  [<c04c7a9c>] __dev_queue_xmit+0x2c8/0x513
-[  348.530014]  [<f80cbd2a>] ? igb_xmit_frame+0x57/0x72 [igb]
-[  348.530014]  [<c04c7cfb>] dev_queue_xmit+0xa/0xc
-[  348.530014]  [<f843a326>] br_dev_queue_push_xmit+0xeb/0xfb [bridge]
-[  348.530014]  [<f843a35f>] br_forward_finish+0x29/0x74 [bridge]
-[  348.530014]  [<f843a23b>] ? deliver_clone+0x3b/0x3b [bridge]
-[  348.530014]  [<f843a714>] __br_forward+0x89/0xe7 [bridge]
-[  348.530014]  [<f843a336>] ? br_dev_queue_push_xmit+0xfb/0xfb [bridge]
-[  348.530014]  [<f843a234>] deliver_clone+0x34/0x3b [bridge]
-[  348.530014]  [<f843a68b>] ? br_flood+0x95/0x95 [bridge]
-[  348.530014]  [<f843a66d>] br_flood+0x77/0x95 [bridge]
-[  348.530014]  [<f843a809>] br_flood_forward+0x13/0x1a [bridge]
-[  348.530014]  [<f843a68b>] ? br_flood+0x95/0x95 [bridge]
-[  348.530014]  [<f843b877>] br_handle_frame_finish+0x392/0x3db [bridge]
-[  348.530014]  [<c04e9b2b>] ? nf_iterate+0x2b/0x6b
-[  348.530014]  [<f843baa6>] br_handle_frame+0x1e6/0x240 [bridge]
-[  348.530014]  [<f843b4e5>] ? br_handle_local_finish+0x6a/0x6a [bridge]
-[  348.530014]  [<c04c4ba0>] __netif_receive_skb_core+0x43a/0x66b
-[  348.530014]  [<f843b8c0>] ? br_handle_frame_finish+0x3db/0x3db [bridge]
-[  348.530014]  [<c023cea4>] ? resched_curr+0x19/0x37
-[  348.530014]  [<c0240707>] ? check_preempt_wakeup+0xbf/0xfe
-[  348.530014]  [<c0255dec>] ? ktime_get_with_offset+0x5c/0xfc
-[  348.530014]  [<c04c4fc1>] __netif_receive_skb+0x47/0x55
-[  348.530014]  [<c04c57ba>] netif_receive_skb_internal+0x40/0x5a
-[  348.530014]  [<c04c61ef>] napi_gro_receive+0x3a/0x94
-[  348.530014]  [<f80ce8d5>] igb_poll+0x6fd/0x9ad [igb]
-[  348.530014]  [<c0242bd8>] ? swake_up_locked+0x14/0x26
-[  348.530014]  [<c04c5d29>] net_rx_action+0xde/0x250
-[  348.530014]  [<c022a743>] __do_softirq+0x8a/0x163
-[  348.530014]  [<c022a6b9>] ? __hrtimer_tasklet_trampoline+0x19/0x19
-[  348.530014]  [<c021100f>] do_softirq_own_stack+0x26/0x2c
-[  348.530014]  <IRQ>
-[  348.530014]  [<c022a957>] irq_exit+0x31/0x6f
-[  348.530014]  [<c0210eb2>] do_IRQ+0x8d/0xa0
-[  348.530014]  [<c058152c>] common_interrupt+0x2c/0x40
-[  348.530014] Code: e7 8c 00 66 81 ff 88 00 75 12 85 d2 75 0e b2 c3 b8 83 e9 29 f9 e8 a7 5f f9 c6 eb 74 66 81 e3 8c 005
-[  348.530014] EIP: [<f929245d>] ieee80211_mps_set_frame_flags+0x40/0xaa [mac80211] SS:ESP 0068:f6409a40
-[  348.530014] CR2: 0000000000020040
-[  348.530014] ---[ end trace 48556ac26779732e ]---
-[  348.530014] Kernel panic - not syncing: Fatal exception in interrupt
-[  348.530014] Kernel Offset: disabled
-
-Cc: stable@vger.kernel.org
-Reported-by: Fred Veldini <fred.veldini@gmail.com>
-Tested-by: Fred Veldini <fred.veldini@gmail.com>
-Signed-off-by: Bob Copeland <me@bobcopeland.com>
----
-
---- a/net/mac80211/mesh.c
-+++ b/net/mac80211/mesh.c
-@@ -161,6 +161,10 @@ void mesh_sta_cleanup(struct sta_info *s
- 		del_timer_sync(&sta->mesh->plink_timer);
- 	}
- 
-+	/* make sure no readers can access nexthop sta from here on */
-+	mesh_path_flush_by_nexthop(sta);
-+	synchronize_net();
-+
- 	if (changed)
- 		ieee80211_mbss_info_change_notify(sdata, changed);
- }
diff --git a/package/kernel/mac80211/patches/304-mac80211-fix-fast_tx-header-alignment.patch b/package/kernel/mac80211/patches/304-mac80211-fix-fast_tx-header-alignment.patch
deleted file mode 100644
index 6316d81..0000000
--- a/package/kernel/mac80211/patches/304-mac80211-fix-fast_tx-header-alignment.patch
+++ /dev/null
@@ -1,25 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Thu, 19 May 2016 17:32:13 +0200
-Subject: [PATCH] mac80211: fix fast_tx header alignment
-
-The header field is defined as u8[] but also accessed as struct
-ieee80211_hdr. Enforce an alignment of 2 to prevent unnecessary
-unaligned accesses, which can be very harmful for performance on many
-platforms.
-
-Fixes: e495c24731a2 ("mac80211: extend fast-xmit for more ciphers")
-Cc: stable@vger.kernel.org
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/mac80211/sta_info.h
-+++ b/net/mac80211/sta_info.h
-@@ -280,7 +280,7 @@ struct ieee80211_fast_tx {
- 	u8 sa_offs, da_offs, pn_offs;
- 	u8 band;
- 	u8 hdr[30 + 2 + IEEE80211_FAST_XMIT_MAX_IV +
--	       sizeof(rfc1042_header)];
-+	       sizeof(rfc1042_header)] __aligned(2);
- 
- 	struct rcu_head rcu_head;
- };
diff --git a/package/kernel/mac80211/patches/350-0001-brcmfmac-add-fallback-for-devices-that-do-not-report.patch b/package/kernel/mac80211/patches/350-0001-brcmfmac-add-fallback-for-devices-that-do-not-report.patch
deleted file mode 100644
index 62e9e26..0000000
--- a/package/kernel/mac80211/patches/350-0001-brcmfmac-add-fallback-for-devices-that-do-not-report.patch
+++ /dev/null
@@ -1,52 +0,0 @@
-From: Jaap Jan Meijer <jjmeijer88@gmail.com>
-Date: Thu, 12 May 2016 18:25:08 +0200
-Subject: [PATCH] brcmfmac: add fallback for devices that do not report
- per-chain values
-
-If brcmf_cfg80211_get_station fails to determine the RSSI from the
-per-chain values get the value individually as a fallback.
-
-Fixes: 1f0dc59a6de9 ("brcmfmac: rework .get_station() callback")
-Signed-off-by: Jaap Jan Meijer <jjmeijer88@gmail.com>
-Acked-by: Arend van Spriel <arend.vanspriel@broadcom.com>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-@@ -2540,12 +2540,14 @@ brcmf_cfg80211_get_station(struct wiphy
- 			   const u8 *mac, struct station_info *sinfo)
- {
- 	struct brcmf_if *ifp = netdev_priv(ndev);
-+	struct brcmf_scb_val_le scb_val;
- 	s32 err = 0;
- 	struct brcmf_sta_info_le sta_info_le;
- 	u32 sta_flags;
- 	u32 is_tdls_peer;
- 	s32 total_rssi;
- 	s32 count_rssi;
-+	int rssi;
- 	u32 i;
- 
- 	brcmf_dbg(TRACE, "Enter, MAC %pM\n", mac);
-@@ -2629,6 +2631,20 @@ brcmf_cfg80211_get_station(struct wiphy
- 			sinfo->filled |= BIT(NL80211_STA_INFO_SIGNAL);
- 			total_rssi /= count_rssi;
- 			sinfo->signal = total_rssi;
-+		} else if (test_bit(BRCMF_VIF_STATUS_CONNECTED,
-+			&ifp->vif->sme_state)) {
-+			memset(&scb_val, 0, sizeof(scb_val));
-+			err = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_RSSI,
-+						     &scb_val, sizeof(scb_val));
-+			if (err) {
-+				brcmf_err("Could not get rssi (%d)\n", err);
-+				goto done;
-+			} else {
-+				rssi = le32_to_cpu(scb_val.val);
-+				sinfo->filled |= BIT(NL80211_STA_INFO_SIGNAL);
-+				sinfo->signal = rssi;
-+				brcmf_dbg(CONN, "RSSI %d dBm\n", rssi);
-+			}
- 		}
- 	}
- done:
diff --git a/package/kernel/mac80211/patches/350-0002-brcmfmac-add-eth_type_trans-back-for-PCIe-full-dongl.patch b/package/kernel/mac80211/patches/350-0002-brcmfmac-add-eth_type_trans-back-for-PCIe-full-dongl.patch
deleted file mode 100644
index db8112d..0000000
--- a/package/kernel/mac80211/patches/350-0002-brcmfmac-add-eth_type_trans-back-for-PCIe-full-dongl.patch
+++ /dev/null
@@ -1,87 +0,0 @@
-From: Franky Lin <franky.lin@broadcom.com>
-Date: Thu, 2 Jun 2016 02:00:27 -0700
-Subject: [PATCH] brcmfmac: add eth_type_trans back for PCIe full dongle
-
-A regression was introduced in commit 9c349892ccc9 ("brcmfmac: revise
-handling events in receive path") which moves eth_type_trans() call
-to brcmf_rx_frame(). Msgbuf layer doesn't use brcmf_rx_frame() but invokes
-brcmf_netif_rx() directly. In such case the Ethernet header was not
-stripped out resulting in null pointer dereference in the networking
-stack.
-
-BUG: unable to handle kernel NULL pointer dereference at 0000000000000048
-IP: [<ffffffff814c3ce6>] enqueue_to_backlog+0x56/0x260
-PGD 0
-Oops: 0000 [#1] PREEMPT SMP
-Modules linked in: fuse ipt_MASQUERADE nf_nat_masquerade_ipv4
-iptable_nat nf_conntrack_ipv4 nf_defrag_ipv4 nf_nat_ipv4 xt_addrtype
-[...]
-rtsx_pci scsi_mod usbcore usb_common i8042 serio nvme nvme_core
-CPU: 7 PID: 1340 Comm: irq/136-brcmf_p Not tainted 4.7.0-rc1-mainline #1
-Hardware name: Dell Inc. XPS 15 9550/0N7TVV, BIOS 01.02.00 04/07/2016
-task: ffff8804a0c5bd00 ti: ffff88049e124000 task.ti: ffff88049e124000
-RIP: 0010:[<ffffffff814c3ce6>] [<ffffffff814c3ce6>]
-enqueue_to_backlog+0x56/0x260
-RSP: 0018:ffff88049e127ca0 EFLAGS: 00010046
-RAX: 0000000000000000 RBX: ffff8804bddd7c40 RCX: 000000000000002f
-RDX: 0000000000000000 RSI: 0000000000000007 RDI: ffff8804bddd7d4c
-RBP: ffff88049e127ce8 R08: 0000000000000000 R09: 0000000000000000
-R10: ffff8804bddd12c0 R11: 000000000000149e R12: 0000000000017c40
-R13: ffff88049e127d08 R14: ffff8804a9bd6d00 R15: ffff8804bddd7d4c
-FS: 0000000000000000(0000) GS:ffff8804bddc0000(0000) knlGS:0000000000000000
-CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
-CR2: 0000000000000048 CR3: 0000000001806000 CR4: 00000000003406e0
-DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
-DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
-Stack:
-ffff8804bdddad00 ffff8804ad089e00 0000000000000000 0000000000000282
-0000000000000000 ffff8804a9bd6d00 ffff8804a1b27e00 ffff8804a9bd6d00
-ffff88002ee88000 ffff88049e127d28 ffffffff814c3f3b ffffffff81311fc3
-Call Trace:
-[<ffffffff814c3f3b>] netif_rx_internal+0x4b/0x170
-[<ffffffff81311fc3>] ? swiotlb_tbl_unmap_single+0xf3/0x120
-[<ffffffff814c5467>] netif_rx_ni+0x27/0xc0
-[<ffffffffa08519e9>] brcmf_netif_rx+0x49/0x70 [brcmfmac]
-[<ffffffffa08564d4>] brcmf_msgbuf_process_rx+0x2b4/0x570 [brcmfmac]
-[<ffffffff81020017>] ? __xen_set_pgd_hyper+0x57/0xd0
-[<ffffffff810d60b0>] ? irq_forced_thread_fn+0x70/0x70
-[<ffffffffa0857381>] brcmf_proto_msgbuf_rx_trigger+0x31/0xe0 [brcmfmac]
-[<ffffffffa0861e8f>] brcmf_pcie_isr_thread+0x7f/0x110 [brcmfmac]
-[<ffffffff810d60d0>] irq_thread_fn+0x20/0x50
-[<ffffffff810d63ad>] irq_thread+0x12d/0x1c0
-[<ffffffff815d07d5>] ? __schedule+0x2f5/0x7a0
-[<ffffffff810d61d0>] ? wake_threads_waitq+0x30/0x30
-[<ffffffff810d6280>] ? irq_thread_dtor+0xb0/0xb0
-[<ffffffff81098ea8>] kthread+0xd8/0xf0
-[<ffffffff815d4b7f>] ret_from_fork+0x1f/0x40
-[<ffffffff81098dd0>] ? kthread_worker_fn+0x170/0x170
-Code: 1c f5 60 9a 8e 81 9c 58 0f 1f 44 00 00 48 89 45 d0 fa 66 0f 1f
-44 00 00 4c 8d bb 0c 01 00 00 4c 89 ff e8 5e 08 11 00 49 8b 56 20 <48>
-8b 52 48 83 e2 01 74 10 8b 8b 08 01 00 00 8b 15 59 c5 42 00
-RIP [<ffffffff814c3ce6>] enqueue_to_backlog+0x56/0x260
-RSP <ffff88049e127ca0>
-CR2: 0000000000000048
-
-Fixes: 9c349892ccc9 ("brcmfmac: revise handling events in receive path")
-Reported-by: Rafal Milecki <zajec5@gmail.com>
-Reported-by: Grey Christoforo <grey@christoforo.net>
-Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
-Reviewed-by: Arend Van Spriel <arend@broadcom.com>
-Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
-Signed-off-by: Franky Lin <franky.lin@broadcom.com>
-[arend@broadcom.com: rephrased the commit message]
-Signed-off-by: Arend van Spriel <arend@broadcom.com>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c
-@@ -1157,6 +1157,8 @@ brcmf_msgbuf_process_rx_complete(struct
- 		brcmu_pkt_buf_free_skb(skb);
- 		return;
- 	}
-+
-+	skb->protocol = eth_type_trans(skb, ifp->ndev);
- 	brcmf_netif_rx(ifp, skb);
- }
- 
diff --git a/package/kernel/mac80211/patches/351-0003-brcmfmac-Fix-kernel-oops-in-failed-chip_attach.patch b/package/kernel/mac80211/patches/351-0003-brcmfmac-Fix-kernel-oops-in-failed-chip_attach.patch
deleted file mode 100644
index 59f1e42..0000000
--- a/package/kernel/mac80211/patches/351-0003-brcmfmac-Fix-kernel-oops-in-failed-chip_attach.patch
+++ /dev/null
@@ -1,88 +0,0 @@
-From: Christian Daudt <csd@broadcom.com>
-Date: Wed, 11 May 2016 15:06:48 -0700
-Subject: [PATCH] brcmfmac: Fix kernel oops in failed chip_attach
-
-When chip attach fails, brcmf_sdiod_intr_unregister is being called
-but that is too early as sdiodev->settings has not been set yet
-nor has brcmf_sdiod_intr_register been called.
-Change to use oob_irq_requested + newly created sd_irq_requested
-to decide on what to unregister at intr_unregister time.
-
-Steps to reproduce problem:
-- modprobe brcmfmac using buggy FW
-- rmmod brcmfmac
-- modprobe brcmfmac again.
-
-If done with a buggy firmware, brcm_chip_attach will fail on the
-2nd modprobe triggering the call to intr_unregister and the
-kernel oops when attempting to de-reference sdiodev->settings->bus.sdio
-which has not yet been set.
-
-Signed-off-by: Christian Daudt <csd@broadcom.com>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c
-@@ -166,6 +166,7 @@ int brcmf_sdiod_intr_register(struct brc
- 		sdio_claim_irq(sdiodev->func[1], brcmf_sdiod_ib_irqhandler);
- 		sdio_claim_irq(sdiodev->func[2], brcmf_sdiod_dummy_irqhandler);
- 		sdio_release_host(sdiodev->func[1]);
-+		sdiodev->sd_irq_requested = true;
- 	}
- 
- 	return 0;
-@@ -173,27 +174,30 @@ int brcmf_sdiod_intr_register(struct brc
- 
- int brcmf_sdiod_intr_unregister(struct brcmf_sdio_dev *sdiodev)
- {
--	struct brcmfmac_sdio_pd *pdata;
- 
--	brcmf_dbg(SDIO, "Entering\n");
-+	brcmf_dbg(SDIO, "Entering oob=%d sd=%d\n",
-+		  sdiodev->oob_irq_requested,
-+		  sdiodev->sd_irq_requested);
- 
--	pdata = &sdiodev->settings->bus.sdio;
--	if (pdata->oob_irq_supported) {
-+	if (sdiodev->oob_irq_requested) {
-+		struct brcmfmac_sdio_pd *pdata;
-+
-+		pdata = &sdiodev->settings->bus.sdio;
- 		sdio_claim_host(sdiodev->func[1]);
- 		brcmf_sdiod_regwb(sdiodev, SDIO_CCCR_BRCM_SEPINT, 0, NULL);
- 		brcmf_sdiod_regwb(sdiodev, SDIO_CCCR_IENx, 0, NULL);
- 		sdio_release_host(sdiodev->func[1]);
- 
--		if (sdiodev->oob_irq_requested) {
--			sdiodev->oob_irq_requested = false;
--			if (sdiodev->irq_wake) {
--				disable_irq_wake(pdata->oob_irq_nr);
--				sdiodev->irq_wake = false;
--			}
--			free_irq(pdata->oob_irq_nr, &sdiodev->func[1]->dev);
--			sdiodev->irq_en = false;
-+		sdiodev->oob_irq_requested = false;
-+		if (sdiodev->irq_wake) {
-+			disable_irq_wake(pdata->oob_irq_nr);
-+			sdiodev->irq_wake = false;
- 		}
--	} else {
-+		free_irq(pdata->oob_irq_nr, &sdiodev->func[1]->dev);
-+		sdiodev->irq_en = false;
-+	}
-+
-+	if (sdiodev->sd_irq_requested) {
- 		sdio_claim_host(sdiodev->func[1]);
- 		sdio_release_irq(sdiodev->func[2]);
- 		sdio_release_irq(sdiodev->func[1]);
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.h
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.h
-@@ -186,6 +186,7 @@ struct brcmf_sdio_dev {
- 	struct brcmf_bus *bus_if;
- 	struct brcmf_mp_device *settings;
- 	bool oob_irq_requested;
-+	bool sd_irq_requested;
- 	bool irq_en;			/* irq enable flags */
- 	spinlock_t irq_en_lock;
- 	bool irq_wake;			/* irq wake enable flags */
diff --git a/package/kernel/mac80211/patches/351-0004-brcmfmac-Fix-did-not-remove-int-handler-warning.patch b/package/kernel/mac80211/patches/351-0004-brcmfmac-Fix-did-not-remove-int-handler-warning.patch
deleted file mode 100644
index 17f3dbc..0000000
--- a/package/kernel/mac80211/patches/351-0004-brcmfmac-Fix-did-not-remove-int-handler-warning.patch
+++ /dev/null
@@ -1,83 +0,0 @@
-From: Christian Daudt <csd@broadcom.com>
-Date: Wed, 11 May 2016 15:06:49 -0700
-Subject: [PATCH] brcmfmac: Fix 'did not remove int handler' warning
-
-brcmf_sdiod_intr_unregister call that removes both func1 and
-func2 interrupt handlers only called when brcmf_ops_sdio_remove
-is called for func 1 (which is the 2nd call) but sdio is expecting
-it to be removed at the end of each sdio_remove call.
-This is causing 'rmmod bcmrfmac' on a 4356-sdio chip to complain
-with:
-WARNING: driver brcmfmac did not remove its interrupt handler!
-
-The modification makes calling brcmf_sdiod_intr_unregister multiple
-times harmless by clearing the variables that track if interrupt
-handlers have been installed, and then calls it on every
-brcmf_ops_sdio_remove call instead of just remove for func 1.
-
-Signed-off-by: Christian Daudt <csd@broadcom.com>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c
-@@ -172,7 +172,7 @@ int brcmf_sdiod_intr_register(struct brc
- 	return 0;
- }
- 
--int brcmf_sdiod_intr_unregister(struct brcmf_sdio_dev *sdiodev)
-+void brcmf_sdiod_intr_unregister(struct brcmf_sdio_dev *sdiodev)
- {
- 
- 	brcmf_dbg(SDIO, "Entering oob=%d sd=%d\n",
-@@ -195,6 +195,7 @@ int brcmf_sdiod_intr_unregister(struct b
- 		}
- 		free_irq(pdata->oob_irq_nr, &sdiodev->func[1]->dev);
- 		sdiodev->irq_en = false;
-+		sdiodev->oob_irq_requested = false;
- 	}
- 
- 	if (sdiodev->sd_irq_requested) {
-@@ -202,9 +203,8 @@ int brcmf_sdiod_intr_unregister(struct b
- 		sdio_release_irq(sdiodev->func[2]);
- 		sdio_release_irq(sdiodev->func[1]);
- 		sdio_release_host(sdiodev->func[1]);
-+		sdiodev->sd_irq_requested = false;
- 	}
--
--	return 0;
- }
- 
- void brcmf_sdiod_change_state(struct brcmf_sdio_dev *sdiodev,
-@@ -1201,12 +1201,17 @@ static void brcmf_ops_sdio_remove(struct
- 	brcmf_dbg(SDIO, "sdio device ID: 0x%04x\n", func->device);
- 	brcmf_dbg(SDIO, "Function: %d\n", func->num);
- 
--	if (func->num != 1)
--		return;
--
- 	bus_if = dev_get_drvdata(&func->dev);
- 	if (bus_if) {
- 		sdiodev = bus_if->bus_priv.sdio;
-+
-+		/* start by unregistering irqs */
-+		brcmf_sdiod_intr_unregister(sdiodev);
-+
-+		if (func->num != 1)
-+			return;
-+
-+		/* only proceed with rest of cleanup if func 1 */
- 		brcmf_sdiod_remove(sdiodev);
- 
- 		dev_set_drvdata(&sdiodev->func[1]->dev, NULL);
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.h
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.h
-@@ -294,7 +294,7 @@ struct sdpcmd_regs {
- 
- /* Register/deregister interrupt handler. */
- int brcmf_sdiod_intr_register(struct brcmf_sdio_dev *sdiodev);
--int brcmf_sdiod_intr_unregister(struct brcmf_sdio_dev *sdiodev);
-+void brcmf_sdiod_intr_unregister(struct brcmf_sdio_dev *sdiodev);
- 
- /* sdio device register access interface */
- u8 brcmf_sdiod_regrb(struct brcmf_sdio_dev *sdiodev, u32 addr, int *ret);
diff --git a/package/kernel/mac80211/patches/351-0005-brcmfmac-rework-function-picking-free-BSS-index.patch b/package/kernel/mac80211/patches/351-0005-brcmfmac-rework-function-picking-free-BSS-index.patch
deleted file mode 100644
index 19d6bb9..0000000
--- a/package/kernel/mac80211/patches/351-0005-brcmfmac-rework-function-picking-free-BSS-index.patch
+++ /dev/null
@@ -1,119 +0,0 @@
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
-Date: Thu, 26 May 2016 01:44:27 +0200
-Subject: [PATCH] brcmfmac: rework function picking free BSS index
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-The old implementation was overcomplicated and slightly bugged in some
-corner cases.
-
-Consider following state of BSS-es (limited to 6 for simplification):
-drvr->iflist[0]: { bsscfgidx:0, ndev->name:wlan1, }
-drvr->iflist[1]:  (null)
-drvr->iflist[2]: { bsscfgidx:2, ndev->name:wlan1-1, }
-drvr->iflist[3]: { bsscfgidx:3, ndev->name:wlan1-2, }
-drvr->iflist[4]:  (null)
-drvr->iflist[5]:  (null)
-In such case the next AP interface should bsscfgidx 4 (we don't use 1 as
-it's reserved for P2P).
-
-With old code the loop iterations were following:
-[ifidx = 0] [bsscfgidx = 2] [highest = 2]
-[ifidx = 1] [bsscfgidx = 2] [highest = 2] available = true
-[ifidx = 2] [bsscfgidx = 2] [highest = 2] bsscfgidx = highest + 1
-[ifidx = 3] [bsscfgidx = 3] [highest = 2] bsscfgidx = highest + 1
-[ifidx = 4] [bsscfgidx = 3] [highest = 2] available = true
-[ifidx = 5] [bsscfgidx = 3] [highest = 2] available = true
-There were 2 obvious problems:
-1) Having empty BSS at index 1 was resulting in available being always
-   set to true, even if we would run out of BSS-es.
-2) Calculated bsscfgidx was invalid (3 instead of 4) resulting in driver
-   not being able to create the 4th AP interface.
-
-New code is simpler, placed in file where it's really used, handles
-running out of free BSS-es and allows using 4 interfaces at the same
-time. It also looks for the first free BSS instead of one after the last
-in use. It works well with current driver (which doesn't allow deleting
-interfaces) and should be future proof (if we ever allow deleting).
-
-Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-@@ -541,6 +541,21 @@ brcmf_cfg80211_update_proto_addr_mode(st
- 						ADDR_INDIRECT);
- }
- 
-+static int brcmf_get_first_free_bsscfgidx(struct brcmf_pub *drvr)
-+{
-+	int bsscfgidx;
-+
-+	for (bsscfgidx = 0; bsscfgidx < BRCMF_MAX_IFS; bsscfgidx++) {
-+		/* bsscfgidx 1 is reserved for legacy P2P */
-+		if (bsscfgidx == 1)
-+			continue;
-+		if (!drvr->iflist[bsscfgidx])
-+			return bsscfgidx;
-+	}
-+
-+	return -ENOMEM;
-+}
-+
- static int brcmf_cfg80211_request_ap_if(struct brcmf_if *ifp)
- {
- 	struct brcmf_mbss_ssid_le mbss_ssid_le;
-@@ -548,7 +563,7 @@ static int brcmf_cfg80211_request_ap_if(
- 	int err;
- 
- 	memset(&mbss_ssid_le, 0, sizeof(mbss_ssid_le));
--	bsscfgidx = brcmf_get_next_free_bsscfgidx(ifp->drvr);
-+	bsscfgidx = brcmf_get_first_free_bsscfgidx(ifp->drvr);
- 	if (bsscfgidx < 0)
- 		return bsscfgidx;
- 
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
-@@ -753,30 +753,6 @@ void brcmf_remove_interface(struct brcmf
- 	brcmf_del_if(ifp->drvr, ifp->bsscfgidx);
- }
- 
--int brcmf_get_next_free_bsscfgidx(struct brcmf_pub *drvr)
--{
--	int ifidx;
--	int bsscfgidx;
--	bool available;
--	int highest;
--
--	available = false;
--	bsscfgidx = 2;
--	highest = 2;
--	for (ifidx = 0; ifidx < BRCMF_MAX_IFS; ifidx++) {
--		if (drvr->iflist[ifidx]) {
--			if (drvr->iflist[ifidx]->bsscfgidx == bsscfgidx)
--				bsscfgidx = highest + 1;
--			else if (drvr->iflist[ifidx]->bsscfgidx > highest)
--				highest = drvr->iflist[ifidx]->bsscfgidx;
--		} else {
--			available = true;
--		}
--	}
--
--	return available ? bsscfgidx : -ENOMEM;
--}
--
- #ifdef CONFIG_INET
- #define ARPOL_MAX_ENTRIES	8
- static int brcmf_inetaddr_changed(struct notifier_block *nb,
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.h
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.h
-@@ -217,7 +217,6 @@ int brcmf_net_attach(struct brcmf_if *if
- struct brcmf_if *brcmf_add_if(struct brcmf_pub *drvr, s32 bsscfgidx, s32 ifidx,
- 			      bool is_p2pdev, char *name, u8 *mac_addr);
- void brcmf_remove_interface(struct brcmf_if *ifp);
--int brcmf_get_next_free_bsscfgidx(struct brcmf_pub *drvr);
- void brcmf_txflowblock_if(struct brcmf_if *ifp,
- 			  enum brcmf_netif_stop_reason reason, bool state);
- void brcmf_txfinalize(struct brcmf_if *ifp, struct sk_buff *txp, bool success);
diff --git a/package/kernel/mac80211/patches/351-0006-brcmfmac-use-kmemdup.patch b/package/kernel/mac80211/patches/351-0006-brcmfmac-use-kmemdup.patch
deleted file mode 100644
index fa93265..0000000
--- a/package/kernel/mac80211/patches/351-0006-brcmfmac-use-kmemdup.patch
+++ /dev/null
@@ -1,28 +0,0 @@
-From: Muhammad Falak R Wani <falakreyaz@gmail.com>
-Date: Thu, 19 May 2016 19:29:03 +0530
-Subject: [PATCH] brcmfmac: use kmemdup
-
-Use kmemdup when some other buffer is immediately copied into allocated
-region. It replaces call to allocation followed by memcpy, by a single
-call to kmemdup.
-
-Signed-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>
-Acked-by: Arend van Spriel <arend.vanspriel@broadcom.com>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-@@ -6730,11 +6730,10 @@ struct brcmf_cfg80211_info *brcmf_cfg802
- 		return NULL;
- 	}
- 
--	ops = kzalloc(sizeof(*ops), GFP_KERNEL);
-+	ops = kmemdup(&brcmf_cfg80211_ops, sizeof(*ops), GFP_KERNEL);
- 	if (!ops)
- 		return NULL;
- 
--	memcpy(ops, &brcmf_cfg80211_ops, sizeof(*ops));
- 	ifp = netdev_priv(ndev);
- #ifdef CONFIG_PM
- 	if (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_WOWL_GTK))
diff --git a/package/kernel/mac80211/patches/351-0007-brcmutil-add-field-storing-control-channel-to-the-st.patch b/package/kernel/mac80211/patches/351-0007-brcmutil-add-field-storing-control-channel-to-the-st.patch
deleted file mode 100644
index b15da32..0000000
--- a/package/kernel/mac80211/patches/351-0007-brcmutil-add-field-storing-control-channel-to-the-st.patch
+++ /dev/null
@@ -1,244 +0,0 @@
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
-Date: Fri, 20 May 2016 13:38:57 +0200
-Subject: [PATCH] brcmutil: add field storing control channel to the struct
- brcmu_chan
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Our d11 code supports encoding/decoding channel info into/from chanspec
-format used by firmware. Current implementation is quite misleading
-because of the way "chnum" field is used.
-When encoding channel info, "chnum" has to be filled by a caller with
-*center* channel number. However when decoding chanspec the same field
-is filled with a *control* channel number.
-
-1) This can be confusing. It's expected for information to be the same
-   after encoding and decoding.
-2) It doesn't allow accessing all info when decoding. Some functions may
-   need to know both channel numbers, e.g. cfg80211 callback getting
-   current channel.
-Solve this by adding a separated field for control channel.
-
-Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
-Reviewed-by: Arend van Spriel <arend.vanspriel@broadcom.com>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-@@ -2765,7 +2765,7 @@ static s32 brcmf_inform_single_bss(struc
- 	if (!bi->ctl_ch) {
- 		ch.chspec = le16_to_cpu(bi->chanspec);
- 		cfg->d11inf.decchspec(&ch);
--		bi->ctl_ch = ch.chnum;
-+		bi->ctl_ch = ch.control_ch_num;
- 	}
- 	channel = bi->ctl_ch;
- 
-@@ -2883,7 +2883,7 @@ static s32 brcmf_inform_ibss(struct brcm
- 	else
- 		band = wiphy->bands[NL80211_BAND_5GHZ];
- 
--	freq = ieee80211_channel_to_frequency(ch.chnum, band->band);
-+	freq = ieee80211_channel_to_frequency(ch.control_ch_num, band->band);
- 	cfg->channel = freq;
- 	notify_channel = ieee80211_get_channel(wiphy, freq);
- 
-@@ -2893,7 +2893,7 @@ static s32 brcmf_inform_ibss(struct brcm
- 	notify_ielen = le32_to_cpu(bi->ie_length);
- 	notify_signal = (s16)le16_to_cpu(bi->RSSI) * 100;
- 
--	brcmf_dbg(CONN, "channel: %d(%d)\n", ch.chnum, freq);
-+	brcmf_dbg(CONN, "channel: %d(%d)\n", ch.control_ch_num, freq);
- 	brcmf_dbg(CONN, "capability: %X\n", notify_capability);
- 	brcmf_dbg(CONN, "beacon interval: %d\n", notify_interval);
- 	brcmf_dbg(CONN, "signal: %d\n", notify_signal);
-@@ -5311,7 +5311,7 @@ brcmf_bss_roaming_done(struct brcmf_cfg8
- 	else
- 		band = wiphy->bands[NL80211_BAND_5GHZ];
- 
--	freq = ieee80211_channel_to_frequency(ch.chnum, band->band);
-+	freq = ieee80211_channel_to_frequency(ch.control_ch_num, band->band);
- 	notify_channel = ieee80211_get_channel(wiphy, freq);
- 
- done:
-@@ -5833,14 +5833,15 @@ static int brcmf_construct_chaninfo(stru
- 		channel = band->channels;
- 		index = band->n_channels;
- 		for (j = 0; j < band->n_channels; j++) {
--			if (channel[j].hw_value == ch.chnum) {
-+			if (channel[j].hw_value == ch.control_ch_num) {
- 				index = j;
- 				break;
- 			}
- 		}
- 		channel[index].center_freq =
--			ieee80211_channel_to_frequency(ch.chnum, band->band);
--		channel[index].hw_value = ch.chnum;
-+			ieee80211_channel_to_frequency(ch.control_ch_num,
-+						       band->band);
-+		channel[index].hw_value = ch.control_ch_num;
- 
- 		/* assuming the chanspecs order is HT20,
- 		 * HT40 upper, HT40 lower, and VHT80.
-@@ -5942,7 +5943,7 @@ static int brcmf_enable_bw40_2g(struct b
- 			if (WARN_ON(ch.bw != BRCMU_CHAN_BW_40))
- 				continue;
- 			for (j = 0; j < band->n_channels; j++) {
--				if (band->channels[j].hw_value == ch.chnum)
-+				if (band->channels[j].hw_value == ch.control_ch_num)
- 					break;
- 			}
- 			if (WARN_ON(j == band->n_channels))
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c
-@@ -1246,7 +1246,7 @@ bool brcmf_p2p_scan_finding_common_chann
- 		if (!bi->ctl_ch) {
- 			ch.chspec = le16_to_cpu(bi->chanspec);
- 			cfg->d11inf.decchspec(&ch);
--			bi->ctl_ch = ch.chnum;
-+			bi->ctl_ch = ch.control_ch_num;
- 		}
- 		afx_hdl->peer_chan = bi->ctl_ch;
- 		brcmf_dbg(TRACE, "ACTION FRAME SCAN : Peer %pM found, channel : %d\n",
-@@ -1385,7 +1385,7 @@ int brcmf_p2p_notify_action_frame_rx(str
- 			if (test_bit(BRCMF_P2P_STATUS_FINDING_COMMON_CHANNEL,
- 				     &p2p->status) &&
- 			    (ether_addr_equal(afx_hdl->tx_dst_addr, e->addr))) {
--				afx_hdl->peer_chan = ch.chnum;
-+				afx_hdl->peer_chan = ch.control_ch_num;
- 				brcmf_dbg(INFO, "GON request: Peer found, channel=%d\n",
- 					  afx_hdl->peer_chan);
- 				complete(&afx_hdl->act_frm_scan);
-@@ -1428,7 +1428,7 @@ int brcmf_p2p_notify_action_frame_rx(str
- 	memcpy(&mgmt_frame->u, frame, mgmt_frame_len);
- 	mgmt_frame_len += offsetof(struct ieee80211_mgmt, u);
- 
--	freq = ieee80211_channel_to_frequency(ch.chnum,
-+	freq = ieee80211_channel_to_frequency(ch.control_ch_num,
- 					      ch.band == BRCMU_CHAN_BAND_2G ?
- 					      NL80211_BAND_2GHZ :
- 					      NL80211_BAND_5GHZ);
-@@ -1873,7 +1873,7 @@ s32 brcmf_p2p_notify_rx_mgmt_p2p_probere
- 
- 	if (test_bit(BRCMF_P2P_STATUS_FINDING_COMMON_CHANNEL, &p2p->status) &&
- 	    (ether_addr_equal(afx_hdl->tx_dst_addr, e->addr))) {
--		afx_hdl->peer_chan = ch.chnum;
-+		afx_hdl->peer_chan = ch.control_ch_num;
- 		brcmf_dbg(INFO, "PROBE REQUEST: Peer found, channel=%d\n",
- 			  afx_hdl->peer_chan);
- 		complete(&afx_hdl->act_frm_scan);
-@@ -1898,7 +1898,7 @@ s32 brcmf_p2p_notify_rx_mgmt_p2p_probere
- 
- 	mgmt_frame = (u8 *)(rxframe + 1);
- 	mgmt_frame_len = e->datalen - sizeof(*rxframe);
--	freq = ieee80211_channel_to_frequency(ch.chnum,
-+	freq = ieee80211_channel_to_frequency(ch.control_ch_num,
- 					      ch.band == BRCMU_CHAN_BAND_2G ?
- 					      NL80211_BAND_2GHZ :
- 					      NL80211_BAND_5GHZ);
---- a/drivers/net/wireless/broadcom/brcm80211/brcmutil/d11.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmutil/d11.c
-@@ -107,6 +107,7 @@ static void brcmu_d11n_decchspec(struct
- 	u16 val;
- 
- 	ch->chnum = (u8)(ch->chspec & BRCMU_CHSPEC_CH_MASK);
-+	ch->control_ch_num = ch->chnum;
- 
- 	switch (ch->chspec & BRCMU_CHSPEC_D11N_BW_MASK) {
- 	case BRCMU_CHSPEC_D11N_BW_20:
-@@ -118,10 +119,10 @@ static void brcmu_d11n_decchspec(struct
- 		val = ch->chspec & BRCMU_CHSPEC_D11N_SB_MASK;
- 		if (val == BRCMU_CHSPEC_D11N_SB_L) {
- 			ch->sb = BRCMU_CHAN_SB_L;
--			ch->chnum -= CH_10MHZ_APART;
-+			ch->control_ch_num -= CH_10MHZ_APART;
- 		} else {
- 			ch->sb = BRCMU_CHAN_SB_U;
--			ch->chnum += CH_10MHZ_APART;
-+			ch->control_ch_num += CH_10MHZ_APART;
- 		}
- 		break;
- 	default:
-@@ -147,6 +148,7 @@ static void brcmu_d11ac_decchspec(struct
- 	u16 val;
- 
- 	ch->chnum = (u8)(ch->chspec & BRCMU_CHSPEC_CH_MASK);
-+	ch->control_ch_num = ch->chnum;
- 
- 	switch (ch->chspec & BRCMU_CHSPEC_D11AC_BW_MASK) {
- 	case BRCMU_CHSPEC_D11AC_BW_20:
-@@ -158,10 +160,10 @@ static void brcmu_d11ac_decchspec(struct
- 		val = ch->chspec & BRCMU_CHSPEC_D11AC_SB_MASK;
- 		if (val == BRCMU_CHSPEC_D11AC_SB_L) {
- 			ch->sb = BRCMU_CHAN_SB_L;
--			ch->chnum -= CH_10MHZ_APART;
-+			ch->control_ch_num -= CH_10MHZ_APART;
- 		} else if (val == BRCMU_CHSPEC_D11AC_SB_U) {
- 			ch->sb = BRCMU_CHAN_SB_U;
--			ch->chnum += CH_10MHZ_APART;
-+			ch->control_ch_num += CH_10MHZ_APART;
- 		} else {
- 			WARN_ON_ONCE(1);
- 		}
-@@ -172,16 +174,16 @@ static void brcmu_d11ac_decchspec(struct
- 					 BRCMU_CHSPEC_D11AC_SB_SHIFT);
- 		switch (ch->sb) {
- 		case BRCMU_CHAN_SB_LL:
--			ch->chnum -= CH_30MHZ_APART;
-+			ch->control_ch_num -= CH_30MHZ_APART;
- 			break;
- 		case BRCMU_CHAN_SB_LU:
--			ch->chnum -= CH_10MHZ_APART;
-+			ch->control_ch_num -= CH_10MHZ_APART;
- 			break;
- 		case BRCMU_CHAN_SB_UL:
--			ch->chnum += CH_10MHZ_APART;
-+			ch->control_ch_num += CH_10MHZ_APART;
- 			break;
- 		case BRCMU_CHAN_SB_UU:
--			ch->chnum += CH_30MHZ_APART;
-+			ch->control_ch_num += CH_30MHZ_APART;
- 			break;
- 		default:
- 			WARN_ON_ONCE(1);
---- a/drivers/net/wireless/broadcom/brcm80211/include/brcmu_d11.h
-+++ b/drivers/net/wireless/broadcom/brcm80211/include/brcmu_d11.h
-@@ -125,14 +125,36 @@ enum brcmu_chan_sb {
- 	BRCMU_CHAN_SB_UU = BRCMU_CHAN_SB_LUU,
- };
- 
-+/**
-+ * struct brcmu_chan - stores channel formats
-+ *
-+ * This structure can be used with functions translating chanspec into generic
-+ * channel info and the other way.
-+ *
-+ * @chspec: firmware specific format
-+ * @chnum: center channel number
-+ * @control_ch_num: control channel number
-+ * @band: frequency band
-+ * @bw: channel width
-+ * @sb: control sideband (location of control channel against the center one)
-+ */
- struct brcmu_chan {
- 	u16 chspec;
- 	u8 chnum;
-+	u8 control_ch_num;
- 	u8 band;
- 	enum brcmu_chan_bw bw;
- 	enum brcmu_chan_sb sb;
- };
- 
-+/**
-+ * struct brcmu_d11inf - provides functions translating channel format
-+ *
-+ * @io_type: determines version of channel format used by firmware
-+ * @encchspec: encodes channel info into a chanspec, requires center channel
-+ *	number, ignores control one
-+ * @decchspec: decodes chanspec into generic info
-+ */
- struct brcmu_d11inf {
- 	u8 io_type;
- 
diff --git a/package/kernel/mac80211/patches/351-0008-brcmfmac-support-get_channel-cfg80211-callback.patch b/package/kernel/mac80211/patches/351-0008-brcmfmac-support-get_channel-cfg80211-callback.patch
deleted file mode 100644
index 2583c78..0000000
--- a/package/kernel/mac80211/patches/351-0008-brcmfmac-support-get_channel-cfg80211-callback.patch
+++ /dev/null
@@ -1,94 +0,0 @@
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
-Date: Fri, 20 May 2016 13:38:58 +0200
-Subject: [PATCH] brcmfmac: support get_channel cfg80211 callback
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-This is important for brcmfmac as some of released firmwares (e.g.
-brcmfmac4366b-pcie.bin) may pick different channel than requested. This
-has been tested with BCM4366B1 in D-Link DIR-885L.
-
-Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-@@ -4923,6 +4923,68 @@ exit:
- 	return err;
- }
- 
-+static int brcmf_cfg80211_get_channel(struct wiphy *wiphy,
-+				      struct wireless_dev *wdev,
-+				      struct cfg80211_chan_def *chandef)
-+{
-+	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
-+	struct net_device *ndev = wdev->netdev;
-+	struct brcmf_if *ifp;
-+	struct brcmu_chan ch;
-+	enum nl80211_band band = 0;
-+	enum nl80211_chan_width width = 0;
-+	u32 chanspec;
-+	int freq, err;
-+
-+	if (!ndev)
-+		return -ENODEV;
-+	ifp = netdev_priv(ndev);
-+
-+	err = brcmf_fil_iovar_int_get(ifp, "chanspec", &chanspec);
-+	if (err) {
-+		brcmf_err("chanspec failed (%d)\n", err);
-+		return err;
-+	}
-+
-+	ch.chspec = chanspec;
-+	cfg->d11inf.decchspec(&ch);
-+
-+	switch (ch.band) {
-+	case BRCMU_CHAN_BAND_2G:
-+		band = NL80211_BAND_2GHZ;
-+		break;
-+	case BRCMU_CHAN_BAND_5G:
-+		band = NL80211_BAND_5GHZ;
-+		break;
-+	}
-+
-+	switch (ch.bw) {
-+	case BRCMU_CHAN_BW_80:
-+		width = NL80211_CHAN_WIDTH_80;
-+		break;
-+	case BRCMU_CHAN_BW_40:
-+		width = NL80211_CHAN_WIDTH_40;
-+		break;
-+	case BRCMU_CHAN_BW_20:
-+		width = NL80211_CHAN_WIDTH_20;
-+		break;
-+	case BRCMU_CHAN_BW_80P80:
-+		width = NL80211_CHAN_WIDTH_80P80;
-+		break;
-+	case BRCMU_CHAN_BW_160:
-+		width = NL80211_CHAN_WIDTH_160;
-+		break;
-+	}
-+
-+	freq = ieee80211_channel_to_frequency(ch.control_ch_num, band);
-+	chandef->chan = ieee80211_get_channel(wiphy, freq);
-+	chandef->width = width;
-+	chandef->center_freq1 = ieee80211_channel_to_frequency(ch.chnum, band);
-+	chandef->center_freq2 = 0;
-+
-+	return 0;
-+}
-+
- static int brcmf_cfg80211_crit_proto_start(struct wiphy *wiphy,
- 					   struct wireless_dev *wdev,
- 					   enum nl80211_crit_proto_id proto,
-@@ -5085,6 +5147,7 @@ static struct cfg80211_ops brcmf_cfg8021
- 	.mgmt_tx = brcmf_cfg80211_mgmt_tx,
- 	.remain_on_channel = brcmf_p2p_remain_on_channel,
- 	.cancel_remain_on_channel = brcmf_cfg80211_cancel_remain_on_channel,
-+	.get_channel = brcmf_cfg80211_get_channel,
- 	.start_p2p_device = brcmf_p2p_start_device,
- 	.stop_p2p_device = brcmf_p2p_stop_device,
- 	.crit_proto_start = brcmf_cfg80211_crit_proto_start,
diff --git a/package/kernel/mac80211/patches/351-0009-brcmfmac-print-errors-if-creating-interface-fails.patch b/package/kernel/mac80211/patches/351-0009-brcmfmac-print-errors-if-creating-interface-fails.patch
deleted file mode 100644
index 81fbff4..0000000
--- a/package/kernel/mac80211/patches/351-0009-brcmfmac-print-errors-if-creating-interface-fails.patch
+++ /dev/null
@@ -1,59 +0,0 @@
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
-Date: Fri, 27 May 2016 10:54:28 +0200
-Subject: [PATCH] brcmfmac: print errors if creating interface fails
-
-This is helpful for debugging. Without this all I was getting from "iw"
-command on failed creating of P2P interface was:
-> command failed: Too many open files in system (-23)
-
-Signed-off-by: Rafal Milecki <zajec5@gmail.com>
-[arend@broadcom.com: reduce error prints upon iface creation]
-Signed-off-by: Arend van Spriel <arend@broadcom.com>
-Reviewed-by: Julian Calaby <julian.calaby@gmail.com>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-@@ -684,20 +684,24 @@ static struct wireless_dev *brcmf_cfg802
- 		return ERR_PTR(-EOPNOTSUPP);
- 	case NL80211_IFTYPE_AP:
- 		wdev = brcmf_ap_add_vif(wiphy, name, flags, params);
--		if (!IS_ERR(wdev))
--			brcmf_cfg80211_update_proto_addr_mode(wdev);
--		return wdev;
-+		break;
- 	case NL80211_IFTYPE_P2P_CLIENT:
- 	case NL80211_IFTYPE_P2P_GO:
- 	case NL80211_IFTYPE_P2P_DEVICE:
- 		wdev = brcmf_p2p_add_vif(wiphy, name, name_assign_type, type, flags, params);
--		if (!IS_ERR(wdev))
--			brcmf_cfg80211_update_proto_addr_mode(wdev);
--		return wdev;
-+		break;
- 	case NL80211_IFTYPE_UNSPECIFIED:
- 	default:
- 		return ERR_PTR(-EINVAL);
- 	}
-+
-+	if (IS_ERR(wdev))
-+		brcmf_err("add iface %s type %d failed: err=%d\n",
-+			  name, type, (int)PTR_ERR(wdev));
-+	else
-+		brcmf_cfg80211_update_proto_addr_mode(wdev);
-+
-+	return wdev;
- }
- 
- static void brcmf_scan_config_mpc(struct brcmf_if *ifp, int mpc)
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c
-@@ -2030,8 +2030,6 @@ static int brcmf_p2p_request_p2p_if(stru
- 
- 	err = brcmf_fil_iovar_data_set(ifp, "p2p_ifadd", &if_request,
- 				       sizeof(if_request));
--	if (err)
--		return err;
- 
- 	return err;
- }
diff --git a/package/kernel/mac80211/patches/351-0010-brcmfmac-fix-setting-AP-channel-with-new-firmwares.patch b/package/kernel/mac80211/patches/351-0010-brcmfmac-fix-setting-AP-channel-with-new-firmwares.patch
deleted file mode 100644
index 90055f2..0000000
--- a/package/kernel/mac80211/patches/351-0010-brcmfmac-fix-setting-AP-channel-with-new-firmwares.patch
+++ /dev/null
@@ -1,114 +0,0 @@
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
-Date: Fri, 27 May 2016 21:07:19 +0200
-Subject: [PATCH] brcmfmac: fix setting AP channel with new firmwares
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Firmware for new chipsets is based on a new major version of code
-internally maintained at Broadcom. E.g. brcmfmac4366b-pcie.bin (used for
-BCM4366B1) is based on 10.10.69.3309 while brcmfmac43602-pcie.ap.bin was
-based on 7.35.177.56.
-
-Currently setting AP 5 GHz channel doesn't work reliably with BCM4366B1.
-When setting e.g. 36 control channel with VHT80 (center channel 42)
-firmware may randomly pick one of:
-1) 52 control channel with 58 as center one
-2) 100 control channel with 106 as center one
-3) 116 control channel with 122 as center one
-4) 149 control channel with 155 as center one
-
-It seems new firmwares require setting AP mode (BRCMF_C_SET_AP) before
-specifying a channel. Changing an order of firmware calls fixes the
-problem. This requirement resulted in two separated "chanspec" calls,
-one in AP code path and one in P2P path.
-
-This fix was verified with BCM4366B1 and tested for regressions on
-BCM43602.
-
-Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-@@ -4458,7 +4458,7 @@ brcmf_cfg80211_start_ap(struct wiphy *wi
- 	struct brcmf_join_params join_params;
- 	enum nl80211_iftype dev_role;
- 	struct brcmf_fil_bss_enable_le bss_enable;
--	u16 chanspec;
-+	u16 chanspec = chandef_to_chanspec(&cfg->d11inf, &settings->chandef);
- 	bool mbss;
- 	int is_11d;
- 
-@@ -4534,16 +4534,8 @@ brcmf_cfg80211_start_ap(struct wiphy *wi
- 
- 	brcmf_config_ap_mgmt_ie(ifp->vif, &settings->beacon);
- 
-+	/* Parameters shared by all radio interfaces */
- 	if (!mbss) {
--		chanspec = chandef_to_chanspec(&cfg->d11inf,
--					       &settings->chandef);
--		err = brcmf_fil_iovar_int_set(ifp, "chanspec", chanspec);
--		if (err < 0) {
--			brcmf_err("Set Channel failed: chspec=%d, %d\n",
--				  chanspec, err);
--			goto exit;
--		}
--
- 		if (is_11d != ifp->vif->is_11d) {
- 			err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_REGULATORY,
- 						    is_11d);
-@@ -4591,6 +4583,8 @@ brcmf_cfg80211_start_ap(struct wiphy *wi
- 		err = -EINVAL;
- 		goto exit;
- 	}
-+
-+	/* Interface specific setup */
- 	if (dev_role == NL80211_IFTYPE_AP) {
- 		if ((brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MBSS)) && (!mbss))
- 			brcmf_fil_iovar_int_set(ifp, "mbss", 1);
-@@ -4600,6 +4594,17 @@ brcmf_cfg80211_start_ap(struct wiphy *wi
- 			brcmf_err("setting AP mode failed %d\n", err);
- 			goto exit;
- 		}
-+		if (!mbss) {
-+			/* Firmware 10.x requires setting channel after enabling
-+			 * AP and before bringing interface up.
-+			 */
-+			err = brcmf_fil_iovar_int_set(ifp, "chanspec", chanspec);
-+			if (err < 0) {
-+				brcmf_err("Set Channel failed: chspec=%d, %d\n",
-+					  chanspec, err);
-+				goto exit;
-+			}
-+		}
- 		err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_UP, 1);
- 		if (err < 0) {
- 			brcmf_err("BRCMF_C_UP error (%d)\n", err);
-@@ -4621,7 +4626,13 @@ brcmf_cfg80211_start_ap(struct wiphy *wi
- 			goto exit;
- 		}
- 		brcmf_dbg(TRACE, "AP mode configuration complete\n");
--	} else {
-+	} else if (dev_role == NL80211_IFTYPE_P2P_GO) {
-+		err = brcmf_fil_iovar_int_set(ifp, "chanspec", chanspec);
-+		if (err < 0) {
-+			brcmf_err("Set Channel failed: chspec=%d, %d\n",
-+				  chanspec, err);
-+			goto exit;
-+		}
- 		err = brcmf_fil_bsscfg_data_set(ifp, "ssid", &ssid_le,
- 						sizeof(ssid_le));
- 		if (err < 0) {
-@@ -4638,7 +4649,10 @@ brcmf_cfg80211_start_ap(struct wiphy *wi
- 		}
- 
- 		brcmf_dbg(TRACE, "GO mode configuration complete\n");
-+	} else {
-+		WARN_ON(1);
- 	}
-+
- 	set_bit(BRCMF_VIF_STATUS_AP_CREATED, &ifp->vif->sme_state);
- 	brcmf_net_setcarrier(ifp, true);
- 
diff --git a/package/kernel/mac80211/patches/351-0011-brcmfmac-don-t-remove-interface-on-link-down-firmwar.patch b/package/kernel/mac80211/patches/351-0011-brcmfmac-don-t-remove-interface-on-link-down-firmwar.patch
deleted file mode 100644
index 97fdff7..0000000
--- a/package/kernel/mac80211/patches/351-0011-brcmfmac-don-t-remove-interface-on-link-down-firmwar.patch
+++ /dev/null
@@ -1,60 +0,0 @@
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
-Date: Mon, 30 May 2016 06:40:54 +0200
-Subject: [PATCH] brcmfmac: don't remove interface on link down firmware event
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-There are two firmware events we handle similarly in brcmfmac:
-BRCMF_E_LINK and BRCMF_E_IF. The difference from firmware point of view
-is that the first one means BSS remains present in the firmware. Trying
-to (re)create it (e.g. when adding new virtual interface) will result in
-an error.
-
-Current code treats both events in a similar way. It removes Linux
-interface for each of them. It works OK with e.g. BCM43602. Its firmware
-generates both events for each interface. It means we get BRCMF_E_LINK
-and remove interface. That is soon followed by BRCMF_E_IF which means
-BSS was also removed in a firmware. The only downside of this is a
-harmless error like:
-[  208.643180] brcmfmac: brcmf_fweh_call_event_handler: no interface object
-
-Unfortunately BCM4366 firmware doesn't automatically remove BSS and so
-it doesn't generate BRCMF_E_IF. In such case we incorrectly remove Linux
-interface on BRCMF_E_LINK as BSS is still present in the firmware. It
-results in an error when trying to re-create virtual interface, e.g.:
-> iw phy phy1 interface add wlan1-1 type __ap
-[ 3602.929199] brcmfmac: brcmf_ap_add_vif: timeout occurred
-command failed: I/O error (-5)
-
-With this patch we don't remove Linux interface while firmware keeps
-BSS. Thanks to this we keep a consistent states of host driver and
-device firmware.
-
-Further improvement should be to mark BSS as disabled and remove
-interface on BRCMF_E_LINK. Then we should add support for reusing
-BSS-es.
-
-Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-@@ -5448,7 +5448,6 @@ brcmf_notify_connect_status_ap(struct br
- 			       struct net_device *ndev,
- 			       const struct brcmf_event_msg *e, void *data)
- {
--	struct brcmf_if *ifp = netdev_priv(ndev);
- 	static int generation;
- 	u32 event = e->event_code;
- 	u32 reason = e->reason;
-@@ -5459,8 +5458,6 @@ brcmf_notify_connect_status_ap(struct br
- 	    ndev != cfg_to_ndev(cfg)) {
- 		brcmf_dbg(CONN, "AP mode link down\n");
- 		complete(&cfg->vif_disabled);
--		if (ifp->vif->mbss)
--			brcmf_remove_interface(ifp);
- 		return 0;
- 	}
- 
diff --git a/package/kernel/mac80211/patches/351-0012-brcmfmac-fix-skb-priority-handling.patch b/package/kernel/mac80211/patches/351-0012-brcmfmac-fix-skb-priority-handling.patch
deleted file mode 100644
index c729d43..0000000
--- a/package/kernel/mac80211/patches/351-0012-brcmfmac-fix-skb-priority-handling.patch
+++ /dev/null
@@ -1,28 +0,0 @@
-From: Hante Meuleman <hante.meuleman@broadcom.com>
-Date: Fri, 3 Jun 2016 23:31:07 +0200
-Subject: [PATCH] brcmfmac: fix skb priority handling
-
-SKBs can come with a prioriy. Currently a priority of 0..7 is
-assumed. But this assumption is incorrect. To fix this any
-priority of 0 or higher then 7 will be adjusted by calling
-cfg80211_classify8021d
-
-Reviewed-by: Arend Van Spriel <arend@broadcom.com>
-Reviewed-by: Franky Lin <franky.lin@broadcom.com>
-Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
-Signed-off-by: Hante Meuleman <hante.meuleman@broadcom.com>
-Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.c
-@@ -2101,7 +2101,7 @@ int brcmf_fws_process_skb(struct brcmf_i
- 
- 	brcmf_dbg(DATA, "tx proto=0x%X\n", ntohs(eh->h_proto));
- 	/* determine the priority */
--	if (!skb->priority)
-+	if ((skb->priority == 0) || (skb->priority > 7))
- 		skb->priority = cfg80211_classify8021d(skb, NULL);
- 
- 	drvr->tx_multicast += !!multicast;
diff --git a/package/kernel/mac80211/patches/351-0013-brcmfmac-revise-SDIO-error-message-in-brcmf_sdio_dri.patch b/package/kernel/mac80211/patches/351-0013-brcmfmac-revise-SDIO-error-message-in-brcmf_sdio_dri.patch
deleted file mode 100644
index a2b2e43..0000000
--- a/package/kernel/mac80211/patches/351-0013-brcmfmac-revise-SDIO-error-message-in-brcmf_sdio_dri.patch
+++ /dev/null
@@ -1,27 +0,0 @@
-From: Wright Feng <wright.feng@broadcom.com>
-Date: Fri, 3 Jun 2016 23:31:08 +0200
-Subject: [PATCH] brcmfmac: revise SDIO error message in
- brcmf_sdio_drivestrengthinit
-
-The error message is given for something that is not an error here as
-the drive strength configuration may not be applicable for specific
-devices. Therefor the error message is rephrased and changed to a
-debug message.
-
-Signed-off-by: Wright Feng <wright.feng@broadcom.com>
-[arend@broadcom.com: rephrase commit message]
-Signed-off-by: Arend van Spriel <arend@broadcom.com>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
-@@ -3666,7 +3666,7 @@ brcmf_sdio_drivestrengthinit(struct brcm
- 		str_shift = 11;
- 		break;
- 	default:
--		brcmf_err("No SDIO Drive strength init done for chip %s rev %d pmurev %d\n",
-+		brcmf_dbg(INFO, "No SDIO driver strength init needed for chip %s rev %d pmurev %d\n",
- 			  ci->name, ci->chiprev, ci->pmurev);
- 		break;
- 	}
diff --git a/package/kernel/mac80211/patches/351-0014-brcmfmac-use-ndev-needed_headroom-to-reserve-additio.patch b/package/kernel/mac80211/patches/351-0014-brcmfmac-use-ndev-needed_headroom-to-reserve-additio.patch
deleted file mode 100644
index 7cfdc03..0000000
--- a/package/kernel/mac80211/patches/351-0014-brcmfmac-use-ndev-needed_headroom-to-reserve-additio.patch
+++ /dev/null
@@ -1,30 +0,0 @@
-From: Wright Feng <wright.feng@broadcom.com>
-Date: Fri, 3 Jun 2016 23:31:09 +0200
-Subject: [PATCH] brcmfmac: use ndev->needed_headroom to reserve additional
- header space
-
-When using nmap tool with FMAC, the nmap packets were be dropped by kernel
-because the size was too short. The kernel message showed like
-"nmap: packet size is too short (42 <= 50)". It is caused by the packet
-length is shorter than ndev->hard_header_len. According to definition of
-LL_RESERVED_SPACE() and hard_header_len, we should use hard_header_len
-to reserve for L2 header, like ethernet header(ETH_HLEN) in our case and
-use needed_headroom for the additional headroom needed by hardware.
-
-Reviewed-by: Arend Van Spriel <arend@broadcom.com>
-Signed-off-by: Wright Feng <wright.feng@broadcom.com>
-Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
-@@ -516,7 +516,7 @@ int brcmf_net_attach(struct brcmf_if *if
- 	/* set appropriate operations */
- 	ndev->netdev_ops = &brcmf_netdev_ops_pri;
- 
--	ndev->hard_header_len += drvr->hdrlen;
-+	ndev->needed_headroom += drvr->hdrlen;
- 	ndev->ethtool_ops = &brcmf_ethtool_ops;
- 
- 	drvr->rxsz = ndev->mtu + ndev->hard_header_len +
diff --git a/package/kernel/mac80211/patches/351-0015-brcmfmac-add-support-for-the-PCIE-devices-43525-and-.patch b/package/kernel/mac80211/patches/351-0015-brcmfmac-add-support-for-the-PCIE-devices-43525-and-.patch
deleted file mode 100644
index 66e0aaa..0000000
--- a/package/kernel/mac80211/patches/351-0015-brcmfmac-add-support-for-the-PCIE-devices-43525-and-.patch
+++ /dev/null
@@ -1,66 +0,0 @@
-From: Hante Meuleman <hante.meuleman@broadcom.com>
-Date: Fri, 3 Jun 2016 23:31:10 +0200
-Subject: [PATCH] brcmfmac: add support for the PCIE devices 43525 and 43465
-
-This patch adds support for the new PCIE devices 43525 and 43465.
-
-Reviewed-by: Arend Van Spriel <arend@broadcom.com>
-Reviewed-by: Franky (Zhenhui) Lin <franky.lin@broadcom.com>
-Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
-Signed-off-by: Hante Meuleman <hante.meuleman@broadcom.com>
-Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c
-@@ -685,6 +685,8 @@ static u32 brcmf_chip_tcm_rambase(struct
- 	case BRCM_CC_43602_CHIP_ID:
- 	case BRCM_CC_4371_CHIP_ID:
- 		return 0x180000;
-+	case BRCM_CC_43465_CHIP_ID:
-+	case BRCM_CC_43525_CHIP_ID:
- 	case BRCM_CC_4365_CHIP_ID:
- 	case BRCM_CC_4366_CHIP_ID:
- 		return 0x200000;
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
-@@ -54,21 +54,25 @@ BRCMF_FW_NVRAM_DEF(43570, "brcmfmac43570
- BRCMF_FW_NVRAM_DEF(4358, "brcmfmac4358-pcie.bin", "brcmfmac4358-pcie.txt");
- BRCMF_FW_NVRAM_DEF(4359, "brcmfmac4359-pcie.bin", "brcmfmac4359-pcie.txt");
- BRCMF_FW_NVRAM_DEF(4365B, "brcmfmac4365b-pcie.bin", "brcmfmac4365b-pcie.txt");
-+BRCMF_FW_NVRAM_DEF(4365C, "brcmfmac4365c-pcie.bin", "brcmfmac4365c-pcie.txt");
- BRCMF_FW_NVRAM_DEF(4366B, "brcmfmac4366b-pcie.bin", "brcmfmac4366b-pcie.txt");
- BRCMF_FW_NVRAM_DEF(4366C, "brcmfmac4366c-pcie.bin", "brcmfmac4366c-pcie.txt");
- BRCMF_FW_NVRAM_DEF(4371, "brcmfmac4371-pcie.bin", "brcmfmac4371-pcie.txt");
- 
- static struct brcmf_firmware_mapping brcmf_pcie_fwnames[] = {
- 	BRCMF_FW_NVRAM_ENTRY(BRCM_CC_43602_CHIP_ID, 0xFFFFFFFF, 43602),
-+	BRCMF_FW_NVRAM_ENTRY(BRCM_CC_43465_CHIP_ID, 0xFFFFFFF0, 4366C),
- 	BRCMF_FW_NVRAM_ENTRY(BRCM_CC_4350_CHIP_ID, 0x000000FF, 4350C),
- 	BRCMF_FW_NVRAM_ENTRY(BRCM_CC_4350_CHIP_ID, 0xFFFFFF00, 4350),
-+	BRCMF_FW_NVRAM_ENTRY(BRCM_CC_43525_CHIP_ID, 0xFFFFFFF0, 4365C),
- 	BRCMF_FW_NVRAM_ENTRY(BRCM_CC_4356_CHIP_ID, 0xFFFFFFFF, 4356),
- 	BRCMF_FW_NVRAM_ENTRY(BRCM_CC_43567_CHIP_ID, 0xFFFFFFFF, 43570),
- 	BRCMF_FW_NVRAM_ENTRY(BRCM_CC_43569_CHIP_ID, 0xFFFFFFFF, 43570),
- 	BRCMF_FW_NVRAM_ENTRY(BRCM_CC_43570_CHIP_ID, 0xFFFFFFFF, 43570),
- 	BRCMF_FW_NVRAM_ENTRY(BRCM_CC_4358_CHIP_ID, 0xFFFFFFFF, 4358),
- 	BRCMF_FW_NVRAM_ENTRY(BRCM_CC_4359_CHIP_ID, 0xFFFFFFFF, 4359),
--	BRCMF_FW_NVRAM_ENTRY(BRCM_CC_4365_CHIP_ID, 0xFFFFFFFF, 4365B),
-+	BRCMF_FW_NVRAM_ENTRY(BRCM_CC_4365_CHIP_ID, 0x0000000F, 4365B),
-+	BRCMF_FW_NVRAM_ENTRY(BRCM_CC_4365_CHIP_ID, 0xFFFFFFF0, 4365C),
- 	BRCMF_FW_NVRAM_ENTRY(BRCM_CC_4366_CHIP_ID, 0x0000000F, 4366B),
- 	BRCMF_FW_NVRAM_ENTRY(BRCM_CC_4366_CHIP_ID, 0xFFFFFFF0, 4366C),
- 	BRCMF_FW_NVRAM_ENTRY(BRCM_CC_4371_CHIP_ID, 0xFFFFFFFF, 4371),
---- a/drivers/net/wireless/broadcom/brcm80211/include/brcm_hw_ids.h
-+++ b/drivers/net/wireless/broadcom/brcm80211/include/brcm_hw_ids.h
-@@ -40,7 +40,9 @@
- #define BRCM_CC_4339_CHIP_ID		0x4339
- #define BRCM_CC_43430_CHIP_ID		43430
- #define BRCM_CC_4345_CHIP_ID		0x4345
-+#define BRCM_CC_43465_CHIP_ID		43465
- #define BRCM_CC_4350_CHIP_ID		0x4350
-+#define BRCM_CC_43525_CHIP_ID		43525
- #define BRCM_CC_4354_CHIP_ID		0x4354
- #define BRCM_CC_4356_CHIP_ID		0x4356
- #define BRCM_CC_43566_CHIP_ID		43566
diff --git a/package/kernel/mac80211/patches/351-0016-brcmfmac-change-rx_seq-check-log-from-error-print-to.patch b/package/kernel/mac80211/patches/351-0016-brcmfmac-change-rx_seq-check-log-from-error-print-to.patch
deleted file mode 100644
index b26f4b9..0000000
--- a/package/kernel/mac80211/patches/351-0016-brcmfmac-change-rx_seq-check-log-from-error-print-to.patch
+++ /dev/null
@@ -1,30 +0,0 @@
-From: Wright Feng <wright.feng@broadcom.com>
-Date: Fri, 3 Jun 2016 23:31:11 +0200
-Subject: [PATCH] brcmfmac: change rx_seq check log from error print to debug
- print
-
-The bus rx sequence is not in order because that control and event
-frames always cause immediate send, but data frames may be held
-for glomming in firmware side. It is not actually an error as the
-packets are still processed even if the RX sequence is not in order.
-Therefor the error message is rephrased and changed to a debug
-message.
-
-Reviewed-by: Arend Van Spriel <arend@broadcom.com>
-Signed-off-by: Wright Feng <wright.feng@broadcom.com>
-Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
-@@ -1384,8 +1384,7 @@ static int brcmf_sdio_hdparse(struct brc
- 		return -ENXIO;
- 	}
- 	if (rd->seq_num != rx_seq) {
--		brcmf_err("seq %d: sequence number error, expect %d\n",
--			  rx_seq, rd->seq_num);
-+		brcmf_dbg(SDIO, "seq %d, expected %d\n", rx_seq, rd->seq_num);
- 		bus->sdcnt.rx_badseq++;
- 		rd->seq_num = rx_seq;
- 	}
diff --git a/package/kernel/mac80211/patches/351-0017-brcmfmac-drop-unused-pm_block-vif-attribute.patch b/package/kernel/mac80211/patches/351-0017-brcmfmac-drop-unused-pm_block-vif-attribute.patch
deleted file mode 100644
index 9a86507..0000000
--- a/package/kernel/mac80211/patches/351-0017-brcmfmac-drop-unused-pm_block-vif-attribute.patch
+++ /dev/null
@@ -1,103 +0,0 @@
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
-Date: Mon, 6 Jun 2016 23:03:55 +0200
-Subject: [PATCH] brcmfmac: drop unused pm_block vif attribute
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-This attribute was added 3 years ago by
-commit 3eacf866559c ("brcmfmac: introduce brcmf_cfg80211_vif structure")
-but it remains unused since then. It seems we can safely drop it.
-
-Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-@@ -601,7 +601,7 @@ struct wireless_dev *brcmf_ap_add_vif(st
- 
- 	brcmf_dbg(INFO, "Adding vif \"%s\"\n", name);
- 
--	vif = brcmf_alloc_vif(cfg, NL80211_IFTYPE_AP, false);
-+	vif = brcmf_alloc_vif(cfg, NL80211_IFTYPE_AP);
- 	if (IS_ERR(vif))
- 		return (struct wireless_dev *)vif;
- 
-@@ -5174,8 +5174,7 @@ static struct cfg80211_ops brcmf_cfg8021
- };
- 
- struct brcmf_cfg80211_vif *brcmf_alloc_vif(struct brcmf_cfg80211_info *cfg,
--					   enum nl80211_iftype type,
--					   bool pm_block)
-+					   enum nl80211_iftype type)
- {
- 	struct brcmf_cfg80211_vif *vif_walk;
- 	struct brcmf_cfg80211_vif *vif;
-@@ -5190,8 +5189,6 @@ struct brcmf_cfg80211_vif *brcmf_alloc_v
- 	vif->wdev.wiphy = cfg->wiphy;
- 	vif->wdev.iftype = type;
- 
--	vif->pm_block = pm_block;
--
- 	brcmf_init_prof(&vif->profile);
- 
- 	if (type == NL80211_IFTYPE_AP) {
-@@ -6833,7 +6830,7 @@ struct brcmf_cfg80211_info *brcmf_cfg802
- 	init_vif_event(&cfg->vif_event);
- 	INIT_LIST_HEAD(&cfg->vif_list);
- 
--	vif = brcmf_alloc_vif(cfg, NL80211_IFTYPE_STATION, false);
-+	vif = brcmf_alloc_vif(cfg, NL80211_IFTYPE_STATION);
- 	if (IS_ERR(vif))
- 		goto wiphy_out;
- 
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.h
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.h
-@@ -167,7 +167,6 @@ struct vif_saved_ie {
-  * @wdev: wireless device.
-  * @profile: profile information.
-  * @sme_state: SME state using enum brcmf_vif_status bits.
-- * @pm_block: power-management blocked.
-  * @list: linked list.
-  * @mgmt_rx_reg: registered rx mgmt frame types.
-  * @mbss: Multiple BSS type, set if not first AP (not relevant for P2P).
-@@ -177,7 +176,6 @@ struct brcmf_cfg80211_vif {
- 	struct wireless_dev wdev;
- 	struct brcmf_cfg80211_profile profile;
- 	unsigned long sme_state;
--	bool pm_block;
- 	struct vif_saved_ie saved_ie;
- 	struct list_head list;
- 	u16 mgmt_rx_reg;
-@@ -388,8 +386,7 @@ s32 brcmf_cfg80211_down(struct net_devic
- enum nl80211_iftype brcmf_cfg80211_get_iftype(struct brcmf_if *ifp);
- 
- struct brcmf_cfg80211_vif *brcmf_alloc_vif(struct brcmf_cfg80211_info *cfg,
--					   enum nl80211_iftype type,
--					   bool pm_block);
-+					   enum nl80211_iftype type);
- void brcmf_free_vif(struct brcmf_cfg80211_vif *vif);
- 
- s32 brcmf_vif_set_mgmt_ie(struct brcmf_cfg80211_vif *vif, s32 pktflag,
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c
-@@ -2074,8 +2074,7 @@ static struct wireless_dev *brcmf_p2p_cr
- 	if (p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif)
- 		return ERR_PTR(-ENOSPC);
- 
--	p2p_vif = brcmf_alloc_vif(p2p->cfg, NL80211_IFTYPE_P2P_DEVICE,
--				  false);
-+	p2p_vif = brcmf_alloc_vif(p2p->cfg, NL80211_IFTYPE_P2P_DEVICE);
- 	if (IS_ERR(p2p_vif)) {
- 		brcmf_err("could not create discovery vif\n");
- 		return (struct wireless_dev *)p2p_vif;
-@@ -2175,7 +2174,7 @@ struct wireless_dev *brcmf_p2p_add_vif(s
- 		return ERR_PTR(-EOPNOTSUPP);
- 	}
- 
--	vif = brcmf_alloc_vif(cfg, type, false);
-+	vif = brcmf_alloc_vif(cfg, type);
- 	if (IS_ERR(vif))
- 		return (struct wireless_dev *)vif;
- 	brcmf_cfg80211_arm_vif_event(cfg, vif);
diff --git a/package/kernel/mac80211/patches/351-0018-brcmfmac-include-required-headers-in-cfg80211.h.patch b/package/kernel/mac80211/patches/351-0018-brcmfmac-include-required-headers-in-cfg80211.h.patch
deleted file mode 100644
index bfcab29..0000000
--- a/package/kernel/mac80211/patches/351-0018-brcmfmac-include-required-headers-in-cfg80211.h.patch
+++ /dev/null
@@ -1,37 +0,0 @@
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
-Date: Tue, 7 Jun 2016 08:20:21 +0200
-Subject: [PATCH] brcmfmac: include required headers in cfg80211.h
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Without this including cfg80211.h in a wrong order could result in:
-
-drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.h:122:24: error: array type has incomplete element type
-  struct brcmf_wsec_key key[BRCMF_MAX_DEFAULT_KEYS];
-                        ^
-drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.h:291:24: error: field ‘p2p’ has incomplete type
-  struct brcmf_p2p_info p2p;
-                        ^
-drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.h:297:27: error: field ‘pmk_list’ has incomplete type
-  struct brcmf_pmk_list_le pmk_list;
-                           ^
-drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.h:317:28: error: field ‘assoclist’ has incomplete type
-  struct brcmf_assoclist_le assoclist;
-
-Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.h
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.h
-@@ -20,6 +20,9 @@
- /* for brcmu_d11inf */
- #include <brcmu_d11.h>
- 
-+#include "fwil_types.h"
-+#include "p2p.h"
-+
- #define WL_NUM_SCAN_MAX			10
- #define WL_TLV_INFO_MAX			1024
- #define WL_BSS_INFO_MAX			2048
diff --git a/package/kernel/mac80211/patches/351-0019-brcmfmac-slightly-simplify-building-interface-combin.patch b/package/kernel/mac80211/patches/351-0019-brcmfmac-slightly-simplify-building-interface-combin.patch
deleted file mode 100644
index d946ecc..0000000
--- a/package/kernel/mac80211/patches/351-0019-brcmfmac-slightly-simplify-building-interface-combin.patch
+++ /dev/null
@@ -1,108 +0,0 @@
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
-Date: Tue, 7 Jun 2016 21:10:18 +0200
-Subject: [PATCH] brcmfmac: slightly simplify building interface combinations
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-This change reorders some operations in brcmf_setup_ifmodes in hope to
-make it simpler:
-1) It allocates arrays right before filling them. This way it's easier
-   to follow requested array length as it's immediately followed by
-   code filling it. It's easier to check e.g. why we need 4 entries for
-   P2P. Other than that it deduplicates some checks (e.g. for P2P).
-2) It reorders code to first prepare limits and then define a new combo.
-   Previously this was mixed (e.g. we were setting num of channels
-   before preparing limits).
-3) It modifies mbss code to use i variable just like other combos do.
-
-Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
-Acked-by: Arend van Spriel <arend.vanspriel@broadcom.com>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-@@ -6284,29 +6284,15 @@ static int brcmf_setup_ifmodes(struct wi
- 	if (!combo)
- 		goto err;
- 
--	c0_limits = kcalloc(p2p ? 3 : 2, sizeof(*c0_limits), GFP_KERNEL);
--	if (!c0_limits)
--		goto err;
--
--	if (p2p) {
--		p2p_limits = kcalloc(4, sizeof(*p2p_limits), GFP_KERNEL);
--		if (!p2p_limits)
--			goto err;
--	}
--
--	if (mbss) {
--		mbss_limits = kcalloc(1, sizeof(*mbss_limits), GFP_KERNEL);
--		if (!mbss_limits)
--			goto err;
--	}
--
- 	wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |
- 				 BIT(NL80211_IFTYPE_ADHOC) |
- 				 BIT(NL80211_IFTYPE_AP);
- 
- 	c = 0;
- 	i = 0;
--	combo[c].num_different_channels = 1;
-+	c0_limits = kcalloc(p2p ? 3 : 2, sizeof(*c0_limits), GFP_KERNEL);
-+	if (!c0_limits)
-+		goto err;
- 	c0_limits[i].max = 1;
- 	c0_limits[i++].types = BIT(NL80211_IFTYPE_STATION);
- 	if (p2p) {
-@@ -6324,6 +6310,7 @@ static int brcmf_setup_ifmodes(struct wi
- 		c0_limits[i].max = 1;
- 		c0_limits[i++].types = BIT(NL80211_IFTYPE_AP);
- 	}
-+	combo[c].num_different_channels = 1;
- 	combo[c].max_interfaces = i;
- 	combo[c].n_limits = i;
- 	combo[c].limits = c0_limits;
-@@ -6331,7 +6318,9 @@ static int brcmf_setup_ifmodes(struct wi
- 	if (p2p) {
- 		c++;
- 		i = 0;
--		combo[c].num_different_channels = 1;
-+		p2p_limits = kcalloc(4, sizeof(*p2p_limits), GFP_KERNEL);
-+		if (!p2p_limits)
-+			goto err;
- 		p2p_limits[i].max = 1;
- 		p2p_limits[i++].types = BIT(NL80211_IFTYPE_STATION);
- 		p2p_limits[i].max = 1;
-@@ -6340,6 +6329,7 @@ static int brcmf_setup_ifmodes(struct wi
- 		p2p_limits[i++].types = BIT(NL80211_IFTYPE_P2P_CLIENT);
- 		p2p_limits[i].max = 1;
- 		p2p_limits[i++].types = BIT(NL80211_IFTYPE_P2P_DEVICE);
-+		combo[c].num_different_channels = 1;
- 		combo[c].max_interfaces = i;
- 		combo[c].n_limits = i;
- 		combo[c].limits = p2p_limits;
-@@ -6347,14 +6337,19 @@ static int brcmf_setup_ifmodes(struct wi
- 
- 	if (mbss) {
- 		c++;
-+		i = 0;
-+		mbss_limits = kcalloc(1, sizeof(*mbss_limits), GFP_KERNEL);
-+		if (!mbss_limits)
-+			goto err;
-+		mbss_limits[i].max = 4;
-+		mbss_limits[i++].types = BIT(NL80211_IFTYPE_AP);
- 		combo[c].beacon_int_infra_match = true;
- 		combo[c].num_different_channels = 1;
--		mbss_limits[0].max = 4;
--		mbss_limits[0].types = BIT(NL80211_IFTYPE_AP);
- 		combo[c].max_interfaces = 4;
--		combo[c].n_limits = 1;
-+		combo[c].n_limits = i;
- 		combo[c].limits = mbss_limits;
- 	}
-+
- 	wiphy->n_iface_combinations = n_combos;
- 	wiphy->iface_combinations = combo;
- 	return 0;
diff --git a/package/kernel/mac80211/patches/351-0020-brcmfmac-fix-lockup-when-removing-P2P-interface-afte.patch b/package/kernel/mac80211/patches/351-0020-brcmfmac-fix-lockup-when-removing-P2P-interface-afte.patch
deleted file mode 100644
index 894dbd8..0000000
--- a/package/kernel/mac80211/patches/351-0020-brcmfmac-fix-lockup-when-removing-P2P-interface-afte.patch
+++ /dev/null
@@ -1,154 +0,0 @@
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
-Date: Fri, 17 Jun 2016 12:29:21 +0200
-Subject: [PATCH] brcmfmac: fix lockup when removing P2P interface after event
- timeout
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Removing P2P interface is handled by sending a proper request to the
-firmware. On success firmware triggers an event and driver's handler
-removes a matching interface.
-
-However on event timeout we remove interface directly from the cfg80211
-callback. Current code doesn't handle this case correctly as it always
-assumes rtnl to be unlocked.
-
-Fix it by adding an extra rtnl_locked parameter to functions and calling
-unregister_netdevice when needed.
-
-Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
-@@ -548,12 +548,16 @@ fail:
- 	return -EBADE;
- }
- 
--static void brcmf_net_detach(struct net_device *ndev)
-+static void brcmf_net_detach(struct net_device *ndev, bool rtnl_locked)
- {
--	if (ndev->reg_state == NETREG_REGISTERED)
--		unregister_netdev(ndev);
--	else
-+	if (ndev->reg_state == NETREG_REGISTERED) {
-+		if (rtnl_locked)
-+			unregister_netdevice(ndev);
-+		else
-+			unregister_netdev(ndev);
-+	} else {
- 		brcmf_cfg80211_free_netdev(ndev);
-+	}
- }
- 
- void brcmf_net_setcarrier(struct brcmf_if *ifp, bool on)
-@@ -651,7 +655,7 @@ struct brcmf_if *brcmf_add_if(struct brc
- 			brcmf_err("ERROR: netdev:%s already exists\n",
- 				  ifp->ndev->name);
- 			netif_stop_queue(ifp->ndev);
--			brcmf_net_detach(ifp->ndev);
-+			brcmf_net_detach(ifp->ndev, false);
- 			drvr->iflist[bsscfgidx] = NULL;
- 		} else {
- 			brcmf_dbg(INFO, "netdev:%s ignore IF event\n",
-@@ -699,7 +703,8 @@ struct brcmf_if *brcmf_add_if(struct brc
- 	return ifp;
- }
- 
--static void brcmf_del_if(struct brcmf_pub *drvr, s32 bsscfgidx)
-+static void brcmf_del_if(struct brcmf_pub *drvr, s32 bsscfgidx,
-+			 bool rtnl_locked)
- {
- 	struct brcmf_if *ifp;
- 
-@@ -729,7 +734,7 @@ static void brcmf_del_if(struct brcmf_pu
- 			cancel_work_sync(&ifp->multicast_work);
- 			cancel_work_sync(&ifp->ndoffload_work);
- 		}
--		brcmf_net_detach(ifp->ndev);
-+		brcmf_net_detach(ifp->ndev, rtnl_locked);
- 	} else {
- 		/* Only p2p device interfaces which get dynamically created
- 		 * end up here. In this case the p2p module should be informed
-@@ -743,14 +748,14 @@ static void brcmf_del_if(struct brcmf_pu
- 	}
- }
- 
--void brcmf_remove_interface(struct brcmf_if *ifp)
-+void brcmf_remove_interface(struct brcmf_if *ifp, bool rtnl_locked)
- {
- 	if (!ifp || WARN_ON(ifp->drvr->iflist[ifp->bsscfgidx] != ifp))
- 		return;
- 	brcmf_dbg(TRACE, "Enter, bsscfgidx=%d, ifidx=%d\n", ifp->bsscfgidx,
- 		  ifp->ifidx);
- 	brcmf_fws_del_interface(ifp);
--	brcmf_del_if(ifp->drvr, ifp->bsscfgidx);
-+	brcmf_del_if(ifp->drvr, ifp->bsscfgidx, rtnl_locked);
- }
- 
- #ifdef CONFIG_INET
-@@ -1057,9 +1062,9 @@ fail:
- 		brcmf_fws_deinit(drvr);
- 	}
- 	if (ifp)
--		brcmf_net_detach(ifp->ndev);
-+		brcmf_net_detach(ifp->ndev, false);
- 	if (p2p_ifp)
--		brcmf_net_detach(p2p_ifp->ndev);
-+		brcmf_net_detach(p2p_ifp->ndev, false);
- 	drvr->iflist[0] = NULL;
- 	drvr->iflist[1] = NULL;
- 	if (drvr->settings->ignore_probe_fail)
-@@ -1128,7 +1133,7 @@ void brcmf_detach(struct device *dev)
- 
- 	/* make sure primary interface removed last */
- 	for (i = BRCMF_MAX_IFS-1; i > -1; i--)
--		brcmf_remove_interface(drvr->iflist[i]);
-+		brcmf_remove_interface(drvr->iflist[i], false);
- 
- 	brcmf_cfg80211_detach(drvr->config);
- 
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.h
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.h
-@@ -216,7 +216,7 @@ struct brcmf_if *brcmf_get_ifp(struct br
- int brcmf_net_attach(struct brcmf_if *ifp, bool rtnl_locked);
- struct brcmf_if *brcmf_add_if(struct brcmf_pub *drvr, s32 bsscfgidx, s32 ifidx,
- 			      bool is_p2pdev, char *name, u8 *mac_addr);
--void brcmf_remove_interface(struct brcmf_if *ifp);
-+void brcmf_remove_interface(struct brcmf_if *ifp, bool rtnl_locked);
- void brcmf_txflowblock_if(struct brcmf_if *ifp,
- 			  enum brcmf_netif_stop_reason reason, bool state);
- void brcmf_txfinalize(struct brcmf_if *ifp, struct sk_buff *txp, bool success);
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.c
-@@ -183,7 +183,7 @@ static void brcmf_fweh_handle_if_event(s
- 	err = brcmf_fweh_call_event_handler(ifp, emsg->event_code, emsg, data);
- 
- 	if (ifp && ifevent->action == BRCMF_E_IF_DEL)
--		brcmf_remove_interface(ifp);
-+		brcmf_remove_interface(ifp, false);
- }
- 
- /**
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c
-@@ -2289,7 +2289,7 @@ int brcmf_p2p_del_vif(struct wiphy *wiph
- 			err = 0;
- 	}
- 	if (err)
--		brcmf_remove_interface(vif->ifp);
-+		brcmf_remove_interface(vif->ifp, true);
- 
- 	brcmf_cfg80211_arm_vif_event(cfg, NULL);
- 	if (vif->wdev.iftype != NL80211_IFTYPE_P2P_DEVICE)
-@@ -2395,7 +2395,7 @@ void brcmf_p2p_detach(struct brcmf_p2p_i
- 	if (vif != NULL) {
- 		brcmf_p2p_cancel_remain_on_channel(vif->ifp);
- 		brcmf_p2p_deinit_discovery(p2p);
--		brcmf_remove_interface(vif->ifp);
-+		brcmf_remove_interface(vif->ifp, false);
- 	}
- 	/* just set it all to zero */
- 	memset(p2p, 0, sizeof(*p2p));
diff --git a/package/kernel/mac80211/patches/351-0021-brcmfmac-use-const-char-for-interface-name-in-brcmf_.patch b/package/kernel/mac80211/patches/351-0021-brcmfmac-use-const-char-for-interface-name-in-brcmf_.patch
deleted file mode 100644
index 24f06c4..0000000
--- a/package/kernel/mac80211/patches/351-0021-brcmfmac-use-const-char-for-interface-name-in-brcmf_.patch
+++ /dev/null
@@ -1,39 +0,0 @@
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
-Date: Fri, 17 Jun 2016 12:48:44 +0200
-Subject: [PATCH] brcmfmac: use const char * for interface name in brcmf_add_if
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-This function can work just fine with const pointer, it only calls
-alloc_netdev which take const as well. Moreover it makes this function
-more flexible as some cfg80211 callback may provide const char * as
-well, e.g. add_virtual_intf. This will be needed for more advanced
-interface management.
-
-Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
-@@ -638,7 +638,7 @@ fail:
- }
- 
- struct brcmf_if *brcmf_add_if(struct brcmf_pub *drvr, s32 bsscfgidx, s32 ifidx,
--			      bool is_p2pdev, char *name, u8 *mac_addr)
-+			      bool is_p2pdev, const char *name, u8 *mac_addr)
- {
- 	struct brcmf_if *ifp;
- 	struct net_device *ndev;
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.h
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.h
-@@ -215,7 +215,7 @@ char *brcmf_ifname(struct brcmf_if *ifp)
- struct brcmf_if *brcmf_get_ifp(struct brcmf_pub *drvr, int ifidx);
- int brcmf_net_attach(struct brcmf_if *ifp, bool rtnl_locked);
- struct brcmf_if *brcmf_add_if(struct brcmf_pub *drvr, s32 bsscfgidx, s32 ifidx,
--			      bool is_p2pdev, char *name, u8 *mac_addr);
-+			      bool is_p2pdev, const char *name, u8 *mac_addr);
- void brcmf_remove_interface(struct brcmf_if *ifp, bool rtnl_locked);
- void brcmf_txflowblock_if(struct brcmf_if *ifp,
- 			  enum brcmf_netif_stop_reason reason, bool state);
diff --git a/package/kernel/mac80211/patches/351-0022-brcmfmac-include-also-core.h-header-in-cfg80211.h.patch b/package/kernel/mac80211/patches/351-0022-brcmfmac-include-also-core.h-header-in-cfg80211.h.patch
deleted file mode 100644
index eeda766..0000000
--- a/package/kernel/mac80211/patches/351-0022-brcmfmac-include-also-core.h-header-in-cfg80211.h.patch
+++ /dev/null
@@ -1,33 +0,0 @@
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
-Date: Sat, 18 Jun 2016 18:49:38 +0200
-Subject: [PATCH] brcmfmac: include also core.h header in cfg80211.h
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-This header provides two inline functions using struct brcmf_if so we
-need core.h to avoid:
-
-drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.h: In function ‘ndev_to_prof’:
-drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.h:368:13: error: dereferencing pointer to incomplete type
-  return &ifp->vif->profile;
-             ^
-drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.h: In function ‘ndev_to_vif’:
-drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.h:374:12: error: dereferencing pointer to incomplete type
-  return ifp->vif;
-            ^
-
-Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.h
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.h
-@@ -20,6 +20,7 @@
- /* for brcmu_d11inf */
- #include <brcmu_d11.h>
- 
-+#include "core.h"
- #include "fwil_types.h"
- #include "p2p.h"
- 
diff --git a/package/kernel/mac80211/patches/351-0023-brcmfmac-add-missing-break-when-deleting-P2P_DEVICE.patch b/package/kernel/mac80211/patches/351-0023-brcmfmac-add-missing-break-when-deleting-P2P_DEVICE.patch
deleted file mode 100644
index 3819248..0000000
--- a/package/kernel/mac80211/patches/351-0023-brcmfmac-add-missing-break-when-deleting-P2P_DEVICE.patch
+++ /dev/null
@@ -1,27 +0,0 @@
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
-Date: Sun, 19 Jun 2016 01:55:57 +0200
-Subject: [PATCH] brcmfmac: add missing break when deleting P2P_DEVICE
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-We obviously don't want to fall through in that switch. With this change
-1) We wait for event (triggered by p2p_disc) as expected
-2) We remove interface manually on timeout
-3) We return 0 on success instead of -ENOTSUPP
-
-Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c
-@@ -2263,6 +2263,8 @@ int brcmf_p2p_del_vif(struct wiphy *wiph
- 			return 0;
- 		brcmf_p2p_cancel_remain_on_channel(vif->ifp);
- 		brcmf_p2p_deinit_discovery(p2p);
-+		break;
-+
- 	default:
- 		return -ENOTSUPP;
- 	}
diff --git a/package/kernel/mac80211/patches/352-0001-brcmfmac-delete-interface-directly-in-code-that-sent.patch b/package/kernel/mac80211/patches/352-0001-brcmfmac-delete-interface-directly-in-code-that-sent.patch
deleted file mode 100644
index 12d7eb4..0000000
--- a/package/kernel/mac80211/patches/352-0001-brcmfmac-delete-interface-directly-in-code-that-sent.patch
+++ /dev/null
@@ -1,75 +0,0 @@
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
-Date: Wed, 29 Jun 2016 21:54:26 +0200
-Subject: [PATCH] brcmfmac: delete interface directly in code that sent fw
- request
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-So far when receiving event about in-firmware-interface removal our
-event worker was notifying listener and afterwards it was removing Linux
-interface.
-
-First of all it was resulting in slightly unexpected order. The listener
-(del_virtual_intf callback) was (usually) returning with success before
-we even called unregister_netdev(ice).
-
-Please note this couldn't be simply fixed by changing order of calls in
-brcmf_fweh_handle_if_event as unregistering interface earlier could free
-struct brcmf_if.
-
-Another problem of current implementation are possible lockups. Focus on
-the time slot between calling event handler and removing Linux
-interface. During that time original caller may leave (unlocking rtnl
-semaphore) *and* another call to the same code may be done (locking it
-again). If that happens our event handler will stuck at removing Linux
-interface, it won't handle another event and will block process holding
-rtnl lock.
-
-This can be simply solved by unregistering interface in a proper
-callback, right after receiving confirmation event from firmware. This
-only required modifying worker to don't unregister on its own if there
-is someone waiting for the event.
-
-Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.c
-@@ -18,6 +18,7 @@
- #include "brcmu_wifi.h"
- #include "brcmu_utils.h"
- 
-+#include "cfg80211.h"
- #include "core.h"
- #include "debug.h"
- #include "tracepoint.h"
-@@ -182,8 +183,13 @@ static void brcmf_fweh_handle_if_event(s
- 
- 	err = brcmf_fweh_call_event_handler(ifp, emsg->event_code, emsg, data);
- 
--	if (ifp && ifevent->action == BRCMF_E_IF_DEL)
--		brcmf_remove_interface(ifp, false);
-+	if (ifp && ifevent->action == BRCMF_E_IF_DEL) {
-+		bool armed = brcmf_cfg80211_vif_event_armed(drvr->config);
-+
-+		/* Default handling in case no-one waits for this event */
-+		if (!armed)
-+			brcmf_remove_interface(ifp, false);
-+	}
- }
- 
- /**
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c
-@@ -2290,8 +2290,7 @@ int brcmf_p2p_del_vif(struct wiphy *wiph
- 		else
- 			err = 0;
- 	}
--	if (err)
--		brcmf_remove_interface(vif->ifp, true);
-+	brcmf_remove_interface(vif->ifp, true);
- 
- 	brcmf_cfg80211_arm_vif_event(cfg, NULL);
- 	if (vif->wdev.iftype != NL80211_IFTYPE_P2P_DEVICE)
diff --git a/package/kernel/mac80211/patches/352-0002-brcmfmac-support-removing-AP-interfaces-with-interfa.patch b/package/kernel/mac80211/patches/352-0002-brcmfmac-support-removing-AP-interfaces-with-interfa.patch
deleted file mode 100644
index 2f7165e..0000000
--- a/package/kernel/mac80211/patches/352-0002-brcmfmac-support-removing-AP-interfaces-with-interfa.patch
+++ /dev/null
@@ -1,84 +0,0 @@
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
-Date: Wed, 29 Jun 2016 21:54:27 +0200
-Subject: [PATCH] brcmfmac: support removing AP interfaces with
- "interface_remove"
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-New firmwares (e.g. 10.10.69.36 for BCM4366) support "interface_remove"
-for removing interfaces. Try to use this method on cfg80211 request. In
-case of older firmwares (e.g. 7.35.177.56 for BCM43602 as I tested) this
-will just result in firmware rejecting command and this won't change any
-behavior.
-
-Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-@@ -785,12 +785,48 @@ s32 brcmf_notify_escan_complete(struct b
- 	return err;
- }
- 
-+static int brcmf_cfg80211_del_ap_iface(struct wiphy *wiphy,
-+				       struct wireless_dev *wdev)
-+{
-+	struct brcmf_cfg80211_info *cfg = wiphy_priv(wiphy);
-+	struct net_device *ndev = wdev->netdev;
-+	struct brcmf_if *ifp = netdev_priv(ndev);
-+	int ret;
-+	int err;
-+
-+	brcmf_cfg80211_arm_vif_event(cfg, ifp->vif);
-+
-+	err = brcmf_fil_bsscfg_data_set(ifp, "interface_remove", NULL, 0);
-+	if (err) {
-+		brcmf_err("interface_remove failed %d\n", err);
-+		goto err_unarm;
-+	}
-+
-+	/* wait for firmware event */
-+	ret = brcmf_cfg80211_wait_vif_event(cfg, BRCMF_E_IF_DEL,
-+					    BRCMF_VIF_EVENT_TIMEOUT);
-+	if (!ret) {
-+		brcmf_err("timeout occurred\n");
-+		err = -EIO;
-+		goto err_unarm;
-+	}
-+
-+	brcmf_remove_interface(ifp, true);
-+
-+err_unarm:
-+	brcmf_cfg80211_arm_vif_event(cfg, NULL);
-+	return err;
-+}
-+
- static
- int brcmf_cfg80211_del_iface(struct wiphy *wiphy, struct wireless_dev *wdev)
- {
- 	struct brcmf_cfg80211_info *cfg = wiphy_priv(wiphy);
- 	struct net_device *ndev = wdev->netdev;
- 
-+	if (ndev && ndev == cfg_to_ndev(cfg))
-+		return -ENOTSUPP;
-+
- 	/* vif event pending in firmware */
- 	if (brcmf_cfg80211_vif_event_armed(cfg))
- 		return -EBUSY;
-@@ -807,12 +843,13 @@ int brcmf_cfg80211_del_iface(struct wiph
- 	switch (wdev->iftype) {
- 	case NL80211_IFTYPE_ADHOC:
- 	case NL80211_IFTYPE_STATION:
--	case NL80211_IFTYPE_AP:
- 	case NL80211_IFTYPE_AP_VLAN:
- 	case NL80211_IFTYPE_WDS:
- 	case NL80211_IFTYPE_MONITOR:
- 	case NL80211_IFTYPE_MESH_POINT:
- 		return -EOPNOTSUPP;
-+	case NL80211_IFTYPE_AP:
-+		return brcmf_cfg80211_del_ap_iface(wiphy, wdev);
- 	case NL80211_IFTYPE_P2P_CLIENT:
- 	case NL80211_IFTYPE_P2P_GO:
- 	case NL80211_IFTYPE_P2P_DEVICE:
diff --git a/package/kernel/mac80211/patches/400-ath_move_debug_code.patch b/package/kernel/mac80211/patches/400-ath_move_debug_code.patch
deleted file mode 100644
index 72e9a41..0000000
--- a/package/kernel/mac80211/patches/400-ath_move_debug_code.patch
+++ /dev/null
@@ -1,30 +0,0 @@
---- a/drivers/net/wireless/ath/Makefile
-+++ b/drivers/net/wireless/ath/Makefile
-@@ -13,10 +13,10 @@ ath-objs :=	main.o \
- 		regd.o \
- 		hw.o \
- 		key.o \
-+		debug.o \
- 		dfs_pattern_detector.o \
- 		dfs_pri_detector.o
- 
--ath-$(CPTCFG_ATH_DEBUG) += debug.o
- ath-$(CPTCFG_ATH_TRACEPOINTS) += trace.o
- 
- ccflags-y += -D__CHECK_ENDIAN__
---- a/drivers/net/wireless/ath/ath.h
-+++ b/drivers/net/wireless/ath/ath.h
-@@ -318,13 +318,6 @@ void _ath_dbg(struct ath_common *common,
- #endif /* CPTCFG_ATH_DEBUG */
- 
- /** Returns string describing opmode, or NULL if unknown mode. */
--#ifdef CPTCFG_ATH_DEBUG
- const char *ath_opmode_to_string(enum nl80211_iftype opmode);
--#else
--static inline const char *ath_opmode_to_string(enum nl80211_iftype opmode)
--{
--	return "UNKNOWN";
--}
--#endif
- 
- #endif /* ATH_H */
diff --git a/package/kernel/mac80211/patches/401-ath9k_blink_default.patch b/package/kernel/mac80211/patches/401-ath9k_blink_default.patch
deleted file mode 100644
index 4a997f1..0000000
--- a/package/kernel/mac80211/patches/401-ath9k_blink_default.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/init.c
-+++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -45,7 +45,7 @@ int ath9k_modparam_nohwcrypt;
- module_param_named(nohwcrypt, ath9k_modparam_nohwcrypt, int, 0444);
- MODULE_PARM_DESC(nohwcrypt, "Disable hardware encryption");
- 
--int ath9k_led_blink;
-+int ath9k_led_blink = 1;
- module_param_named(blink, ath9k_led_blink, int, 0444);
- MODULE_PARM_DESC(blink, "Enable LED blink on activity");
- 
diff --git a/package/kernel/mac80211/patches/402-ath_regd_optional.patch b/package/kernel/mac80211/patches/402-ath_regd_optional.patch
deleted file mode 100644
index 4634283..0000000
--- a/package/kernel/mac80211/patches/402-ath_regd_optional.patch
+++ /dev/null
@@ -1,69 +0,0 @@
---- a/drivers/net/wireless/ath/regd.c
-+++ b/drivers/net/wireless/ath/regd.c
-@@ -341,6 +341,10 @@ ath_reg_apply_beaconing_flags(struct wip
- 	struct ieee80211_channel *ch;
- 	unsigned int i;
- 
-+#ifdef CPTCFG_ATH_USER_REGD
-+	return;
-+#endif
-+
- 	for (band = 0; band < NUM_NL80211_BANDS; band++) {
- 		if (!wiphy->bands[band])
- 			continue;
-@@ -374,6 +378,10 @@ ath_reg_apply_ir_flags(struct wiphy *wip
- {
- 	struct ieee80211_supported_band *sband;
- 
-+#ifdef CPTCFG_ATH_USER_REGD
-+	return;
-+#endif
-+
- 	sband = wiphy->bands[NL80211_BAND_2GHZ];
- 	if (!sband)
- 		return;
-@@ -402,6 +410,10 @@ static void ath_reg_apply_radar_flags(st
- 	struct ieee80211_channel *ch;
- 	unsigned int i;
- 
-+#ifdef CPTCFG_ATH_USER_REGD
-+	return;
-+#endif
-+
- 	if (!wiphy->bands[NL80211_BAND_5GHZ])
- 		return;
- 
-@@ -633,6 +645,11 @@ ath_regd_init_wiphy(struct ath_regulator
- 	const struct ieee80211_regdomain *regd;
- 
- 	wiphy->reg_notifier = reg_notifier;
-+
-+#ifdef CPTCFG_ATH_USER_REGD
-+	return 0;
-+#endif
-+
- 	wiphy->regulatory_flags |= REGULATORY_STRICT_REG |
- 				   REGULATORY_CUSTOM_REG;
- 
---- a/drivers/net/wireless/ath/Kconfig
-+++ b/drivers/net/wireless/ath/Kconfig
-@@ -23,6 +23,9 @@ config WLAN_VENDOR_ATH
- 
- if WLAN_VENDOR_ATH
- 
-+config ATH_USER_REGD
-+	bool "Do not enforce EEPROM regulatory restrictions"
-+
- config ATH_DEBUG
- 	bool "Atheros wireless debugging"
- 	---help---
---- a/.local-symbols
-+++ b/.local-symbols
-@@ -127,6 +127,7 @@ ADM8211=
- ATH_COMMON=
- WLAN_VENDOR_ATH=
- ATH_DEBUG=
-+ATH_USER_REGD=
- ATH_TRACEPOINTS=
- ATH_REG_DYNAMIC_USER_REG_HINTS=
- ATH_REG_DYNAMIC_USER_CERT_TESTING=
diff --git a/package/kernel/mac80211/patches/403-world_regd_fixup.patch b/package/kernel/mac80211/patches/403-world_regd_fixup.patch
deleted file mode 100644
index 2b04309..0000000
--- a/package/kernel/mac80211/patches/403-world_regd_fixup.patch
+++ /dev/null
@@ -1,84 +0,0 @@
---- a/drivers/net/wireless/ath/regd.c
-+++ b/drivers/net/wireless/ath/regd.c
-@@ -43,7 +43,8 @@ static int __ath_regd_init(struct ath_re
- 					 NL80211_RRF_NO_OFDM)
- 
- /* We allow IBSS on these on a case by case basis by regulatory domain */
--#define ATH9K_5GHZ_5150_5350	REG_RULE(5150-10, 5350+10, 80, 0, 30,\
-+#define ATH9K_5GHZ_5150_5350	REG_RULE(5150-10, 5240+10, 80, 0, 30, 0),\
-+				REG_RULE(5260-10, 5350+10, 80, 0, 30,\
- 					 NL80211_RRF_NO_IR)
- #define ATH9K_5GHZ_5470_5850	REG_RULE(5470-10, 5850+10, 80, 0, 30,\
- 					 NL80211_RRF_NO_IR)
-@@ -61,57 +62,56 @@ static int __ath_regd_init(struct ath_re
- #define ATH9K_5GHZ_NO_MIDBAND	ATH9K_5GHZ_5150_5350, \
- 				ATH9K_5GHZ_5725_5850
- 
-+#define REGD_RULES(...) \
-+	.reg_rules = { __VA_ARGS__ }, \
-+	.n_reg_rules = ARRAY_SIZE(((struct ieee80211_reg_rule[]) { __VA_ARGS__ }))
-+
- /* Can be used for:
-  * 0x60, 0x61, 0x62 */
- static const struct ieee80211_regdomain ath_world_regdom_60_61_62 = {
--	.n_reg_rules = 5,
- 	.alpha2 =  "99",
--	.reg_rules = {
-+	REGD_RULES(
- 		ATH9K_2GHZ_ALL,
- 		ATH9K_5GHZ_ALL,
--	}
-+	)
- };
- 
- /* Can be used by 0x63 and 0x65 */
- static const struct ieee80211_regdomain ath_world_regdom_63_65 = {
--	.n_reg_rules = 4,
- 	.alpha2 =  "99",
--	.reg_rules = {
-+	REGD_RULES(
- 		ATH9K_2GHZ_CH01_11,
- 		ATH9K_2GHZ_CH12_13,
- 		ATH9K_5GHZ_NO_MIDBAND,
--	}
-+	)
- };
- 
- /* Can be used by 0x64 only */
- static const struct ieee80211_regdomain ath_world_regdom_64 = {
--	.n_reg_rules = 3,
- 	.alpha2 =  "99",
--	.reg_rules = {
-+	REGD_RULES(
- 		ATH9K_2GHZ_CH01_11,
- 		ATH9K_5GHZ_NO_MIDBAND,
--	}
-+	)
- };
- 
- /* Can be used by 0x66 and 0x69 */
- static const struct ieee80211_regdomain ath_world_regdom_66_69 = {
--	.n_reg_rules = 3,
- 	.alpha2 =  "99",
--	.reg_rules = {
-+	REGD_RULES(
- 		ATH9K_2GHZ_CH01_11,
- 		ATH9K_5GHZ_ALL,
--	}
-+	)
- };
- 
- /* Can be used by 0x67, 0x68, 0x6A and 0x6C */
- static const struct ieee80211_regdomain ath_world_regdom_67_68_6A_6C = {
--	.n_reg_rules = 4,
- 	.alpha2 =  "99",
--	.reg_rules = {
-+	REGD_RULES(
- 		ATH9K_2GHZ_CH01_11,
- 		ATH9K_2GHZ_CH12_13,
- 		ATH9K_5GHZ_ALL,
--	}
-+	)
- };
- 
- static bool dynamic_country_user_possible(struct ath_regulatory *reg)
diff --git a/package/kernel/mac80211/patches/404-regd_no_assoc_hints.patch b/package/kernel/mac80211/patches/404-regd_no_assoc_hints.patch
deleted file mode 100644
index 1ef5545..0000000
--- a/package/kernel/mac80211/patches/404-regd_no_assoc_hints.patch
+++ /dev/null
@@ -1,19 +0,0 @@
---- a/net/wireless/reg.c
-+++ b/net/wireless/reg.c
-@@ -2411,6 +2411,8 @@ void regulatory_hint_country_ie(struct w
- 	enum environment_cap env = ENVIRON_ANY;
- 	struct regulatory_request *request = NULL, *lr;
- 
-+	return;
-+
- 	/* IE len must be evenly divisible by 2 */
- 	if (country_ie_len & 0x01)
- 		return;
-@@ -2617,6 +2619,7 @@ static void restore_regulatory_settings(
- 
- void regulatory_hint_disconnect(void)
- {
-+	return;
- 	pr_debug("All devices are disconnected, going to restore regulatory settings\n");
- 	restore_regulatory_settings(false);
- }
diff --git a/package/kernel/mac80211/patches/405-ath_regd_us.patch b/package/kernel/mac80211/patches/405-ath_regd_us.patch
deleted file mode 100644
index cc55877..0000000
--- a/package/kernel/mac80211/patches/405-ath_regd_us.patch
+++ /dev/null
@@ -1,26 +0,0 @@
---- a/drivers/net/wireless/ath/regd_common.h
-+++ b/drivers/net/wireless/ath/regd_common.h
-@@ -32,6 +32,7 @@ enum EnumRd {
- 	FCC2_WORLD = 0x21,
- 	FCC2_ETSIC = 0x22,
- 	FCC6_WORLD = 0x23,
-+	FCC3_FCCA_2 = 0x2A,
- 	FRANCE_RES = 0x31,
- 	FCC3_FCCA = 0x3A,
- 	FCC3_WORLD = 0x3B,
-@@ -167,6 +168,7 @@ static struct reg_dmn_pair_mapping regDo
- 	{FCC2_WORLD, CTL_FCC, CTL_ETSI},
- 	{FCC2_ETSIC, CTL_FCC, CTL_ETSI},
- 	{FCC3_FCCA, CTL_FCC, CTL_FCC},
-+	{FCC3_FCCA_2, CTL_FCC, CTL_FCC},
- 	{FCC3_WORLD, CTL_FCC, CTL_ETSI},
- 	{FCC4_FCCA, CTL_FCC, CTL_FCC},
- 	{FCC5_FCCA, CTL_FCC, CTL_FCC},
-@@ -463,6 +465,7 @@ static struct country_code_to_enum_rd al
- 	{CTRY_UAE, NULL1_WORLD, "AE"},
- 	{CTRY_UNITED_KINGDOM, ETSI1_WORLD, "GB"},
- 	{CTRY_UNITED_STATES, FCC3_FCCA, "US"},
-+	{CTRY_UNITED_STATES, FCC3_FCCA_2, "US"},
- 	/* This "PS" is for US public safety actually... to support this we
- 	 * would need to assign new special alpha2 to CRDA db as with the world
- 	 * regdomain and use another alpha2 */
diff --git a/package/kernel/mac80211/patches/406-ath_relax_default_regd.patch b/package/kernel/mac80211/patches/406-ath_relax_default_regd.patch
deleted file mode 100644
index 6336f1f..0000000
--- a/package/kernel/mac80211/patches/406-ath_relax_default_regd.patch
+++ /dev/null
@@ -1,47 +0,0 @@
---- a/drivers/net/wireless/ath/regd.c
-+++ b/drivers/net/wireless/ath/regd.c
-@@ -114,10 +114,22 @@ static const struct ieee80211_regdomain
- 	)
- };
- 
-+static u16 ath_regd_get_eepromRD(struct ath_regulatory *reg)
-+{
-+	return reg->current_rd & ~WORLDWIDE_ROAMING_FLAG;
-+}
-+
-+static bool is_default_regd(struct ath_regulatory *reg)
-+{
-+	return ath_regd_get_eepromRD(reg) == CTRY_DEFAULT;
-+}
-+
- static bool dynamic_country_user_possible(struct ath_regulatory *reg)
- {
- 	if (config_enabled(CPTCFG_ATH_REG_DYNAMIC_USER_CERT_TESTING))
- 		return true;
-+	if (is_default_regd(reg))
-+		return true;
- 
- 	switch (reg->country_code) {
- 	case CTRY_UNITED_STATES:
-@@ -202,11 +214,6 @@ static inline bool is_wwr_sku(u16 regd)
- 		(regd == WORLD));
- }
- 
--static u16 ath_regd_get_eepromRD(struct ath_regulatory *reg)
--{
--	return reg->current_rd & ~WORLDWIDE_ROAMING_FLAG;
--}
--
- bool ath_is_world_regd(struct ath_regulatory *reg)
- {
- 	return is_wwr_sku(ath_regd_get_eepromRD(reg));
-@@ -650,6 +657,9 @@ ath_regd_init_wiphy(struct ath_regulator
- 	return 0;
- #endif
- 
-+	if (is_default_regd(reg))
-+		return 0;
-+
- 	wiphy->regulatory_flags |= REGULATORY_STRICT_REG |
- 				   REGULATORY_CUSTOM_REG;
- 
diff --git a/package/kernel/mac80211/patches/410-ath9k_allow_adhoc_and_ap.patch b/package/kernel/mac80211/patches/410-ath9k_allow_adhoc_and_ap.patch
deleted file mode 100644
index 819e64f..0000000
--- a/package/kernel/mac80211/patches/410-ath9k_allow_adhoc_and_ap.patch
+++ /dev/null
@@ -1,10 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/init.c
-+++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -728,6 +728,7 @@ static const struct ieee80211_iface_limi
- 				 BIT(NL80211_IFTYPE_AP) },
- 	{ .max = 1,	.types = BIT(NL80211_IFTYPE_P2P_CLIENT) |
- 				 BIT(NL80211_IFTYPE_P2P_GO) },
-+	{ .max = 1,	.types = BIT(NL80211_IFTYPE_ADHOC) },
- };
- 
- static const struct ieee80211_iface_limit wds_limits[] = {
diff --git a/package/kernel/mac80211/patches/411-ath5k_allow_adhoc_and_ap.patch b/package/kernel/mac80211/patches/411-ath5k_allow_adhoc_and_ap.patch
deleted file mode 100644
index 2a5ab3d..0000000
--- a/package/kernel/mac80211/patches/411-ath5k_allow_adhoc_and_ap.patch
+++ /dev/null
@@ -1,46 +0,0 @@
---- a/drivers/net/wireless/ath/ath5k/mac80211-ops.c
-+++ b/drivers/net/wireless/ath/ath5k/mac80211-ops.c
-@@ -86,13 +86,8 @@ ath5k_add_interface(struct ieee80211_hw
- 		goto end;
- 	}
- 
--	/* Don't allow other interfaces if one ad-hoc is configured.
--	 * TODO: Fix the problems with ad-hoc and multiple other interfaces.
--	 * We would need to operate the HW in ad-hoc mode to allow TSF updates
--	 * for the IBSS, but this breaks with additional AP or STA interfaces
--	 * at the moment. */
--	if (ah->num_adhoc_vifs ||
--	    (ah->nvifs && vif->type == NL80211_IFTYPE_ADHOC)) {
-+	/* Don't allow more than one ad-hoc interface */
-+	if (ah->num_adhoc_vifs && vif->type == NL80211_IFTYPE_ADHOC) {
- 		ATH5K_ERR(ah, "Only one single ad-hoc interface is allowed.\n");
- 		ret = -ELNRNG;
- 		goto end;
---- a/drivers/net/wireless/ath/ath5k/base.c
-+++ b/drivers/net/wireless/ath/ath5k/base.c
-@@ -1965,7 +1965,7 @@ ath5k_beacon_send(struct ath5k_hw *ah)
- 	}
- 
- 	if ((ah->opmode == NL80211_IFTYPE_AP && ah->num_ap_vifs +
--			ah->num_mesh_vifs > 1) ||
-+			ah->num_adhoc_vifs + ah->num_mesh_vifs > 1) ||
- 			ah->opmode == NL80211_IFTYPE_MESH_POINT) {
- 		u64 tsf = ath5k_hw_get_tsf64(ah);
- 		u32 tsftu = TSF_TO_TU(tsf);
-@@ -2051,7 +2051,7 @@ ath5k_beacon_update_timers(struct ath5k_
- 
- 	intval = ah->bintval & AR5K_BEACON_PERIOD;
- 	if (ah->opmode == NL80211_IFTYPE_AP && ah->num_ap_vifs
--		+ ah->num_mesh_vifs > 1) {
-+		+ ah->num_adhoc_vifs + ah->num_mesh_vifs > 1) {
- 		intval /= ATH_BCBUF;	/* staggered multi-bss beacons */
- 		if (intval < 15)
- 			ATH5K_WARN(ah, "intval %u is too low, min 15\n",
-@@ -2518,6 +2518,7 @@ static const struct ieee80211_iface_limi
- 				 BIT(NL80211_IFTYPE_MESH_POINT) |
- #endif
- 				 BIT(NL80211_IFTYPE_AP) },
-+	{ .max = 1,	.types = BIT(NL80211_IFTYPE_ADHOC) },
- };
- 
- static const struct ieee80211_iface_combination if_comb = {
diff --git a/package/kernel/mac80211/patches/420-ath5k_disable_fast_cc.patch b/package/kernel/mac80211/patches/420-ath5k_disable_fast_cc.patch
deleted file mode 100644
index 414f495..0000000
--- a/package/kernel/mac80211/patches/420-ath5k_disable_fast_cc.patch
+++ /dev/null
@@ -1,18 +0,0 @@
---- a/drivers/net/wireless/ath/ath5k/reset.c
-+++ b/drivers/net/wireless/ath/ath5k/reset.c
-@@ -1154,6 +1154,7 @@ ath5k_hw_reset(struct ath5k_hw *ah, enum
- 	tsf_lo = 0;
- 	mode = 0;
- 
-+#if 0
- 	/*
- 	 * Sanity check for fast flag
- 	 * Fast channel change only available
-@@ -1161,6 +1162,7 @@ ath5k_hw_reset(struct ath5k_hw *ah, enum
- 	 */
- 	if (fast && (ah->ah_radio != AR5K_RF2413) &&
- 	(ah->ah_radio != AR5K_RF5413))
-+#endif
- 		fast = false;
- 
- 	/* Disable sleep clock operation
diff --git a/package/kernel/mac80211/patches/430-add_ath5k_platform.patch b/package/kernel/mac80211/patches/430-add_ath5k_platform.patch
deleted file mode 100644
index b213e2a..0000000
--- a/package/kernel/mac80211/patches/430-add_ath5k_platform.patch
+++ /dev/null
@@ -1,33 +0,0 @@
---- /dev/null
-+++ b/include/linux/ath5k_platform.h
-@@ -0,0 +1,30 @@
-+/*
-+ * Copyright (c) 2008 Atheros Communications Inc.
-+ * Copyright (c) 2009 Gabor Juhos <juhosg@openwrt.org>
-+ * Copyright (c) 2009 Imre Kaloz <kaloz@openwrt.org>
-+ * Copyright (c) 2010 Daniel Golle <daniel.golle@gmail.com>
-+ *
-+ * Permission to use, copy, modify, and/or distribute this software for any
-+ * purpose with or without fee is hereby granted, provided that the above
-+ * copyright notice and this permission notice appear in all copies.
-+ *
-+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
-+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
-+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
-+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
-+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
-+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
-+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-+ */
-+
-+#ifndef _LINUX_ATH5K_PLATFORM_H
-+#define _LINUX_ATH5K_PLATFORM_H
-+
-+#define ATH5K_PLAT_EEP_MAX_WORDS	2048
-+
-+struct ath5k_platform_data {
-+	u16 *eeprom_data;
-+	u8 *macaddr;
-+};
-+
-+#endif /* _LINUX_ATH5K_PLATFORM_H */
diff --git a/package/kernel/mac80211/patches/431-add_platform_eeprom_support_to_ath5k.patch b/package/kernel/mac80211/patches/431-add_platform_eeprom_support_to_ath5k.patch
deleted file mode 100644
index cdc9315..0000000
--- a/package/kernel/mac80211/patches/431-add_platform_eeprom_support_to_ath5k.patch
+++ /dev/null
@@ -1,56 +0,0 @@
---- a/drivers/net/wireless/ath/ath5k/pci.c
-+++ b/drivers/net/wireless/ath/ath5k/pci.c
-@@ -21,6 +21,7 @@
- #include <linux/pci-aspm.h>
- #include <linux/etherdevice.h>
- #include <linux/module.h>
-+#include <linux/ath5k_platform.h>
- #include "../ath.h"
- #include "ath5k.h"
- #include "debug.h"
-@@ -72,7 +73,7 @@ static void ath5k_pci_read_cachesize(str
- }
- 
- /*
-- * Read from eeprom
-+ * Read from eeprom or platform_data
-  */
- static bool
- ath5k_pci_eeprom_read(struct ath_common *common, u32 offset, u16 *data)
-@@ -80,6 +81,19 @@ ath5k_pci_eeprom_read(struct ath_common
- 	struct ath5k_hw *ah = (struct ath5k_hw *) common->ah;
- 	u32 status, timeout;
- 
-+	struct ath5k_platform_data *pdata = NULL;
-+
-+	if (ah->pdev)
-+		pdata = ah->pdev->dev.platform_data;
-+
-+	if (pdata && pdata->eeprom_data && pdata->eeprom_data[61] == AR5K_EEPROM_MAGIC_VALUE) {
-+		if (offset >= ATH5K_PLAT_EEP_MAX_WORDS)
-+			return false;
-+
-+		*data = pdata->eeprom_data[offset];
-+		return true;
-+	}
-+
- 	/*
- 	 * Initialize EEPROM access
- 	 */
-@@ -123,6 +137,16 @@ static int ath5k_pci_eeprom_read_mac(str
- 	u16 data;
- 	int octet;
- 
-+	struct ath5k_platform_data *pdata = NULL;
-+
-+	if (ah->pdev)
-+		pdata = ah->pdev->dev.platform_data;
-+
-+	if (pdata && pdata->macaddr) {
-+		memcpy(mac, pdata->macaddr, ETH_ALEN);
-+		return 0;
-+	}
-+
- 	AR5K_EEPROM_READ(0x20, data);
- 
- 	for (offset = 0x1f, octet = 0, total = 0; offset >= 0x1d; offset--) {
diff --git a/package/kernel/mac80211/patches/432-ath5k_add_pciids.patch b/package/kernel/mac80211/patches/432-ath5k_add_pciids.patch
deleted file mode 100644
index d82f800..0000000
--- a/package/kernel/mac80211/patches/432-ath5k_add_pciids.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/drivers/net/wireless/ath/ath5k/pci.c
-+++ b/drivers/net/wireless/ath/ath5k/pci.c
-@@ -48,6 +48,8 @@ static const struct pci_device_id ath5k_
- 	{ PCI_VDEVICE(ATHEROS, 0x001b) }, /* 5413 Eagle */
- 	{ PCI_VDEVICE(ATHEROS, 0x001c) }, /* PCI-E cards */
- 	{ PCI_VDEVICE(ATHEROS, 0x001d) }, /* 2417 Nala */
-+	{ PCI_VDEVICE(ATHEROS, 0xff16) }, /* 2413,2414 sx76x on lantiq_danube */
-+	{ PCI_VDEVICE(ATHEROS, 0xff1a) }, /* 2417 arv45xx on lantiq_danube */
- 	{ PCI_VDEVICE(ATHEROS, 0xff1b) }, /* AR5BXB63 */
- 	{ 0 }
- };
diff --git a/package/kernel/mac80211/patches/440-ath5k_channel_bw_debugfs.patch b/package/kernel/mac80211/patches/440-ath5k_channel_bw_debugfs.patch
deleted file mode 100644
index 924b62e..0000000
--- a/package/kernel/mac80211/patches/440-ath5k_channel_bw_debugfs.patch
+++ /dev/null
@@ -1,143 +0,0 @@
-This adds a bwmode debugfs file which can be used to set alternate
-channel operating bandwidths.  Only tested with AR5413 and only at
-5 and 20 mhz channels.
-
-Signed-off-by: Pat Erley <pat-lkml at erley.org>
----
-Other devices will need to be added to the switch in  write_file_bwmode
-
-drivers/net/wireless/ath/ath5k/debug.c |   86 ++++++++++++++++++++++++++++++++
- 1 files changed, 86 insertions(+), 0 deletions(-)
-
---- a/drivers/net/wireless/ath/ath5k/debug.c
-+++ b/drivers/net/wireless/ath/ath5k/debug.c
-@@ -823,6 +823,97 @@ static const struct file_operations fops
- 	.llseek = default_llseek,
- };
- 
-+/* debugfs: bwmode */
-+
-+static ssize_t read_file_bwmode(struct file *file, char __user *user_buf,
-+				   size_t count, loff_t *ppos)
-+{
-+	struct ath5k_hw *ah = file->private_data;
-+	char buf[15];
-+	unsigned int len = 0;
-+
-+	int cur_ah_bwmode = ah->ah_bwmode_debug;
-+
-+#define print_selected(MODE, LABEL) \
-+	if (cur_ah_bwmode == MODE) \
-+		len += snprintf(buf+len, sizeof(buf)-len, "[%s]", LABEL); \
-+	else \
-+		len += snprintf(buf+len, sizeof(buf)-len, "%s", LABEL); \
-+	len += snprintf(buf+len, sizeof(buf)-len, " ");
-+
-+	print_selected(AR5K_BWMODE_5MHZ, "5");
-+	print_selected(AR5K_BWMODE_10MHZ, "10");
-+	print_selected(AR5K_BWMODE_DEFAULT, "20");
-+	print_selected(AR5K_BWMODE_40MHZ, "40");
-+#undef print_selected
-+
-+	len += snprintf(buf+len, sizeof(buf)-len, "\n");
-+
-+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
-+}
-+
-+static ssize_t write_file_bwmode(struct file *file,
-+				 const char __user *userbuf,
-+				 size_t count, loff_t *ppos)
-+{
-+	struct ath5k_hw *ah = file->private_data;
-+	char buf[3];
-+	int bw = 20;
-+	int tobwmode = AR5K_BWMODE_DEFAULT;
-+
-+	if (copy_from_user(buf, userbuf, min(count, sizeof(buf))))
-+		return -EFAULT;
-+
-+	/* TODO: Add check for active interface */
-+
-+	if(strncmp(buf, "5", 1) == 0 ) {
-+		tobwmode = AR5K_BWMODE_5MHZ;
-+		bw = 5;
-+	} else if ( strncmp(buf, "10", 2) == 0 ) {
-+		tobwmode = AR5K_BWMODE_10MHZ;
-+		bw = 10;
-+	} else if ( strncmp(buf, "20", 2) == 0 ) {
-+		tobwmode = AR5K_BWMODE_DEFAULT;
-+		bw = 20;
-+	} else if ( strncmp(buf, "40", 2) == 0 ) {
-+		tobwmode = AR5K_BWMODE_40MHZ;
-+		bw = 40;
-+	} else
-+		return -EINVAL;
-+
-+	ATH5K_INFO(ah, "Changing to %imhz channel width[%i]\n",
-+		bw, tobwmode);
-+
-+	switch (ah->ah_radio) {
-+	/* TODO: only define radios that actually support 5/10mhz channels */
-+	case AR5K_RF5413:
-+	case AR5K_RF5110:
-+	case AR5K_RF5111:
-+	case AR5K_RF5112:
-+	case AR5K_RF2413:
-+	case AR5K_RF2316:
-+	case AR5K_RF2317:
-+	case AR5K_RF2425:
-+		if(ah->ah_bwmode_debug != tobwmode) {
-+			mutex_lock(&ah->lock);
-+			ah->ah_bwmode = tobwmode;
-+			ah->ah_bwmode_debug = tobwmode;
-+			mutex_unlock(&ah->lock);
-+		}
-+		break;
-+	default:
-+		return -EOPNOTSUPP;
-+	}
-+	return count;
-+}
-+
-+static const struct file_operations fops_bwmode = {
-+	.read = read_file_bwmode,
-+	.write = write_file_bwmode,
-+	.open = simple_open,
-+	.owner = THIS_MODULE,
-+	.llseek = default_llseek,
-+};
- 
- /* debugfs: queues etc */
- 
-@@ -1010,6 +1101,9 @@ ath5k_debug_init_device(struct ath5k_hw
- 	debugfs_create_file("beacon", S_IWUSR | S_IRUSR, phydir, ah,
- 			    &fops_beacon);
- 
-+	debugfs_create_file("bwmode", S_IWUSR | S_IRUSR, phydir, ah,
-+			    &fops_bwmode);
-+
- 	debugfs_create_file("reset", S_IWUSR, phydir, ah, &fops_reset);
- 
- 	debugfs_create_file("antenna", S_IWUSR | S_IRUSR, phydir, ah,
---- a/drivers/net/wireless/ath/ath5k/ath5k.h
-+++ b/drivers/net/wireless/ath/ath5k/ath5k.h
-@@ -1372,6 +1372,7 @@ struct ath5k_hw {
- 	u8			ah_coverage_class;
- 	bool			ah_ack_bitrate_high;
- 	u8			ah_bwmode;
-+	u8			ah_bwmode_debug;
- 	bool			ah_short_slot;
- 
- 	/* Antenna Control */
---- a/drivers/net/wireless/ath/ath5k/base.c
-+++ b/drivers/net/wireless/ath/ath5k/base.c
-@@ -466,6 +466,9 @@ ath5k_chan_set(struct ath5k_hw *ah, stru
- 		return -EINVAL;
- 	}
- 
-+	if (ah->ah_bwmode_debug != AR5K_BWMODE_DEFAULT)
-+		ah->ah_bwmode = ah->ah_bwmode_debug;
-+
- 	/*
- 	 * To switch channels clear any pending DMA operations;
- 	 * wait long enough for the RX fifo to drain, reset the
diff --git a/package/kernel/mac80211/patches/500-ath9k_eeprom_debugfs.patch b/package/kernel/mac80211/patches/500-ath9k_eeprom_debugfs.patch
deleted file mode 100644
index 4b6da97..0000000
--- a/package/kernel/mac80211/patches/500-ath9k_eeprom_debugfs.patch
+++ /dev/null
@@ -1,65 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/debug.c
-+++ b/drivers/net/wireless/ath/ath9k/debug.c
-@@ -1319,6 +1319,53 @@ void ath9k_deinit_debug(struct ath_softc
- 	ath9k_cmn_spectral_deinit_debug(&sc->spec_priv);
- }
- 
-+static ssize_t read_file_eeprom(struct file *file, char __user *user_buf,
-+			     size_t count, loff_t *ppos)
-+{
-+	struct ath_softc *sc = file->private_data;
-+	struct ath_hw *ah = sc->sc_ah;
-+	struct ath_common *common = ath9k_hw_common(ah);
-+	int bytes = 0;
-+	int pos = *ppos;
-+	int size = 4096;
-+	u16 val;
-+	int i;
-+
-+	if (AR_SREV_9300_20_OR_LATER(ah))
-+		size = 16384;
-+
-+	if (*ppos < 0)
-+		return -EINVAL;
-+
-+	if (count > size - *ppos)
-+		count = size - *ppos;
-+
-+	for (i = *ppos / 2; count > 0; count -= bytes, *ppos += bytes, i++) {
-+		void *from = &val;
-+
-+		if (!common->bus_ops->eeprom_read(common, i, &val))
-+			val = 0xffff;
-+
-+		if (*ppos % 2) {
-+			from++;
-+			bytes = 1;
-+		} else if (count == 1) {
-+			bytes = 1;
-+		} else {
-+			bytes = 2;
-+		}
-+		copy_to_user(user_buf, from, bytes);
-+		user_buf += bytes;
-+	}
-+	return *ppos - pos;
-+}
-+
-+static const struct file_operations fops_eeprom = {
-+	.read = read_file_eeprom,
-+	.open = simple_open,
-+	.owner = THIS_MODULE
-+};
-+
- int ath9k_init_debug(struct ath_hw *ah)
- {
- 	struct ath_common *common = ath9k_hw_common(ah);
-@@ -1338,6 +1385,8 @@ int ath9k_init_debug(struct ath_hw *ah)
- 	ath9k_tx99_init_debug(sc);
- 	ath9k_cmn_spectral_init_debug(&sc->spec_priv, sc->debug.debugfs_phy);
- 
-+	debugfs_create_file("eeprom", S_IRUSR, sc->debug.debugfs_phy, sc,
-+			    &fops_eeprom);
- 	debugfs_create_devm_seqfile(sc->dev, "dma", sc->debug.debugfs_phy,
- 				    read_file_dma);
- 	debugfs_create_devm_seqfile(sc->dev, "interrupt", sc->debug.debugfs_phy,
diff --git a/package/kernel/mac80211/patches/501-ath9k_ahb_init.patch b/package/kernel/mac80211/patches/501-ath9k_ahb_init.patch
deleted file mode 100644
index 1825d77..0000000
--- a/package/kernel/mac80211/patches/501-ath9k_ahb_init.patch
+++ /dev/null
@@ -1,32 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/init.c
-+++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -1030,23 +1030,23 @@ static int __init ath9k_init(void)
- {
- 	int error;
- 
--	error = ath_pci_init();
-+	error = ath_ahb_init();
- 	if (error < 0) {
--		pr_err("No PCI devices found, driver not installed\n");
- 		error = -ENODEV;
- 		goto err_out;
- 	}
- 
--	error = ath_ahb_init();
-+	error = ath_pci_init();
- 	if (error < 0) {
-+		pr_err("No PCI devices found, driver not installed\n");
- 		error = -ENODEV;
--		goto err_pci_exit;
-+		goto err_ahb_exit;
- 	}
- 
- 	return 0;
- 
-- err_pci_exit:
--	ath_pci_exit();
-+ err_ahb_exit:
-+	ath_ahb_exit();
-  err_out:
- 	return error;
- }
diff --git a/package/kernel/mac80211/patches/510-ath9k_intr_mitigation_tweak.patch b/package/kernel/mac80211/patches/510-ath9k_intr_mitigation_tweak.patch
deleted file mode 100644
index d2a3b96..0000000
--- a/package/kernel/mac80211/patches/510-ath9k_intr_mitigation_tweak.patch
+++ /dev/null
@@ -1,18 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/hw.c
-+++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -390,13 +390,8 @@ static void ath9k_hw_init_config(struct
- 
- 	ah->config.rx_intr_mitigation = true;
- 
--	if (AR_SREV_9300_20_OR_LATER(ah)) {
--		ah->config.rimt_last = 500;
--		ah->config.rimt_first = 2000;
--	} else {
--		ah->config.rimt_last = 250;
--		ah->config.rimt_first = 700;
--	}
-+	ah->config.rimt_last = 250;
-+	ah->config.rimt_first = 500;
- 
- 	if (AR_SREV_9462(ah) || AR_SREV_9565(ah))
- 		ah->config.pll_pwrsave = 7;
diff --git a/package/kernel/mac80211/patches/511-ath9k_reduce_rxbuf.patch b/package/kernel/mac80211/patches/511-ath9k_reduce_rxbuf.patch
deleted file mode 100644
index 6766111..0000000
--- a/package/kernel/mac80211/patches/511-ath9k_reduce_rxbuf.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/ath9k.h
-+++ b/drivers/net/wireless/ath/ath9k/ath9k.h
-@@ -88,7 +88,7 @@ int ath_descdma_setup(struct ath_softc *
- 		(_l) &= ((_sz) - 1);		\
- 	} while (0)
- 
--#define ATH_RXBUF               512
-+#define ATH_RXBUF               256
- #define ATH_TXBUF               512
- #define ATH_TXBUF_RESERVE       5
- #define ATH_MAX_QDEPTH          (ATH_TXBUF / 4 - ATH_TXBUF_RESERVE)
diff --git a/package/kernel/mac80211/patches/512-ath9k_channelbw_debugfs.patch b/package/kernel/mac80211/patches/512-ath9k_channelbw_debugfs.patch
deleted file mode 100644
index a105d40..0000000
--- a/package/kernel/mac80211/patches/512-ath9k_channelbw_debugfs.patch
+++ /dev/null
@@ -1,125 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/debug.c
-+++ b/drivers/net/wireless/ath/ath9k/debug.c
-@@ -1366,6 +1366,52 @@ static const struct file_operations fops
- 	.owner = THIS_MODULE
- };
- 
-+
-+static ssize_t read_file_chan_bw(struct file *file, char __user *user_buf,
-+			     size_t count, loff_t *ppos)
-+{
-+	struct ath_softc *sc = file->private_data;
-+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
-+	char buf[32];
-+	unsigned int len;
-+
-+	len = sprintf(buf, "0x%08x\n", common->chan_bw);
-+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
-+}
-+
-+static ssize_t write_file_chan_bw(struct file *file, const char __user *user_buf,
-+			     size_t count, loff_t *ppos)
-+{
-+	struct ath_softc *sc = file->private_data;
-+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
-+	unsigned long chan_bw;
-+	char buf[32];
-+	ssize_t len;
-+
-+	len = min(count, sizeof(buf) - 1);
-+	if (copy_from_user(buf, user_buf, len))
-+		return -EFAULT;
-+
-+	buf[len] = '\0';
-+	if (kstrtoul(buf, 0, &chan_bw))
-+		return -EINVAL;
-+
-+	common->chan_bw = chan_bw;
-+	if (!test_bit(ATH_OP_INVALID, &common->op_flags))
-+		ath9k_ops.config(sc->hw, IEEE80211_CONF_CHANGE_CHANNEL);
-+
-+	return count;
-+}
-+
-+static const struct file_operations fops_chanbw = {
-+	.read = read_file_chan_bw,
-+	.write = write_file_chan_bw,
-+	.open = simple_open,
-+	.owner = THIS_MODULE,
-+	.llseek = default_llseek,
-+};
-+
-+
- int ath9k_init_debug(struct ath_hw *ah)
- {
- 	struct ath_common *common = ath9k_hw_common(ah);
-@@ -1387,6 +1433,8 @@ int ath9k_init_debug(struct ath_hw *ah)
- 
- 	debugfs_create_file("eeprom", S_IRUSR, sc->debug.debugfs_phy, sc,
- 			    &fops_eeprom);
-+	debugfs_create_file("chanbw", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
-+			    sc, &fops_chanbw);
- 	debugfs_create_devm_seqfile(sc->dev, "dma", sc->debug.debugfs_phy,
- 				    read_file_dma);
- 	debugfs_create_devm_seqfile(sc->dev, "interrupt", sc->debug.debugfs_phy,
---- a/drivers/net/wireless/ath/ath.h
-+++ b/drivers/net/wireless/ath/ath.h
-@@ -151,6 +151,7 @@ struct ath_common {
- 	int debug_mask;
- 	enum ath_device_state state;
- 	unsigned long op_flags;
-+	u32 chan_bw;
- 
- 	struct ath_ani ani;
- 
---- a/drivers/net/wireless/ath/ath9k/common.c
-+++ b/drivers/net/wireless/ath/ath9k/common.c
-@@ -296,11 +296,13 @@ EXPORT_SYMBOL(ath9k_cmn_get_hw_crypto_ke
- /*
-  * Update internal channel flags.
-  */
--static void ath9k_cmn_update_ichannel(struct ath9k_channel *ichan,
-+static void ath9k_cmn_update_ichannel(struct ath_common *common,
-+				      struct ath9k_channel *ichan,
- 				      struct cfg80211_chan_def *chandef)
- {
- 	struct ieee80211_channel *chan = chandef->chan;
- 	u16 flags = 0;
-+	int width;
- 
- 	ichan->channel = chan->center_freq;
- 	ichan->chan = chan;
-@@ -308,7 +310,19 @@ static void ath9k_cmn_update_ichannel(st
- 	if (chan->band == NL80211_BAND_5GHZ)
- 		flags |= CHANNEL_5GHZ;
- 
--	switch (chandef->width) {
-+	switch (common->chan_bw) {
-+	case 5:
-+		width = NL80211_CHAN_WIDTH_5;
-+		break;
-+	case 10:
-+		width = NL80211_CHAN_WIDTH_10;
-+		break;
-+	default:
-+		width = chandef->width;
-+		break;
-+	}
-+
-+	switch (width) {
- 	case NL80211_CHAN_WIDTH_5:
- 		flags |= CHANNEL_QUARTER;
- 		break;
-@@ -341,10 +355,11 @@ struct ath9k_channel *ath9k_cmn_get_chan
- 					    struct cfg80211_chan_def *chandef)
- {
- 	struct ieee80211_channel *curchan = chandef->chan;
-+	struct ath_common *common = ath9k_hw_common(ah);
- 	struct ath9k_channel *channel;
- 
- 	channel = &ah->channels[curchan->hw_value];
--	ath9k_cmn_update_ichannel(channel, chandef);
-+	ath9k_cmn_update_ichannel(common, channel, chandef);
- 
- 	return channel;
- }
diff --git a/package/kernel/mac80211/patches/513-ath9k_add_pci_ids.patch b/package/kernel/mac80211/patches/513-ath9k_add_pci_ids.patch
deleted file mode 100644
index 167eeff..0000000
--- a/package/kernel/mac80211/patches/513-ath9k_add_pci_ids.patch
+++ /dev/null
@@ -1,30 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/hw.c
-+++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -651,6 +651,7 @@ int ath9k_hw_init(struct ath_hw *ah)
- 
- 	/* These are all the AR5008/AR9001/AR9002/AR9003 hardware family of chipsets */
- 	switch (ah->hw_version.devid) {
-+	case AR9300_DEVID_INVALID:
- 	case AR5416_DEVID_PCI:
- 	case AR5416_DEVID_PCIE:
- 	case AR5416_AR9100_DEVID:
---- a/drivers/net/wireless/ath/ath9k/hw.h
-+++ b/drivers/net/wireless/ath/ath9k/hw.h
-@@ -36,6 +36,7 @@
- 
- #define ATHEROS_VENDOR_ID	0x168c
- 
-+#define AR9300_DEVID_INVALID	0xabcd
- #define AR5416_DEVID_PCI	0x0023
- #define AR5416_DEVID_PCIE	0x0024
- #define AR9160_DEVID_PCI	0x0027
---- a/drivers/net/wireless/ath/ath9k/pci.c
-+++ b/drivers/net/wireless/ath/ath9k/pci.c
-@@ -761,6 +761,7 @@ static const struct pci_device_id ath_pc
- 	  .driver_data = ATH9K_PCI_BT_ANT_DIV },
- #endif
- 
-+	{ PCI_VDEVICE(ATHEROS, 0xabcd) }, /* PCI-E  internal chip default ID */
- 	{ 0 }
- };
- 
diff --git a/package/kernel/mac80211/patches/522-mac80211_configure_antenna_gain.patch b/package/kernel/mac80211/patches/522-mac80211_configure_antenna_gain.patch
deleted file mode 100644
index 28f5dcc..0000000
--- a/package/kernel/mac80211/patches/522-mac80211_configure_antenna_gain.patch
+++ /dev/null
@@ -1,160 +0,0 @@
---- a/include/net/cfg80211.h
-+++ b/include/net/cfg80211.h
-@@ -2406,6 +2406,7 @@ struct cfg80211_qos_map {
-  *	(as advertised by the nl80211 feature flag.)
-  * @get_tx_power: store the current TX power into the dbm variable;
-  *	return 0 if successful
-+ * @set_antenna_gain: set antenna gain to reduce maximum tx power if necessary
-  *
-  * @set_wds_peer: set the WDS peer for a WDS interface
-  *
-@@ -2667,6 +2668,7 @@ struct cfg80211_ops {
- 				enum nl80211_tx_power_setting type, int mbm);
- 	int	(*get_tx_power)(struct wiphy *wiphy, struct wireless_dev *wdev,
- 				int *dbm);
-+	int	(*set_antenna_gain)(struct wiphy *wiphy, int dbi);
- 
- 	int	(*set_wds_peer)(struct wiphy *wiphy, struct net_device *dev,
- 				const u8 *addr);
---- a/include/net/mac80211.h
-+++ b/include/net/mac80211.h
-@@ -1305,6 +1305,7 @@ enum ieee80211_smps_mode {
-  *
-  * @power_level: requested transmit power (in dBm), backward compatibility
-  *	value only that is set to the minimum of all interfaces
-+ * @max_antenna_gain: maximum antenna gain adjusted by user config (in dBi)
-  *
-  * @chandef: the channel definition to tune to
-  * @radar_enabled: whether radar detection is enabled
-@@ -1325,6 +1326,7 @@ enum ieee80211_smps_mode {
- struct ieee80211_conf {
- 	u32 flags;
- 	int power_level, dynamic_ps_timeout;
-+	int max_antenna_gain;
- 
- 	u16 listen_interval;
- 	u8 ps_dtim_period;
---- a/include/uapi/linux/nl80211.h
-+++ b/include/uapi/linux/nl80211.h
-@@ -1819,6 +1819,9 @@ enum nl80211_commands {
-  *
-  * @NL80211_ATTR_PAD: attribute used for padding for 64-bit alignment
-  *
-+ * @NL80211_ATTR_WIPHY_ANTENNA_GAIN: Configured antenna gain. Used to reduce
-+ *	transmit power to stay within regulatory limits. u32, dBi.
-+ *
-  * @NUM_NL80211_ATTR: total number of nl80211_attrs available
-  * @NL80211_ATTR_MAX: highest attribute number currently defined
-  * @__NL80211_ATTR_AFTER_LAST: internal use
-@@ -2201,6 +2204,8 @@ enum nl80211_attrs {
- 
- 	NL80211_ATTR_PAD,
- 
-+	NL80211_ATTR_WIPHY_ANTENNA_GAIN,
-+
- 	/* add attributes here, update the policy in nl80211.c */
- 
- 	__NL80211_ATTR_AFTER_LAST,
---- a/net/mac80211/cfg.c
-+++ b/net/mac80211/cfg.c
-@@ -2238,6 +2238,19 @@ static int ieee80211_get_tx_power(struct
- 	return 0;
- }
- 
-+static int ieee80211_set_antenna_gain(struct wiphy *wiphy, int dbi)
-+{
-+	struct ieee80211_local *local = wiphy_priv(wiphy);
-+
-+	if (dbi < 0)
-+		return -EINVAL;
-+
-+	local->user_antenna_gain = dbi;
-+	ieee80211_hw_config(local, 0);
-+
-+	return 0;
-+}
-+
- static int ieee80211_set_wds_peer(struct wiphy *wiphy, struct net_device *dev,
- 				  const u8 *addr)
- {
-@@ -3412,6 +3425,7 @@ const struct cfg80211_ops mac80211_confi
- 	.set_wiphy_params = ieee80211_set_wiphy_params,
- 	.set_tx_power = ieee80211_set_tx_power,
- 	.get_tx_power = ieee80211_get_tx_power,
-+	.set_antenna_gain = ieee80211_set_antenna_gain,
- 	.set_wds_peer = ieee80211_set_wds_peer,
- 	.rfkill_poll = ieee80211_rfkill_poll,
- 	CFG80211_TESTMODE_CMD(ieee80211_testmode_cmd)
---- a/net/mac80211/ieee80211_i.h
-+++ b/net/mac80211/ieee80211_i.h
-@@ -1322,6 +1322,7 @@ struct ieee80211_local {
- 	int dynamic_ps_forced_timeout;
- 
- 	int user_power_level; /* in dBm, for all interfaces */
-+	int user_antenna_gain; /* in dBi */
- 
- 	enum ieee80211_smps_mode smps_mode;
- 
---- a/net/mac80211/main.c
-+++ b/net/mac80211/main.c
-@@ -93,7 +93,7 @@ static u32 ieee80211_hw_conf_chan(struct
- 	struct ieee80211_sub_if_data *sdata;
- 	struct cfg80211_chan_def chandef = {};
- 	u32 changed = 0;
--	int power;
-+	int power, max_power;
- 	u32 offchannel_flag;
- 
- 	offchannel_flag = local->hw.conf.flags & IEEE80211_CONF_OFFCHANNEL;
-@@ -150,6 +150,12 @@ static u32 ieee80211_hw_conf_chan(struct
- 	}
- 	rcu_read_unlock();
- 
-+	max_power = chandef.chan->max_reg_power;
-+	if (local->user_antenna_gain > 0) {
-+		max_power -= local->user_antenna_gain;
-+		power = min(power, max_power);
-+	}
-+
- 	if (local->hw.conf.power_level != power) {
- 		changed |= IEEE80211_CONF_CHANGE_POWER;
- 		local->hw.conf.power_level = power;
-@@ -588,6 +594,7 @@ struct ieee80211_hw *ieee80211_alloc_hw_
- 					 IEEE80211_RADIOTAP_MCS_HAVE_BW;
- 	local->hw.radiotap_vht_details = IEEE80211_RADIOTAP_VHT_KNOWN_GI |
- 					 IEEE80211_RADIOTAP_VHT_KNOWN_BANDWIDTH;
-+	local->user_antenna_gain = 0;
- 	local->hw.uapsd_queues = IEEE80211_DEFAULT_UAPSD_QUEUES;
- 	local->hw.uapsd_max_sp_len = IEEE80211_DEFAULT_MAX_SP_LEN;
- 	local->user_power_level = IEEE80211_UNSET_POWER_LEVEL;
---- a/net/wireless/nl80211.c
-+++ b/net/wireless/nl80211.c
-@@ -406,6 +406,7 @@ static const struct nla_policy nl80211_p
- 	[NL80211_ATTR_PBSS] = { .type = NLA_FLAG },
- 	[NL80211_ATTR_BSS_SELECT] = { .type = NLA_NESTED },
- 	[NL80211_ATTR_STA_SUPPORT_P2P_PS] = { .type = NLA_U8 },
-+	[NL80211_ATTR_WIPHY_ANTENNA_GAIN] = { .type = NLA_U32 },
- };
- 
- /* policy for the key attributes */
-@@ -2251,6 +2252,20 @@ static int nl80211_set_wiphy(struct sk_b
- 		if (result)
- 			return result;
- 	}
-+
-+	if (info->attrs[NL80211_ATTR_WIPHY_ANTENNA_GAIN]) {
-+		int idx, dbi = 0;
-+
-+		if (!rdev->ops->set_antenna_gain)
-+			return -EOPNOTSUPP;
-+
-+		idx = NL80211_ATTR_WIPHY_ANTENNA_GAIN;
-+		dbi = nla_get_u32(info->attrs[idx]);
-+
-+		result = rdev->ops->set_antenna_gain(&rdev->wiphy, dbi);
-+		if (result)
-+			return result;
-+	}
- 
- 	if (info->attrs[NL80211_ATTR_WIPHY_ANTENNA_TX] &&
- 	    info->attrs[NL80211_ATTR_WIPHY_ANTENNA_RX]) {
diff --git a/package/kernel/mac80211/patches/530-ath9k_extra_leds.patch b/package/kernel/mac80211/patches/530-ath9k_extra_leds.patch
deleted file mode 100644
index 6001266..0000000
--- a/package/kernel/mac80211/patches/530-ath9k_extra_leds.patch
+++ /dev/null
@@ -1,276 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/ath9k.h
-+++ b/drivers/net/wireless/ath/ath9k/ath9k.h
-@@ -813,6 +813,9 @@ static inline int ath9k_dump_btcoex(stru
- #ifdef CPTCFG_MAC80211_LEDS
- void ath_init_leds(struct ath_softc *sc);
- void ath_deinit_leds(struct ath_softc *sc);
-+int ath_create_gpio_led(struct ath_softc *sc, int gpio, const char *name,
-+			const char *trigger, bool active_low);
-+
- #else
- static inline void ath_init_leds(struct ath_softc *sc)
- {
-@@ -949,6 +952,13 @@ void ath_ant_comb_scan(struct ath_softc
- 
- #define ATH9K_NUM_CHANCTX  2 /* supports 2 operating channels */
- 
-+struct ath_led {
-+	struct list_head list;
-+	struct ath_softc *sc;
-+	const struct gpio_led *gpio;
-+	struct led_classdev cdev;
-+};
-+
- struct ath_softc {
- 	struct ieee80211_hw *hw;
- 	struct device *dev;
-@@ -1001,9 +1011,8 @@ struct ath_softc {
- 	spinlock_t chan_lock;
- 
- #ifdef CPTCFG_MAC80211_LEDS
--	bool led_registered;
--	char led_name[32];
--	struct led_classdev led_cdev;
-+	const char *led_default_trigger;
-+	struct list_head leds;
- #endif
- 
- #ifdef CPTCFG_ATH9K_DEBUGFS
---- a/drivers/net/wireless/ath/ath9k/gpio.c
-+++ b/drivers/net/wireless/ath/ath9k/gpio.c
-@@ -22,7 +22,7 @@
- 
- #ifdef CPTCFG_MAC80211_LEDS
- 
--void ath_fill_led_pin(struct ath_softc *sc)
-+static void ath_fill_led_pin(struct ath_softc *sc)
- {
- 	struct ath_hw *ah = sc->sc_ah;
- 
-@@ -39,61 +39,111 @@ void ath_fill_led_pin(struct ath_softc *
- 		else
- 			ah->led_pin = ATH_LED_PIN_DEF;
- 	}
-+}
-+
-+static void ath_led_brightness(struct led_classdev *led_cdev,
-+			       enum led_brightness brightness)
-+{
-+	struct ath_led *led = container_of(led_cdev, struct ath_led, cdev);
-+	struct ath_softc *sc = led->sc;
-+
-+	ath9k_ps_wakeup(sc);
-+	ath9k_hw_set_gpio(sc->sc_ah, led->gpio->gpio,
-+			  (brightness != LED_OFF) ^ led->gpio->active_low);
-+	ath9k_ps_restore(sc);
-+}
-+
-+static int ath_add_led(struct ath_softc *sc, struct ath_led *led)
-+{
-+	const struct gpio_led *gpio = led->gpio;
-+	int ret;
-+
-+	led->cdev.name = gpio->name;
-+	led->cdev.default_trigger = gpio->default_trigger;
-+	led->cdev.brightness_set = ath_led_brightness;
-+
-+	ret = led_classdev_register(wiphy_dev(sc->hw->wiphy), &led->cdev);
-+	if (ret < 0)
-+		return ret;
-+
-+	led->sc = sc;
-+	list_add(&led->list, &sc->leds);
- 
- 	/* Configure gpio for output */
--	ath9k_hw_gpio_request_out(ah, ah->led_pin, "ath9k-led",
-+	ath9k_hw_gpio_request_out(sc->sc_ah, gpio->gpio, gpio->name,
- 				  AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
- 
--	/* LED off, active low */
--	ath9k_hw_set_gpio(ah, ah->led_pin, ah->config.led_active_high ? 0 : 1);
-+	/* LED off */
-+	ath9k_hw_set_gpio(sc->sc_ah, gpio->gpio, gpio->active_low);
-+
-+	return 0;
- }
- 
--static void ath_led_brightness(struct led_classdev *led_cdev,
--			       enum led_brightness brightness)
-+int ath_create_gpio_led(struct ath_softc *sc, int gpio_num, const char *name,
-+			const char *trigger, bool active_low)
- {
--	struct ath_softc *sc = container_of(led_cdev, struct ath_softc, led_cdev);
--	u32 val = (brightness == LED_OFF);
-+	struct ath_led *led;
-+	struct gpio_led *gpio;
-+	char *_name;
-+	int ret;
- 
--	if (sc->sc_ah->config.led_active_high)
--		val = !val;
-+	led = kzalloc(sizeof(*led) + sizeof(*gpio) + strlen(name) + 1,
-+		      GFP_KERNEL);
-+	if (!led)
-+		return -ENOMEM;
- 
--	ath9k_hw_set_gpio(sc->sc_ah, sc->sc_ah->led_pin, val);
-+	led->gpio = gpio = (struct gpio_led *) (led + 1);
-+	_name = (char *) (led->gpio + 1);
-+
-+	strcpy(_name, name);
-+	gpio->name = _name;
-+	gpio->gpio = gpio_num;
-+	gpio->active_low = active_low;
-+	gpio->default_trigger = trigger;
-+
-+	ret = ath_add_led(sc, led);
-+	if (unlikely(ret < 0))
-+		kfree(led);
-+
-+	return ret;
- }
- 
- void ath_deinit_leds(struct ath_softc *sc)
- {
--	if (!sc->led_registered)
--		return;
--
--	ath_led_brightness(&sc->led_cdev, LED_OFF);
--	led_classdev_unregister(&sc->led_cdev);
-+	struct ath_led *led;
- 
--	ath9k_hw_gpio_free(sc->sc_ah, sc->sc_ah->led_pin);
-+	while (!list_empty(&sc->leds)) {
-+		led = list_first_entry(&sc->leds, struct ath_led, list);
-+		list_del(&led->list);
-+		ath_led_brightness(&led->cdev, LED_OFF);
-+		led_classdev_unregister(&led->cdev);
-+		ath9k_hw_gpio_free(sc->sc_ah, led->gpio->gpio);
-+		kfree(led);
-+	}
- }
- 
- void ath_init_leds(struct ath_softc *sc)
- {
--	int ret;
-+	char led_name[32];
-+	const char *trigger;
-+
-+	INIT_LIST_HEAD(&sc->leds);
- 
- 	if (AR_SREV_9100(sc->sc_ah))
- 		return;
- 
- 	ath_fill_led_pin(sc);
- 
--	if (!ath9k_led_blink)
--		sc->led_cdev.default_trigger =
--			ieee80211_get_radio_led_name(sc->hw);
--
--	snprintf(sc->led_name, sizeof(sc->led_name),
--		"ath9k-%s", wiphy_name(sc->hw->wiphy));
--	sc->led_cdev.name = sc->led_name;
--	sc->led_cdev.brightness_set = ath_led_brightness;
-+	snprintf(led_name, sizeof(led_name), "ath9k-%s",
-+		 wiphy_name(sc->hw->wiphy));
- 
--	ret = led_classdev_register(wiphy_dev(sc->hw->wiphy), &sc->led_cdev);
--	if (ret < 0)
--		return;
-+	if (ath9k_led_blink)
-+		trigger = sc->led_default_trigger;
-+	else
-+		trigger = ieee80211_get_radio_led_name(sc->hw);
- 
--	sc->led_registered = true;
-+	ath_create_gpio_led(sc, sc->sc_ah->led_pin, led_name, trigger,
-+			   !sc->sc_ah->config.led_active_high);
- }
- #endif
- 
---- a/drivers/net/wireless/ath/ath9k/init.c
-+++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -942,7 +942,7 @@ int ath9k_init_device(u16 devid, struct
- 
- #ifdef CPTCFG_MAC80211_LEDS
- 	/* must be initialized before ieee80211_register_hw */
--	sc->led_cdev.default_trigger = ieee80211_create_tpt_led_trigger(sc->hw,
-+	sc->led_default_trigger = ieee80211_create_tpt_led_trigger(sc->hw,
- 		IEEE80211_TPT_LEDTRIG_FL_RADIO, ath9k_tpt_blink,
- 		ARRAY_SIZE(ath9k_tpt_blink));
- #endif
---- a/drivers/net/wireless/ath/ath9k/debug.c
-+++ b/drivers/net/wireless/ath/ath9k/debug.c
-@@ -1411,6 +1411,61 @@ static const struct file_operations fops
- 	.llseek = default_llseek,
- };
- 
-+#ifdef CONFIG_MAC80211_LEDS
-+
-+static ssize_t write_file_gpio_led(struct file *file, const char __user *ubuf,
-+				   size_t count, loff_t *ppos)
-+{
-+	struct ath_softc *sc = file->private_data;
-+	char buf[32], *str, *name, *c;
-+	ssize_t len;
-+	unsigned int gpio;
-+	bool active_low = false;
-+
-+	len = min(count, sizeof(buf) - 1);
-+	if (copy_from_user(buf, ubuf, len))
-+		return -EFAULT;
-+
-+	buf[len] = '\0';
-+	name = strchr(buf, ',');
-+	if (!name)
-+		return -EINVAL;
-+
-+	*(name++) = 0;
-+	if (!*name)
-+		return -EINVAL;
-+
-+	c = strchr(name, '\n');
-+	if (c)
-+		*c = 0;
-+
-+	str = buf;
-+	if (*str == '!') {
-+		str++;
-+		active_low = true;
-+	}
-+
-+	if (kstrtouint(str, 0, &gpio) < 0)
-+		return -EINVAL;
-+
-+	if (gpio >= sc->sc_ah->caps.num_gpio_pins)
-+		return -EINVAL;
-+
-+	if (ath_create_gpio_led(sc, gpio, name, NULL, active_low) < 0)
-+		return -EINVAL;
-+
-+	return count;
-+}
-+
-+static const struct file_operations fops_gpio_led = {
-+	.write = write_file_gpio_led,
-+	.open = simple_open,
-+	.owner = THIS_MODULE,
-+	.llseek = default_llseek,
-+};
-+
-+#endif
-+
- 
- int ath9k_init_debug(struct ath_hw *ah)
- {
-@@ -1435,6 +1490,10 @@ int ath9k_init_debug(struct ath_hw *ah)
- 			    &fops_eeprom);
- 	debugfs_create_file("chanbw", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
- 			    sc, &fops_chanbw);
-+#ifdef CONFIG_MAC80211_LEDS
-+	debugfs_create_file("gpio_led", S_IWUSR,
-+			   sc->debug.debugfs_phy, sc, &fops_gpio_led);
-+#endif
- 	debugfs_create_devm_seqfile(sc->dev, "dma", sc->debug.debugfs_phy,
- 				    read_file_dma);
- 	debugfs_create_devm_seqfile(sc->dev, "interrupt", sc->debug.debugfs_phy,
diff --git a/package/kernel/mac80211/patches/531-ath9k_extra_platform_leds.patch b/package/kernel/mac80211/patches/531-ath9k_extra_platform_leds.patch
deleted file mode 100644
index f656697..0000000
--- a/package/kernel/mac80211/patches/531-ath9k_extra_platform_leds.patch
+++ /dev/null
@@ -1,71 +0,0 @@
---- a/include/linux/ath9k_platform.h
-+++ b/include/linux/ath9k_platform.h
-@@ -45,6 +45,9 @@ struct ath9k_platform_data {
- 	int (*external_reset)(void);
- 
- 	bool use_eeprom;
-+
-+	int num_leds;
-+	const struct gpio_led *leds;
- };
- 
- #endif /* _LINUX_ATH9K_PLATFORM_H */
---- a/drivers/net/wireless/ath/ath9k/gpio.c
-+++ b/drivers/net/wireless/ath/ath9k/gpio.c
-@@ -15,6 +15,7 @@
-  */
- 
- #include "ath9k.h"
-+#include <linux/ath9k_platform.h>
- 
- /********************************/
- /*	 LED functions		*/
-@@ -108,6 +109,24 @@ int ath_create_gpio_led(struct ath_softc
- 	return ret;
- }
- 
-+static int ath_create_platform_led(struct ath_softc *sc,
-+				   const struct gpio_led *gpio)
-+{
-+	struct ath_led *led;
-+	int ret;
-+
-+	led = kzalloc(sizeof(*led), GFP_KERNEL);
-+	if (!led)
-+		return -ENOMEM;
-+
-+	led->gpio = gpio;
-+	ret = ath_add_led(sc, led);
-+	if (ret < 0)
-+		kfree(led);
-+
-+	return ret;
-+}
-+
- void ath_deinit_leds(struct ath_softc *sc)
- {
- 	struct ath_led *led;
-@@ -124,8 +143,10 @@ void ath_deinit_leds(struct ath_softc *s
- 
- void ath_init_leds(struct ath_softc *sc)
- {
-+	struct ath9k_platform_data *pdata = sc->dev->platform_data;
- 	char led_name[32];
- 	const char *trigger;
-+	int i;
- 
- 	INIT_LIST_HEAD(&sc->leds);
- 
-@@ -144,6 +165,12 @@ void ath_init_leds(struct ath_softc *sc)
- 
- 	ath_create_gpio_led(sc, sc->sc_ah->led_pin, led_name, trigger,
- 			   !sc->sc_ah->config.led_active_high);
-+
-+	if (!pdata)
-+		return;
-+
-+	for (i = 0; i < pdata->num_leds; i++)
-+		ath_create_platform_led(sc, &pdata->leds[i]);
- }
- #endif
- 
diff --git a/package/kernel/mac80211/patches/532-ath9k_get_led_polarity_from_platform_data.patch b/package/kernel/mac80211/patches/532-ath9k_get_led_polarity_from_platform_data.patch
deleted file mode 100644
index 986f155..0000000
--- a/package/kernel/mac80211/patches/532-ath9k_get_led_polarity_from_platform_data.patch
+++ /dev/null
@@ -1,20 +0,0 @@
---- a/include/linux/ath9k_platform.h
-+++ b/include/linux/ath9k_platform.h
-@@ -40,6 +40,7 @@ struct ath9k_platform_data {
- 	bool tx_gain_buffalo;
- 	bool disable_2ghz;
- 	bool disable_5ghz;
-+	bool led_active_high;
- 
- 	int (*get_mac_revision)(void);
- 	int (*external_reset)(void);
---- a/drivers/net/wireless/ath/ath9k/init.c
-+++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -581,6 +581,7 @@ static int ath9k_init_softc(u16 devid, s
- 		ah->external_reset = pdata->external_reset;
- 		ah->disable_2ghz = pdata->disable_2ghz;
- 		ah->disable_5ghz = pdata->disable_5ghz;
-+		ah->config.led_active_high = pdata->led_active_high;
- 		if (!pdata->endian_check)
- 			ah->ah_flags |= AH_NO_EEP_SWAP;
- 	}
diff --git a/package/kernel/mac80211/patches/540-ath9k_reduce_ani_interval.patch b/package/kernel/mac80211/patches/540-ath9k_reduce_ani_interval.patch
deleted file mode 100644
index e899903..0000000
--- a/package/kernel/mac80211/patches/540-ath9k_reduce_ani_interval.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/ani.h
-+++ b/drivers/net/wireless/ath/ath9k/ani.h
-@@ -42,7 +42,7 @@
- #define ATH9K_ANI_PERIOD                  300
- 
- /* in ms */
--#define ATH9K_ANI_POLLINTERVAL            1000
-+#define ATH9K_ANI_POLLINTERVAL            300
- 
- #define ATH9K_SIG_FIRSTEP_SETTING_MIN     0
- #define ATH9K_SIG_FIRSTEP_SETTING_MAX     20
diff --git a/package/kernel/mac80211/patches/541-ath9k_rx_dma_stop_check.patch b/package/kernel/mac80211/patches/541-ath9k_rx_dma_stop_check.patch
deleted file mode 100644
index 3c5e9f5..0000000
--- a/package/kernel/mac80211/patches/541-ath9k_rx_dma_stop_check.patch
+++ /dev/null
@@ -1,28 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/mac.c
-+++ b/drivers/net/wireless/ath/ath9k/mac.c
-@@ -695,7 +695,7 @@ bool ath9k_hw_stopdmarecv(struct ath_hw
- {
- #define AH_RX_STOP_DMA_TIMEOUT 10000   /* usec */
- 	struct ath_common *common = ath9k_hw_common(ah);
--	u32 mac_status, last_mac_status = 0;
-+	u32 mac_status = 0, last_mac_status = 0;
- 	int i;
- 
- 	/* Enable access to the DMA observation bus */
-@@ -725,6 +725,16 @@ bool ath9k_hw_stopdmarecv(struct ath_hw
- 	}
- 
- 	if (i == 0) {
-+		if (!AR_SREV_9300_20_OR_LATER(ah) &&
-+		    (mac_status & 0x700) == 0) {
-+			/*
-+			 * DMA is idle but the MAC is still stuck
-+			 * processing events
-+			 */
-+			*reset = true;
-+			return true;
-+		}
-+
- 		ath_err(common,
- 			"DMA failed to stop in %d ms AR_CR=0x%08x AR_DIAG_SW=0x%08x DMADBG_7=0x%08x\n",
- 			AH_RX_STOP_DMA_TIMEOUT / 1000,
diff --git a/package/kernel/mac80211/patches/542-ath9k_debugfs_diag.patch b/package/kernel/mac80211/patches/542-ath9k_debugfs_diag.patch
deleted file mode 100644
index f4bb0f2..0000000
--- a/package/kernel/mac80211/patches/542-ath9k_debugfs_diag.patch
+++ /dev/null
@@ -1,139 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/debug.c
-+++ b/drivers/net/wireless/ath/ath9k/debug.c
-@@ -1467,6 +1467,50 @@ static const struct file_operations fops
- #endif
- 
- 
-+static ssize_t read_file_diag(struct file *file, char __user *user_buf,
-+			     size_t count, loff_t *ppos)
-+{
-+	struct ath_softc *sc = file->private_data;
-+	struct ath_hw *ah = sc->sc_ah;
-+	char buf[32];
-+	unsigned int len;
-+
-+	len = sprintf(buf, "0x%08lx\n", ah->diag);
-+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
-+}
-+
-+static ssize_t write_file_diag(struct file *file, const char __user *user_buf,
-+			     size_t count, loff_t *ppos)
-+{
-+	struct ath_softc *sc = file->private_data;
-+	struct ath_hw *ah = sc->sc_ah;
-+	unsigned long diag;
-+	char buf[32];
-+	ssize_t len;
-+
-+	len = min(count, sizeof(buf) - 1);
-+	if (copy_from_user(buf, user_buf, len))
-+		return -EFAULT;
-+
-+	buf[len] = '\0';
-+	if (kstrtoul(buf, 0, &diag))
-+		return -EINVAL;
-+
-+	ah->diag = diag;
-+	ath9k_hw_update_diag(ah);
-+
-+	return count;
-+}
-+
-+static const struct file_operations fops_diag = {
-+	.read = read_file_diag,
-+	.write = write_file_diag,
-+	.open = simple_open,
-+	.owner = THIS_MODULE,
-+	.llseek = default_llseek,
-+};
-+
-+
- int ath9k_init_debug(struct ath_hw *ah)
- {
- 	struct ath_common *common = ath9k_hw_common(ah);
-@@ -1494,6 +1538,8 @@ int ath9k_init_debug(struct ath_hw *ah)
- 	debugfs_create_file("gpio_led", S_IWUSR,
- 			   sc->debug.debugfs_phy, sc, &fops_gpio_led);
- #endif
-+	debugfs_create_file("diag", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
-+			    sc, &fops_diag);
- 	debugfs_create_devm_seqfile(sc->dev, "dma", sc->debug.debugfs_phy,
- 				    read_file_dma);
- 	debugfs_create_devm_seqfile(sc->dev, "interrupt", sc->debug.debugfs_phy,
---- a/drivers/net/wireless/ath/ath9k/hw.h
-+++ b/drivers/net/wireless/ath/ath9k/hw.h
-@@ -520,6 +520,12 @@ enum {
- 	ATH9K_RESET_COLD,
- };
- 
-+enum {
-+	ATH_DIAG_DISABLE_RX,
-+	ATH_DIAG_DISABLE_TX,
-+	ATH_DIAG_TRIGGER_ERROR,
-+};
-+
- struct ath9k_hw_version {
- 	u32 magic;
- 	u16 devid;
-@@ -805,6 +811,8 @@ struct ath_hw {
- 	u32 rfkill_polarity;
- 	u32 ah_flags;
- 
-+	unsigned long diag;
-+
- 	bool reset_power_on;
- 	bool htc_reset_init;
- 
-@@ -1067,6 +1075,7 @@ void ath9k_hw_check_nav(struct ath_hw *a
- bool ath9k_hw_check_alive(struct ath_hw *ah);
- 
- bool ath9k_hw_setpower(struct ath_hw *ah, enum ath9k_power_mode mode);
-+void ath9k_hw_update_diag(struct ath_hw *ah);
- 
- /* Generic hw timer primitives */
- struct ath_gen_timer *ath_gen_timer_alloc(struct ath_hw *ah,
---- a/drivers/net/wireless/ath/ath9k/hw.c
-+++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -1821,6 +1821,20 @@ u32 ath9k_hw_get_tsf_offset(struct times
- }
- EXPORT_SYMBOL(ath9k_hw_get_tsf_offset);
- 
-+void ath9k_hw_update_diag(struct ath_hw *ah)
-+{
-+	if (test_bit(ATH_DIAG_DISABLE_RX, &ah->diag))
-+		REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_RX_DIS);
-+	else
-+		REG_CLR_BIT(ah, AR_DIAG_SW, AR_DIAG_RX_DIS);
-+
-+	if (test_bit(ATH_DIAG_DISABLE_TX, &ah->diag))
-+		REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_LOOP_BACK);
-+	else
-+		REG_CLR_BIT(ah, AR_DIAG_SW, AR_DIAG_LOOP_BACK);
-+}
-+EXPORT_SYMBOL(ath9k_hw_update_diag);
-+
- int ath9k_hw_reset(struct ath_hw *ah, struct ath9k_channel *chan,
- 		   struct ath9k_hw_cal_data *caldata, bool fastcc)
- {
-@@ -2029,6 +2043,7 @@ int ath9k_hw_reset(struct ath_hw *ah, st
- 		ar9003_hw_disable_phy_restart(ah);
- 
- 	ath9k_hw_apply_gpio_override(ah);
-+	ath9k_hw_update_diag(ah);
- 
- 	if (AR_SREV_9565(ah) && common->bt_ant_diversity)
- 		REG_SET_BIT(ah, AR_BTCOEX_WL_LNADIV, AR_BTCOEX_WL_LNADIV_FORCE_ON);
---- a/drivers/net/wireless/ath/ath9k/main.c
-+++ b/drivers/net/wireless/ath/ath9k/main.c
-@@ -533,6 +533,11 @@ irqreturn_t ath_isr(int irq, void *dev)
- 	if (test_bit(ATH_OP_HW_RESET, &common->op_flags))
- 		return IRQ_HANDLED;
- 
-+	if (test_bit(ATH_DIAG_TRIGGER_ERROR, &ah->diag)) {
-+		status |= ATH9K_INT_FATAL;
-+		clear_bit(ATH_DIAG_TRIGGER_ERROR, &ah->diag);
-+	}
-+
- 	/*
- 	 * If there are no status bits set, then this interrupt was not
- 	 * for me (should have been caught above).
diff --git a/package/kernel/mac80211/patches/543-ath9k_entropy_from_adc.patch b/package/kernel/mac80211/patches/543-ath9k_entropy_from_adc.patch
deleted file mode 100644
index 7da7165..0000000
--- a/package/kernel/mac80211/patches/543-ath9k_entropy_from_adc.patch
+++ /dev/null
@@ -1,186 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/hw.h
-+++ b/drivers/net/wireless/ath/ath9k/hw.h
-@@ -721,6 +721,7 @@ struct ath_spec_scan {
-  * @config_pci_powersave:
-  * @calibrate: periodic calibration for NF, ANI, IQ, ADC gain, ADC-DC
-  *
-+ * @get_adc_entropy: get entropy from the raw ADC I/Q output
-  * @spectral_scan_config: set parameters for spectral scan and enable/disable it
-  * @spectral_scan_trigger: trigger a spectral scan run
-  * @spectral_scan_wait: wait for a spectral scan run to finish
-@@ -743,6 +744,7 @@ struct ath_hw_ops {
- 			struct ath_hw_antcomb_conf *antconf);
- 	void (*antdiv_comb_conf_set)(struct ath_hw *ah,
- 			struct ath_hw_antcomb_conf *antconf);
-+	void (*get_adc_entropy)(struct ath_hw *ah, u8 *buf, size_t len);
- 	void (*spectral_scan_config)(struct ath_hw *ah,
- 				     struct ath_spec_scan *param);
- 	void (*spectral_scan_trigger)(struct ath_hw *ah);
---- a/drivers/net/wireless/ath/ath9k/ar9003_phy.c
-+++ b/drivers/net/wireless/ath/ath9k/ar9003_phy.c
-@@ -1945,6 +1945,26 @@ void ar9003_hw_init_rate_txpower(struct
- 	}
- }
- 
-+static void ar9003_hw_get_adc_entropy(struct ath_hw *ah, u8 *buf, size_t len)
-+{
-+	int i, j;
-+
-+	REG_RMW_FIELD(ah, AR_PHY_TEST, AR_PHY_TEST_BBB_OBS_SEL, 1);
-+	REG_CLR_BIT(ah, AR_PHY_TEST, AR_PHY_TEST_RX_OBS_SEL_BIT5);
-+	REG_RMW_FIELD(ah, AR_PHY_TEST_CTL_STATUS, AR_PHY_TEST_CTL_RX_OBS_SEL, 0);
-+
-+	memset(buf, 0, len);
-+	for (i = 0; i < len; i++) {
-+		for (j = 0; j < 4; j++) {
-+			u32 regval = REG_READ(ah, AR_PHY_TST_ADC);
-+
-+			buf[i] <<= 2;
-+			buf[i] |= (regval & 1) | ((regval & BIT(10)) >> 9);
-+			udelay(1);
-+		}
-+	}
-+}
-+
- void ar9003_hw_attach_phy_ops(struct ath_hw *ah)
- {
- 	struct ath_hw_private_ops *priv_ops = ath9k_hw_private_ops(ah);
-@@ -1981,6 +2001,7 @@ void ar9003_hw_attach_phy_ops(struct ath
- 	priv_ops->set_radar_params = ar9003_hw_set_radar_params;
- 	priv_ops->fast_chan_change = ar9003_hw_fast_chan_change;
- 
-+	ops->get_adc_entropy = ar9003_hw_get_adc_entropy;
- 	ops->antdiv_comb_conf_get = ar9003_hw_antdiv_comb_conf_get;
- 	ops->antdiv_comb_conf_set = ar9003_hw_antdiv_comb_conf_set;
- 	ops->spectral_scan_config = ar9003_hw_spectral_scan_config;
---- a/drivers/net/wireless/ath/ath9k/init.c
-+++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -717,7 +717,8 @@ static void ath9k_init_txpower_limits(st
- 	if (ah->caps.hw_caps & ATH9K_HW_CAP_5GHZ)
- 		ath9k_init_band_txpower(sc, NL80211_BAND_5GHZ);
- 
--	ah->curchan = curchan;
-+	if (curchan)
-+		ah->curchan = curchan;
- }
- 
- static const struct ieee80211_iface_limit if_limits[] = {
-@@ -903,6 +904,18 @@ static void ath9k_set_hw_capab(struct at
- 	SET_IEEE80211_PERM_ADDR(hw, common->macaddr);
- }
- 
-+static void ath_get_initial_entropy(struct ath_softc *sc)
-+{
-+	struct ath_hw *ah = sc->sc_ah;
-+	char buf[256];
-+
-+	/* reuse last channel initialized by the tx power test */
-+	ath9k_hw_reset(ah, ah->curchan, NULL, false);
-+
-+	ath9k_hw_get_adc_entropy(ah, buf, sizeof(buf));
-+	add_device_randomness(buf, sizeof(buf));
-+}
-+
- int ath9k_init_device(u16 devid, struct ath_softc *sc,
- 		    const struct ath_bus_ops *bus_ops)
- {
-@@ -948,6 +961,8 @@ int ath9k_init_device(u16 devid, struct
- 		ARRAY_SIZE(ath9k_tpt_blink));
- #endif
- 
-+	ath_get_initial_entropy(sc);
-+
- 	/* Register with mac80211 */
- 	error = ieee80211_register_hw(hw);
- 	if (error)
---- a/drivers/net/wireless/ath/ath9k/hw-ops.h
-+++ b/drivers/net/wireless/ath/ath9k/hw-ops.h
-@@ -100,6 +100,12 @@ static inline void ath9k_hw_tx99_set_txp
- 		ath9k_hw_ops(ah)->tx99_set_txpower(ah, power);
- }
- 
-+static inline void ath9k_hw_get_adc_entropy(struct ath_hw *ah,
-+		u8 *buf, size_t len)
-+{
-+	ath9k_hw_ops(ah)->get_adc_entropy(ah, buf, len);
-+}
-+
- #ifdef CPTCFG_ATH9K_BTCOEX_SUPPORT
- 
- static inline void ath9k_hw_set_bt_ant_diversity(struct ath_hw *ah, bool enable)
---- a/drivers/net/wireless/ath/ath9k/ar5008_phy.c
-+++ b/drivers/net/wireless/ath/ath9k/ar5008_phy.c
-@@ -1325,9 +1325,30 @@ void ar5008_hw_init_rate_txpower(struct
- 	}
- }
- 
-+static void ar5008_hw_get_adc_entropy(struct ath_hw *ah, u8 *buf, size_t len)
-+{
-+	int i, j;
-+
-+	REG_RMW_FIELD(ah, AR_PHY_TEST, AR_PHY_TEST_BBB_OBS_SEL, 1);
-+	REG_CLR_BIT(ah, AR_PHY_TEST, AR_PHY_TEST_RX_OBS_SEL_BIT5);
-+	REG_RMW_FIELD(ah, AR_PHY_TEST2, AR_PHY_TEST2_RX_OBS_SEL, 0);
-+
-+	memset(buf, 0, len);
-+	for (i = 0; i < len; i++) {
-+		for (j = 0; j < 4; j++) {
-+			u32 regval = REG_READ(ah, AR_PHY_TST_ADC);
-+
-+			buf[i] <<= 2;
-+			buf[i] |= (regval & 1) | ((regval & BIT(9)) >> 8);
-+			udelay(1);
-+		}
-+	}
-+}
-+
- int ar5008_hw_attach_phy_ops(struct ath_hw *ah)
- {
- 	struct ath_hw_private_ops *priv_ops = ath9k_hw_private_ops(ah);
-+	struct ath_hw_ops *ops = ath9k_hw_ops(ah);
- 	static const u32 ar5416_cca_regs[6] = {
- 		AR_PHY_CCA,
- 		AR_PHY_CH1_CCA,
-@@ -1342,6 +1363,8 @@ int ar5008_hw_attach_phy_ops(struct ath_
- 	if (ret)
- 	    return ret;
- 
-+	ops->get_adc_entropy = ar5008_hw_get_adc_entropy;
-+
- 	priv_ops->rf_set_freq = ar5008_hw_set_channel;
- 	priv_ops->spur_mitigate_freq = ar5008_hw_spur_mitigate;
- 
---- a/drivers/net/wireless/ath/ath9k/ar9002_phy.h
-+++ b/drivers/net/wireless/ath/ath9k/ar9002_phy.h
-@@ -20,6 +20,12 @@
- #define PHY_AGC_CLR             0x10000000
- #define RFSILENT_BB             0x00002000
- 
-+#define AR_PHY_TEST_BBB_OBS_SEL       0x780000
-+#define AR_PHY_TEST_BBB_OBS_SEL_S     19
-+
-+#define AR_PHY_TEST_RX_OBS_SEL_BIT5_S 23
-+#define AR_PHY_TEST_RX_OBS_SEL_BIT5   (1 << AR_PHY_TEST_RX_OBS_SEL_BIT5_S)
-+
- #define AR_PHY_TURBO                0x9804
- #define AR_PHY_FC_TURBO_MODE        0x00000001
- #define AR_PHY_FC_TURBO_SHORT       0x00000002
-@@ -36,6 +42,9 @@
- 
- #define AR_PHY_TEST2			0x9808
- 
-+#define AR_PHY_TEST2_RX_OBS_SEL        0x3C00
-+#define AR_PHY_TEST2_RX_OBS_SEL_S      10
-+
- #define AR_PHY_TIMING2           0x9810
- #define AR_PHY_TIMING3           0x9814
- #define AR_PHY_TIMING3_DSC_MAN   0xFFFE0000
-@@ -390,6 +399,8 @@
- #define AR_PHY_RFBUS_GRANT       0x9C20
- #define AR_PHY_RFBUS_GRANT_EN    0x00000001
- 
-+#define AR_PHY_TST_ADC      0x9C24
-+
- #define AR_PHY_CHAN_INFO_GAIN_DIFF             0x9CF4
- #define AR_PHY_CHAN_INFO_GAIN_DIFF_UPPER_LIMIT 320
- 
diff --git a/package/kernel/mac80211/patches/544-ath9k-ar933x-usb-hang-workaround.patch b/package/kernel/mac80211/patches/544-ath9k-ar933x-usb-hang-workaround.patch
deleted file mode 100644
index 9462fca..0000000
--- a/package/kernel/mac80211/patches/544-ath9k-ar933x-usb-hang-workaround.patch
+++ /dev/null
@@ -1,79 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/hw.c
-+++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -246,6 +246,19 @@ void ath9k_hw_get_channel_centers(struct
- 		centers->synth_center + (extoff * HT40_CHANNEL_CENTER_SHIFT);
- }
- 
-+static inline void ath9k_hw_disable_pll_lock_detect(struct ath_hw *ah)
-+{
-+	/* On AR9330 and AR9340 devices, some PHY registers must be
-+	 * tuned to gain better stability/performance. These registers
-+	 * might be changed while doing wlan reset so the registers must
-+	 * be reprogrammed after each reset.
-+	 */
-+	REG_CLR_BIT(ah, AR_PHY_USB_CTRL1, BIT(20));
-+	REG_RMW(ah, AR_PHY_USB_CTRL2,
-+		(1 << 21) | (0xf << 22),
-+		(1 << 21) | (0x3 << 22));
-+}
-+
- /******************/
- /* Chip Revisions */
- /******************/
-@@ -1397,6 +1410,9 @@ static bool ath9k_hw_set_reset(struct at
- 	if (AR_SREV_9100(ah))
- 		udelay(50);
- 
-+	if (AR_SREV_9330(ah) || AR_SREV_9340(ah))
-+		ath9k_hw_disable_pll_lock_detect(ah);
-+
- 	return true;
- }
- 
-@@ -1496,6 +1512,9 @@ static bool ath9k_hw_chip_reset(struct a
- 		ar9003_hw_internal_regulator_apply(ah);
- 	ath9k_hw_init_pll(ah, chan);
- 
-+	if (AR_SREV_9330(ah) || AR_SREV_9340(ah))
-+		ath9k_hw_disable_pll_lock_detect(ah);
-+
- 	return true;
- }
- 
-@@ -1799,8 +1818,14 @@ static int ath9k_hw_do_fastcc(struct ath
- 	if (AR_SREV_9271(ah))
- 		ar9002_hw_load_ani_reg(ah, chan);
- 
-+	if (AR_SREV_9330(ah) || AR_SREV_9340(ah))
-+		ath9k_hw_disable_pll_lock_detect(ah);
-+
- 	return 0;
- fail:
-+	if (AR_SREV_9330(ah) || AR_SREV_9340(ah))
-+		ath9k_hw_disable_pll_lock_detect(ah);
-+
- 	return -EINVAL;
- }
- 
-@@ -2054,6 +2079,9 @@ int ath9k_hw_reset(struct ath_hw *ah, st
- 		ath9k_hw_set_radar_params(ah);
- 	}
- 
-+	if (AR_SREV_9330(ah) || AR_SREV_9340(ah))
-+		ath9k_hw_disable_pll_lock_detect(ah);
-+
- 	return 0;
- }
- EXPORT_SYMBOL(ath9k_hw_reset);
---- a/drivers/net/wireless/ath/ath9k/phy.h
-+++ b/drivers/net/wireless/ath/ath9k/phy.h
-@@ -48,6 +48,9 @@
- #define AR_PHY_PLL_CONTROL 0x16180
- #define AR_PHY_PLL_MODE 0x16184
- 
-+#define AR_PHY_USB_CTRL1	0x16c84
-+#define AR_PHY_USB_CTRL2	0x16c88
-+
- enum ath9k_ant_div_comb_lna_conf {
- 	ATH_ANT_DIV_COMB_LNA1_MINUS_LNA2,
- 	ATH_ANT_DIV_COMB_LNA2,
diff --git a/package/kernel/mac80211/patches/545-ath9k_ani_ws_detect.patch b/package/kernel/mac80211/patches/545-ath9k_ani_ws_detect.patch
deleted file mode 100644
index b639f97..0000000
--- a/package/kernel/mac80211/patches/545-ath9k_ani_ws_detect.patch
+++ /dev/null
@@ -1,155 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/ar5008_phy.c
-+++ b/drivers/net/wireless/ath/ath9k/ar5008_phy.c
-@@ -954,55 +954,6 @@ static bool ar5008_hw_ani_control_new(st
- 		 * on == 0 means more noise imm
- 		 */
- 		u32 on = param ? 1 : 0;
--		/*
--		 * make register setting for default
--		 * (weak sig detect ON) come from INI file
--		 */
--		int m1ThreshLow = on ?
--			aniState->iniDef.m1ThreshLow : m1ThreshLow_off;
--		int m2ThreshLow = on ?
--			aniState->iniDef.m2ThreshLow : m2ThreshLow_off;
--		int m1Thresh = on ?
--			aniState->iniDef.m1Thresh : m1Thresh_off;
--		int m2Thresh = on ?
--			aniState->iniDef.m2Thresh : m2Thresh_off;
--		int m2CountThr = on ?
--			aniState->iniDef.m2CountThr : m2CountThr_off;
--		int m2CountThrLow = on ?
--			aniState->iniDef.m2CountThrLow : m2CountThrLow_off;
--		int m1ThreshLowExt = on ?
--			aniState->iniDef.m1ThreshLowExt : m1ThreshLowExt_off;
--		int m2ThreshLowExt = on ?
--			aniState->iniDef.m2ThreshLowExt : m2ThreshLowExt_off;
--		int m1ThreshExt = on ?
--			aniState->iniDef.m1ThreshExt : m1ThreshExt_off;
--		int m2ThreshExt = on ?
--			aniState->iniDef.m2ThreshExt : m2ThreshExt_off;
--
--		REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW,
--			      AR_PHY_SFCORR_LOW_M1_THRESH_LOW,
--			      m1ThreshLow);
--		REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW,
--			      AR_PHY_SFCORR_LOW_M2_THRESH_LOW,
--			      m2ThreshLow);
--		REG_RMW_FIELD(ah, AR_PHY_SFCORR,
--			      AR_PHY_SFCORR_M1_THRESH, m1Thresh);
--		REG_RMW_FIELD(ah, AR_PHY_SFCORR,
--			      AR_PHY_SFCORR_M2_THRESH, m2Thresh);
--		REG_RMW_FIELD(ah, AR_PHY_SFCORR,
--			      AR_PHY_SFCORR_M2COUNT_THR, m2CountThr);
--		REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW,
--			      AR_PHY_SFCORR_LOW_M2COUNT_THR_LOW,
--			      m2CountThrLow);
--
--		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
--			      AR_PHY_SFCORR_EXT_M1_THRESH_LOW, m1ThreshLowExt);
--		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
--			      AR_PHY_SFCORR_EXT_M2_THRESH_LOW, m2ThreshLowExt);
--		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
--			      AR_PHY_SFCORR_EXT_M1_THRESH, m1ThreshExt);
--		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
--			      AR_PHY_SFCORR_EXT_M2_THRESH, m2ThreshExt);
- 
- 		if (on)
- 			REG_SET_BIT(ah, AR_PHY_SFCORR_LOW,
---- a/drivers/net/wireless/ath/ath9k/ar9003_phy.c
-+++ b/drivers/net/wireless/ath/ath9k/ar9003_phy.c
-@@ -42,20 +42,6 @@ static const int cycpwrThr1_table[] =
- /* level:  0   1   2   3   4   5   6   7   8  */
- 	{ -6, -4, -2,  0,  2,  4,  6,  8 };     /* lvl 0-7, default 3 */
- 
--/*
-- * register values to turn OFDM weak signal detection OFF
-- */
--static const int m1ThreshLow_off = 127;
--static const int m2ThreshLow_off = 127;
--static const int m1Thresh_off = 127;
--static const int m2Thresh_off = 127;
--static const int m2CountThr_off =  31;
--static const int m2CountThrLow_off =  63;
--static const int m1ThreshLowExt_off = 127;
--static const int m2ThreshLowExt_off = 127;
--static const int m1ThreshExt_off = 127;
--static const int m2ThreshExt_off = 127;
--
- static const u8 ofdm2pwr[] = {
- 	ALL_TARGET_LEGACY_6_24,
- 	ALL_TARGET_LEGACY_6_24,
-@@ -1095,11 +1081,6 @@ static bool ar9003_hw_ani_control(struct
- 	struct ath_common *common = ath9k_hw_common(ah);
- 	struct ath9k_channel *chan = ah->curchan;
- 	struct ar5416AniState *aniState = &ah->ani;
--	int m1ThreshLow, m2ThreshLow;
--	int m1Thresh, m2Thresh;
--	int m2CountThr, m2CountThrLow;
--	int m1ThreshLowExt, m2ThreshLowExt;
--	int m1ThreshExt, m2ThreshExt;
- 	s32 value, value2;
- 
- 	switch (cmd & ah->ani_function) {
-@@ -1113,61 +1094,6 @@ static bool ar9003_hw_ani_control(struct
- 		 */
- 		u32 on = param ? 1 : 0;
- 
--		if (AR_SREV_9462(ah) || AR_SREV_9565(ah))
--			goto skip_ws_det;
--
--		m1ThreshLow = on ?
--			aniState->iniDef.m1ThreshLow : m1ThreshLow_off;
--		m2ThreshLow = on ?
--			aniState->iniDef.m2ThreshLow : m2ThreshLow_off;
--		m1Thresh = on ?
--			aniState->iniDef.m1Thresh : m1Thresh_off;
--		m2Thresh = on ?
--			aniState->iniDef.m2Thresh : m2Thresh_off;
--		m2CountThr = on ?
--			aniState->iniDef.m2CountThr : m2CountThr_off;
--		m2CountThrLow = on ?
--			aniState->iniDef.m2CountThrLow : m2CountThrLow_off;
--		m1ThreshLowExt = on ?
--			aniState->iniDef.m1ThreshLowExt : m1ThreshLowExt_off;
--		m2ThreshLowExt = on ?
--			aniState->iniDef.m2ThreshLowExt : m2ThreshLowExt_off;
--		m1ThreshExt = on ?
--			aniState->iniDef.m1ThreshExt : m1ThreshExt_off;
--		m2ThreshExt = on ?
--			aniState->iniDef.m2ThreshExt : m2ThreshExt_off;
--
--		REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW,
--			      AR_PHY_SFCORR_LOW_M1_THRESH_LOW,
--			      m1ThreshLow);
--		REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW,
--			      AR_PHY_SFCORR_LOW_M2_THRESH_LOW,
--			      m2ThreshLow);
--		REG_RMW_FIELD(ah, AR_PHY_SFCORR,
--			      AR_PHY_SFCORR_M1_THRESH,
--			      m1Thresh);
--		REG_RMW_FIELD(ah, AR_PHY_SFCORR,
--			      AR_PHY_SFCORR_M2_THRESH,
--			      m2Thresh);
--		REG_RMW_FIELD(ah, AR_PHY_SFCORR,
--			      AR_PHY_SFCORR_M2COUNT_THR,
--			      m2CountThr);
--		REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW,
--			      AR_PHY_SFCORR_LOW_M2COUNT_THR_LOW,
--			      m2CountThrLow);
--		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
--			      AR_PHY_SFCORR_EXT_M1_THRESH_LOW,
--			      m1ThreshLowExt);
--		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
--			      AR_PHY_SFCORR_EXT_M2_THRESH_LOW,
--			      m2ThreshLowExt);
--		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
--			      AR_PHY_SFCORR_EXT_M1_THRESH,
--			      m1ThreshExt);
--		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
--			      AR_PHY_SFCORR_EXT_M2_THRESH,
--			      m2ThreshExt);
--skip_ws_det:
- 		if (on)
- 			REG_SET_BIT(ah, AR_PHY_SFCORR_LOW,
- 				    AR_PHY_SFCORR_LOW_USE_SELF_CORR_LOW);
diff --git a/package/kernel/mac80211/patches/546-ath9k_platform_led_name.patch b/package/kernel/mac80211/patches/546-ath9k_platform_led_name.patch
deleted file mode 100644
index ced72c6..0000000
--- a/package/kernel/mac80211/patches/546-ath9k_platform_led_name.patch
+++ /dev/null
@@ -1,39 +0,0 @@
-From: Michal Cieslakiewicz <michal.cieslakiewicz@wp.pl>
-Date: Sun, 31 Jan 2016 20:45:57 +0100
-Subject: [PATCH v4 1/8] mac80211: ath9k: enable platform WLAN LED name
-
-Enable platform-supplied WLAN LED name for ath9k device. It replaces generic
-'ath9k-phy*' label with string set during platform initialization.
-
-Signed-off-by: Michal Cieslakiewicz <michal.cieslakiewicz@wp.pl>
----
- drivers/net/wireless/ath/ath9k/gpio.c |   10 +++++++---
- include/linux/ath9k_platform.h        |    1 +
- 2 files changed, 8 insertions(+), 3 deletions(-)
-
---- a/drivers/net/wireless/ath/ath9k/gpio.c
-+++ b/drivers/net/wireless/ath/ath9k/gpio.c
-@@ -155,8 +155,11 @@ void ath_init_leds(struct ath_softc *sc)
- 
- 	ath_fill_led_pin(sc);
- 
--	snprintf(led_name, sizeof(led_name), "ath9k-%s",
--		 wiphy_name(sc->hw->wiphy));
-+	if (pdata && pdata->led_name)
-+		strncpy(led_name, pdata->led_name, sizeof(led_name));
-+	else
-+		snprintf(led_name, sizeof(led_name), "ath9k-%s",
-+			 wiphy_name(sc->hw->wiphy));
- 
- 	if (ath9k_led_blink)
- 		trigger = sc->led_default_trigger;
---- a/include/linux/ath9k_platform.h
-+++ b/include/linux/ath9k_platform.h
-@@ -49,6 +49,7 @@ struct ath9k_platform_data {
- 
- 	int num_leds;
- 	const struct gpio_led *leds;
-+	const char *led_name;
- };
- 
- #endif /* _LINUX_ATH9K_PLATFORM_H */
diff --git a/package/kernel/mac80211/patches/547-ath9k_led_defstate_fix.patch b/package/kernel/mac80211/patches/547-ath9k_led_defstate_fix.patch
deleted file mode 100644
index 5d84cf0..0000000
--- a/package/kernel/mac80211/patches/547-ath9k_led_defstate_fix.patch
+++ /dev/null
@@ -1,29 +0,0 @@
-From: Michal Cieslakiewicz <michal.cieslakiewicz@wp.pl>
-Date: Sun, 31 Jan 2016 20:48:49 +0100
-Subject: [PATCH v4 2/8] mac80211: ath9k: set default state for platform LEDs
-
-Support default state for platform LEDs connected to ath9k device.
-Now LEDs are correctly set on or off at ath9k module initialization.
-Very useful if power LED is connected to wireless chip.
-
-Signed-off-by: Michal Cieslakiewicz <michal.cieslakiewicz@wp.pl>
----
- gpio.c |    7 +++++--
- 1 file changed, 5 insertions(+), 2 deletions(-)
-
---- a/drivers/net/wireless/ath/ath9k/gpio.c
-+++ b/drivers/net/wireless/ath/ath9k/gpio.c
-@@ -74,8 +74,11 @@ static int ath_add_led(struct ath_softc
- 	ath9k_hw_gpio_request_out(sc->sc_ah, gpio->gpio, gpio->name,
- 				  AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
- 
--	/* LED off */
--	ath9k_hw_set_gpio(sc->sc_ah, gpio->gpio, gpio->active_low);
-+	/* Set default LED state */
-+	if (gpio->default_state == LEDS_GPIO_DEFSTATE_ON)
-+		ath9k_hw_set_gpio(sc->sc_ah, gpio->gpio, !gpio->active_low);
-+	else
-+		ath9k_hw_set_gpio(sc->sc_ah, gpio->gpio, gpio->active_low);
- 
- 	return 0;
- }
diff --git a/package/kernel/mac80211/patches/548-ath9k_enable_gpio_chip.patch b/package/kernel/mac80211/patches/548-ath9k_enable_gpio_chip.patch
deleted file mode 100644
index 1c89e42..0000000
--- a/package/kernel/mac80211/patches/548-ath9k_enable_gpio_chip.patch
+++ /dev/null
@@ -1,237 +0,0 @@
-From: Michal Cieslakiewicz <michal.cieslakiewicz@wp.pl>
-Date: Sun, 31 Jan 2016 21:01:31 +0100
-Subject: [PATCH v4 4/8] mac80211: ath9k: enable access to GPIO
-
-Enable access to GPIO chip and its pins for Atheros AR92xx
-wireless devices. For now AR9285 and AR9287 are supported.
-
-Signed-off-by: Michal Cieslakiewicz <michal.cieslakiewicz@wp.pl>
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
---- a/drivers/net/wireless/ath/ath9k/ath9k.h
-+++ b/drivers/net/wireless/ath/ath9k/ath9k.h
-@@ -24,6 +24,7 @@
- #include <linux/completion.h>
- #include <linux/time.h>
- #include <linux/hw_random.h>
-+#include <linux/gpio/driver.h>
- 
- #include "common.h"
- #include "debug.h"
-@@ -959,6 +960,14 @@ struct ath_led {
- 	struct led_classdev cdev;
- };
- 
-+#ifdef CONFIG_GPIOLIB
-+struct ath9k_gpio_chip {
-+	struct ath_softc *sc;
-+	char label[32];
-+	struct gpio_chip gchip;
-+};
-+#endif
-+
- struct ath_softc {
- 	struct ieee80211_hw *hw;
- 	struct device *dev;
-@@ -1013,6 +1022,9 @@ struct ath_softc {
- #ifdef CPTCFG_MAC80211_LEDS
- 	const char *led_default_trigger;
- 	struct list_head leds;
-+#ifdef CONFIG_GPIOLIB
-+	struct ath9k_gpio_chip *gpiochip;
-+#endif
- #endif
- 
- #ifdef CPTCFG_ATH9K_DEBUGFS
---- a/drivers/net/wireless/ath/ath9k/gpio.c
-+++ b/drivers/net/wireless/ath/ath9k/gpio.c
-@@ -16,13 +16,138 @@
- 
- #include "ath9k.h"
- #include <linux/ath9k_platform.h>
-+#include <linux/gpio.h>
-+
-+#ifdef CPTCFG_MAC80211_LEDS
-+
-+#ifdef CONFIG_GPIOLIB
-+
-+/***************/
-+/*  GPIO Chip  */
-+/***************/
-+
-+/* gpio_chip handler : set GPIO to input */
-+static int ath9k_gpio_pin_cfg_input(struct gpio_chip *chip, unsigned offset)
-+{
-+	struct ath9k_gpio_chip *gc = container_of(chip, struct ath9k_gpio_chip,
-+						  gchip);
-+
-+	ath9k_hw_gpio_request_in(gc->sc->sc_ah, offset, "ath9k-gpio");
-+
-+	return 0;
-+}
-+
-+/* gpio_chip handler : set GPIO to output */
-+static int ath9k_gpio_pin_cfg_output(struct gpio_chip *chip, unsigned offset,
-+				     int value)
-+{
-+	struct ath9k_gpio_chip *gc = container_of(chip, struct ath9k_gpio_chip,
-+						  gchip);
-+
-+	ath9k_hw_gpio_request_out(gc->sc->sc_ah, offset, "ath9k-gpio",
-+				  AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
-+	ath9k_hw_set_gpio(gc->sc->sc_ah, offset, value);
-+
-+	return 0;
-+}
-+
-+/* gpio_chip handler : query GPIO direction (0=out, 1=in) */
-+static int ath9k_gpio_pin_get_dir(struct gpio_chip *chip, unsigned offset)
-+{
-+	struct ath9k_gpio_chip *gc = container_of(chip, struct ath9k_gpio_chip,
-+						  gchip);
-+	struct ath_hw *ah = gc->sc->sc_ah;
-+
-+	return !((REG_READ(ah, AR_GPIO_OE_OUT) >> (offset * 2)) & 3);
-+}
-+
-+/* gpio_chip handler : get GPIO pin value */
-+static int ath9k_gpio_pin_get(struct gpio_chip *chip, unsigned offset)
-+{
-+	struct ath9k_gpio_chip *gc = container_of(chip, struct ath9k_gpio_chip,
-+						  gchip);
-+
-+	return ath9k_hw_gpio_get(gc->sc->sc_ah, offset);
-+}
-+
-+/* gpio_chip handler : set GPIO pin to value */
-+static void ath9k_gpio_pin_set(struct gpio_chip *chip, unsigned offset,
-+			       int value)
-+{
-+	struct ath9k_gpio_chip *gc = container_of(chip, struct ath9k_gpio_chip,
-+						  gchip);
-+
-+	ath9k_hw_set_gpio(gc->sc->sc_ah, offset, value);
-+}
-+
-+/* register GPIO chip */
-+static void ath9k_register_gpio_chip(struct ath_softc *sc)
-+{
-+	struct ath9k_gpio_chip *gc;
-+	u16 ng;
-+
-+	/* for now only AR9285 and AR9287 are recognized */
-+	if (AR_SREV_9287(sc->sc_ah))
-+		ng = AR9287_NUM_GPIO;
-+	else if (AR_SREV_9285(sc->sc_ah))
-+		ng = AR9285_NUM_GPIO;
-+	else
-+		return;
-+
-+	gc = kzalloc(sizeof(struct ath9k_gpio_chip), GFP_KERNEL);
-+	if (!gc)
-+		return;
-+
-+	snprintf(gc->label, sizeof(gc->label), "ath9k-%s",
-+		 wiphy_name(sc->hw->wiphy));
-+	gc->gchip.label = gc->label;
-+	gc->gchip.base = -1;	/* determine base automatically */
-+	gc->gchip.ngpio = ng;
-+	gc->gchip.direction_input = ath9k_gpio_pin_cfg_input;
-+	gc->gchip.direction_output = ath9k_gpio_pin_cfg_output;
-+	gc->gchip.get_direction = ath9k_gpio_pin_get_dir;
-+	gc->gchip.get = ath9k_gpio_pin_get;
-+	gc->gchip.set = ath9k_gpio_pin_set;
-+	gc->gchip.owner = THIS_MODULE;
-+
-+	if (gpiochip_add(&gc->gchip)) {
-+		kfree(gc);
-+		return;
-+	}
-+
-+	sc->gpiochip = gc;
-+	gc->sc = sc;
-+}
-+
-+/* remove GPIO chip */
-+static void ath9k_unregister_gpio_chip(struct ath_softc *sc)
-+{
-+	struct ath9k_gpio_chip *gc = sc->gpiochip;
-+
-+	if (!gc)
-+		return;
-+
-+	gpiochip_remove(&gc->gchip);
-+	kfree(gc);
-+	sc->gpiochip = NULL;
-+}
-+
-+#else /* CONFIG_GPIOLIB */
-+
-+static inline void ath9k_register_gpio_chip(struct ath_softc *sc)
-+{
-+}
-+
-+static inline void ath9k_unregister_gpio_chip(struct ath_softc *sc)
-+{
-+}
-+
-+#endif /* CONFIG_GPIOLIB */
- 
- /********************************/
- /*	 LED functions		*/
- /********************************/
- 
--#ifdef CPTCFG_MAC80211_LEDS
--
- static void ath_fill_led_pin(struct ath_softc *sc)
- {
- 	struct ath_hw *ah = sc->sc_ah;
-@@ -80,6 +205,12 @@ static int ath_add_led(struct ath_softc
- 	else
- 		ath9k_hw_set_gpio(sc->sc_ah, gpio->gpio, gpio->active_low);
- 
-+#ifdef CONFIG_GPIOLIB
-+	/* If there is GPIO chip configured, reserve LED pin */
-+	if (sc->gpiochip)
-+		gpio_request(sc->gpiochip->gchip.base + gpio->gpio, gpio->name);
-+#endif
-+
- 	return 0;
- }
- 
-@@ -136,12 +267,18 @@ void ath_deinit_leds(struct ath_softc *s
- 
- 	while (!list_empty(&sc->leds)) {
- 		led = list_first_entry(&sc->leds, struct ath_led, list);
-+#ifdef CONFIG_GPIOLIB
-+		/* If there is GPIO chip configured, free LED pin */
-+		if (sc->gpiochip)
-+			gpio_free(sc->gpiochip->gchip.base + led->gpio->gpio);
-+#endif
- 		list_del(&led->list);
- 		ath_led_brightness(&led->cdev, LED_OFF);
- 		led_classdev_unregister(&led->cdev);
- 		ath9k_hw_gpio_free(sc->sc_ah, led->gpio->gpio);
- 		kfree(led);
- 	}
-+	ath9k_unregister_gpio_chip(sc);
- }
- 
- void ath_init_leds(struct ath_softc *sc)
-@@ -158,6 +295,8 @@ void ath_init_leds(struct ath_softc *sc)
- 
- 	ath_fill_led_pin(sc);
- 
-+	ath9k_register_gpio_chip(sc);
-+
- 	if (pdata && pdata->led_name)
- 		strncpy(led_name, pdata->led_name, sizeof(led_name));
- 	else
-@@ -178,6 +317,7 @@ void ath_init_leds(struct ath_softc *sc)
- 	for (i = 0; i < pdata->num_leds; i++)
- 		ath_create_platform_led(sc, &pdata->leds[i]);
- }
-+
- #endif
- 
- /*******************/
diff --git a/package/kernel/mac80211/patches/549-ath9k_enable_gpio_buttons.patch b/package/kernel/mac80211/patches/549-ath9k_enable_gpio_buttons.patch
deleted file mode 100644
index c7973bb..0000000
--- a/package/kernel/mac80211/patches/549-ath9k_enable_gpio_buttons.patch
+++ /dev/null
@@ -1,149 +0,0 @@
-From: Michal Cieslakiewicz <michal.cieslakiewicz@wp.pl>
-Subject: [PATCH v5 5/8] mac80211: ath9k: enable GPIO buttons
-
-Enable platform-defined GPIO button support for ath9k device.
-Key poller is activated for attached platform buttons.
-Requires ath9k GPIO chip access.
-
-Signed-off-by: Michal Cieslakiewicz <michal.cieslakiewicz@wp.pl>
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
---- a/drivers/net/wireless/ath/ath9k/ath9k.h
-+++ b/drivers/net/wireless/ath/ath9k/ath9k.h
-@@ -1024,6 +1024,7 @@ struct ath_softc {
- 	struct list_head leds;
- #ifdef CONFIG_GPIOLIB
- 	struct ath9k_gpio_chip *gpiochip;
-+	struct platform_device *btnpdev;	/* gpio-keys-polled */
- #endif
- #endif
- 
---- a/drivers/net/wireless/ath/ath9k/gpio.c
-+++ b/drivers/net/wireless/ath/ath9k/gpio.c
-@@ -17,6 +17,8 @@
- #include "ath9k.h"
- #include <linux/ath9k_platform.h>
- #include <linux/gpio.h>
-+#include <linux/platform_device.h>
-+#include <linux/gpio_keys.h>
- 
- #ifdef CPTCFG_MAC80211_LEDS
- 
-@@ -132,6 +134,64 @@ static void ath9k_unregister_gpio_chip(s
- 	sc->gpiochip = NULL;
- }
- 
-+/******************/
-+/*  GPIO Buttons  */
-+/******************/
-+
-+/* add GPIO buttons */
-+static void ath9k_init_buttons(struct ath_softc *sc)
-+{
-+	struct ath9k_platform_data *pdata = sc->dev->platform_data;
-+	struct platform_device *pdev;
-+	struct gpio_keys_platform_data gkpdata;
-+	struct gpio_keys_button *bt;
-+	int i;
-+
-+	if (!sc->gpiochip)
-+		return;
-+
-+	if (!pdata || !pdata->btns || !pdata->num_btns)
-+		return;
-+
-+	bt = devm_kmemdup(sc->dev, pdata->btns,
-+			  pdata->num_btns * sizeof(struct gpio_keys_button),
-+			  GFP_KERNEL);
-+	if (!bt)
-+		return;
-+
-+	for (i = 0; i < pdata->num_btns; i++) {
-+		ath9k_hw_gpio_request_in(sc->sc_ah, pdata->btns[i].gpio,
-+					 "ath9k-gpio");
-+		bt[i].gpio = sc->gpiochip->gchip.base + pdata->btns[i].gpio;
-+	}
-+
-+	memset(&gkpdata, 0, sizeof(struct gpio_keys_platform_data));
-+	gkpdata.buttons = bt;
-+	gkpdata.nbuttons = pdata->num_btns;
-+	gkpdata.poll_interval = pdata->btn_poll_interval;
-+
-+	pdev = platform_device_register_data(sc->dev, "gpio-keys-polled",
-+					     PLATFORM_DEVID_AUTO, &gkpdata,
-+					     sizeof(gkpdata));
-+	if (!IS_ERR_OR_NULL(pdev))
-+		sc->btnpdev = pdev;
-+	else {
-+		sc->btnpdev = NULL;
-+		devm_kfree(sc->dev, bt);
-+	}
-+}
-+
-+/* remove GPIO buttons */
-+static void ath9k_deinit_buttons(struct ath_softc *sc)
-+{
-+	if (!sc->gpiochip || !sc->btnpdev)
-+		return;
-+
-+	platform_device_unregister(sc->btnpdev);
-+
-+	sc->btnpdev = NULL;
-+}
-+
- #else /* CONFIG_GPIOLIB */
- 
- static inline void ath9k_register_gpio_chip(struct ath_softc *sc)
-@@ -142,6 +202,14 @@ static inline void ath9k_unregister_gpio
- {
- }
- 
-+static inline void ath9k_init_buttons(struct ath_softc *sc)
-+{
-+}
-+
-+static inline void ath9k_deinit_buttons(struct ath_softc *sc)
-+{
-+}
-+
- #endif /* CONFIG_GPIOLIB */
- 
- /********************************/
-@@ -265,6 +333,7 @@ void ath_deinit_leds(struct ath_softc *s
- {
- 	struct ath_led *led;
- 
-+	ath9k_deinit_buttons(sc);
- 	while (!list_empty(&sc->leds)) {
- 		led = list_first_entry(&sc->leds, struct ath_led, list);
- #ifdef CONFIG_GPIOLIB
-@@ -296,6 +365,7 @@ void ath_init_leds(struct ath_softc *sc)
- 	ath_fill_led_pin(sc);
- 
- 	ath9k_register_gpio_chip(sc);
-+	ath9k_init_buttons(sc);
- 
- 	if (pdata && pdata->led_name)
- 		strncpy(led_name, pdata->led_name, sizeof(led_name));
-@@ -311,7 +381,7 @@ void ath_init_leds(struct ath_softc *sc)
- 	ath_create_gpio_led(sc, sc->sc_ah->led_pin, led_name, trigger,
- 			   !sc->sc_ah->config.led_active_high);
- 
--	if (!pdata)
-+	if (!pdata || !pdata->leds || !pdata->num_leds)
- 		return;
- 
- 	for (i = 0; i < pdata->num_leds; i++)
---- a/include/linux/ath9k_platform.h
-+++ b/include/linux/ath9k_platform.h
-@@ -50,6 +50,10 @@ struct ath9k_platform_data {
- 	int num_leds;
- 	const struct gpio_led *leds;
- 	const char *led_name;
-+
-+	unsigned num_btns;
-+	const struct gpio_keys_button *btns;
-+	unsigned btn_poll_interval;
- };
- 
- #endif /* _LINUX_ATH9K_PLATFORM_H */
diff --git a/package/kernel/mac80211/patches/550-ath9k_add_ar9280_gpio_chip.patch b/package/kernel/mac80211/patches/550-ath9k_add_ar9280_gpio_chip.patch
deleted file mode 100644
index 22e2c66..0000000
--- a/package/kernel/mac80211/patches/550-ath9k_add_ar9280_gpio_chip.patch
+++ /dev/null
@@ -1,27 +0,0 @@
-From: Michal Cieslakiewicz <michal.cieslakiewicz@wp.pl>
-Date: Thu, 21 Apr 2016 23:00:54 +0200
-Subject: [PATCH] mac80211: ath9k: add GPIO support for AR9280 chip
-
-Enable access to GPIO on Atheros wireless chip AR9280.
-Support for 9280 is added to existing 9285/9287 subsystem
-because these 3 chips differ only in number of GPIO pins.
-
-Signed-off-by: Michal Cieslakiewicz <michal.cieslakiewicz@wp.pl>
----
---- a/drivers/net/wireless/ath/ath9k/gpio.c
-+++ b/drivers/net/wireless/ath/ath9k/gpio.c
-@@ -88,11 +88,13 @@ static void ath9k_register_gpio_chip(str
- 	struct ath9k_gpio_chip *gc;
- 	u16 ng;
- 
--	/* for now only AR9285 and AR9287 are recognized */
-+	/* supported chips are AR9280, AR9285 and AR9287 */
- 	if (AR_SREV_9287(sc->sc_ah))
- 		ng = AR9287_NUM_GPIO;
- 	else if (AR_SREV_9285(sc->sc_ah))
- 		ng = AR9285_NUM_GPIO;
-+	else if (AR_SREV_9280(sc->sc_ah))
-+		ng = AR9280_NUM_GPIO;
- 	else
- 		return;
- 
diff --git a/package/kernel/mac80211/patches/600-0001-rt2x00-rt2800lib-move-rt2800_drv_data-declaration-in.patch b/package/kernel/mac80211/patches/600-0001-rt2x00-rt2800lib-move-rt2800_drv_data-declaration-in.patch
deleted file mode 100644
index bd81555..0000000
--- a/package/kernel/mac80211/patches/600-0001-rt2x00-rt2800lib-move-rt2800_drv_data-declaration-in.patch
+++ /dev/null
@@ -1,66 +0,0 @@
-From 7a69da907de668fb22a30ae218062d6f081864ea Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Sat, 17 Aug 2013 19:31:41 +0200
-Subject: [PATCH] rt2x00: rt2800lib: move rt2800_drv_data declaration into
- rt2800lib.h
-
-The rt2800_drv_data structure contains driver specific
-information. Move the declaration into the rt2800lib.h
-header which is a more logical place for it. Also fix
-the comment style to avoid checkpatch warning.
-
-The patch contains no functional changes, it is in
-preparation for the next patch.
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
-Changes since v1: ---
----
- drivers/net/wireless/ralink/rt2x00/rt2800.h    |   13 -------------
- drivers/net/wireless/ralink/rt2x00/rt2800lib.h |   11 +++++++++++
- 2 files changed, 11 insertions(+), 13 deletions(-)
-
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
-@@ -20,6 +20,20 @@
- #ifndef RT2800LIB_H
- #define RT2800LIB_H
- 
-+#include "rt2800.h"
-+
-+/* RT2800 driver data structure */
-+struct rt2800_drv_data {
-+	u8 calibration_bw20;
-+	u8 calibration_bw40;
-+	u8 bbp25;
-+	u8 bbp26;
-+	u8 txmixer_gain_24g;
-+	u8 txmixer_gain_5g;
-+	unsigned int tbtt_tick;
-+	DECLARE_BITMAP(sta_ids, STA_IDS_SIZE);
-+};
-+
- struct rt2800_ops {
- 	void (*register_read)(struct rt2x00_dev *rt2x00dev,
- 			      const unsigned int offset, u32 *value);
---- a/drivers/net/wireless/ralink/rt2x00/rt2800.h
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800.h
-@@ -2969,18 +2969,4 @@ enum rt2800_eeprom_word {
- #define WCID_END	222
- #define STA_IDS_SIZE	(WCID_END - WCID_START + 2)
- 
--/*
-- * RT2800 driver data structure
-- */
--struct rt2800_drv_data {
--	u8 calibration_bw20;
--	u8 calibration_bw40;
--	u8 bbp25;
--	u8 bbp26;
--	u8 txmixer_gain_24g;
--	u8 txmixer_gain_5g;
--	unsigned int tbtt_tick;
--	DECLARE_BITMAP(sta_ids, STA_IDS_SIZE);
--};
--
- #endif /* RT2800_H */
diff --git a/package/kernel/mac80211/patches/600-0002-rt2x00-rt2800lib-introduce-RT2800_HAS_HIGH_SHARED_ME.patch b/package/kernel/mac80211/patches/600-0002-rt2x00-rt2800lib-introduce-RT2800_HAS_HIGH_SHARED_ME.patch
deleted file mode 100644
index db70a33..0000000
--- a/package/kernel/mac80211/patches/600-0002-rt2x00-rt2800lib-introduce-RT2800_HAS_HIGH_SHARED_ME.patch
+++ /dev/null
@@ -1,80 +0,0 @@
-From a7f268af31dddf763fe3dbe9cbf96ea77e0540e0 Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Sat, 17 Aug 2013 19:31:41 +0200
-Subject: [PATCH] rt2x00: rt2800lib: introduce RT2800_HAS_HIGH_SHARED_MEM flag
-
-Some chipsets have more than 16KB of shared memory.
-Introduce a new rt2800 specific flag to indicate that
-and add a helper function which helps to check the
-presence of the new flag.
-
-Also enable the new flag for the RT3593 chipset which
-has 24KB of shared memory. The flag can also be used
-for other chipsets, but none of those has been tested
-yet.
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
-Changes since v1:
-  - don't enable the new flag for RT3071 and RT5592
----
- drivers/net/wireless/ralink/rt2x00/rt2800lib.c |    4 ++++
- drivers/net/wireless/ralink/rt2x00/rt2800lib.h |   13 +++++++++++++
- 2 files changed, 17 insertions(+)
-
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -7726,6 +7726,7 @@ static int rt2800_probe_rt(struct rt2x00
- 
- int rt2800_probe_hw(struct rt2x00_dev *rt2x00dev)
- {
-+	struct rt2800_drv_data *drv_data = rt2x00dev->drv_data;
- 	int retval;
- 	u32 reg;
- 
-@@ -7733,6 +7734,9 @@ int rt2800_probe_hw(struct rt2x00_dev *r
- 	if (retval)
- 		return retval;
- 
-+	if (rt2x00_rt(rt2x00dev, RT3593))
-+		__set_bit(RT2800_HAS_HIGH_SHARED_MEM, &drv_data->rt2800_flags);
-+
- 	/*
- 	 * Allocate eeprom data.
- 	 */
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
-@@ -22,6 +22,10 @@
- 
- #include "rt2800.h"
- 
-+enum rt2800_flag {
-+	RT2800_HAS_HIGH_SHARED_MEM,
-+};
-+
- /* RT2800 driver data structure */
- struct rt2800_drv_data {
- 	u8 calibration_bw20;
-@@ -32,6 +36,8 @@ struct rt2800_drv_data {
- 	u8 txmixer_gain_5g;
- 	unsigned int tbtt_tick;
- 	DECLARE_BITMAP(sta_ids, STA_IDS_SIZE);
-+
-+	unsigned long rt2800_flags;
- };
- 
- struct rt2800_ops {
-@@ -64,6 +70,13 @@ struct rt2800_ops {
- 	__le32 *(*drv_get_txwi)(struct queue_entry *entry);
- };
- 
-+static inline bool rt2800_has_high_shared_mem(struct rt2x00_dev *rt2x00dev)
-+{
-+	struct rt2800_drv_data *drv_data = rt2x00dev->drv_data;
-+
-+	return test_bit(RT2800_HAS_HIGH_SHARED_MEM, &drv_data->rt2800_flags);
-+}
-+
- static inline void rt2800_register_read(struct rt2x00_dev *rt2x00dev,
- 					const unsigned int offset,
- 					u32 *value)
diff --git a/package/kernel/mac80211/patches/600-0003-rt2x00-rt2800-serialize-shared-memory-access.patch b/package/kernel/mac80211/patches/600-0003-rt2x00-rt2800-serialize-shared-memory-access.patch
deleted file mode 100644
index a3b62bc..0000000
--- a/package/kernel/mac80211/patches/600-0003-rt2x00-rt2800-serialize-shared-memory-access.patch
+++ /dev/null
@@ -1,531 +0,0 @@
-From 250a1b520cd7fdc0df4fc3fedea9066913f49ecf Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Sat, 17 Aug 2013 19:31:42 +0200
-Subject: [PATCH] rt2x00: rt2800: serialize shared memory access
-
-The shared memory of the rt2800 devices is accessible
-through the register offset range between 0x4000 and
-0x8000. The size of this range is 16KB only and on
-devices which have more than 16KB of shared memory either
-the low or the high part of the memory is accessible at a
-time.
-
-Serialize all accesses to the shared memory by a mutex,
-in order to avoid concurrent use of that.
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
-Changes since v1: ---
----
- drivers/net/wireless/ralink/rt2x00/rt2800lib.c  |   55 +++++++++++++++++++++++++++++-
- drivers/net/wireless/ralink/rt2x00/rt2800lib.h  |   32 +++++++++++++++++
- drivers/net/wireless/ralink/rt2x00/rt2800mmio.c |   26 ++++++++++++++
- drivers/net/wireless/ralink/rt2x00/rt2800mmio.h |    4 +++
- drivers/net/wireless/ralink/rt2x00/rt2800pci.c  |   14 ++++++++
- drivers/net/wireless/ralink/rt2x00/rt2800soc.c  |    3 ++
- drivers/net/wireless/ralink/rt2x00/rt2800usb.c  |   31 +++++++++++++++++
- 7 files changed, 164 insertions(+), 1 deletion(-)
-
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -451,11 +451,13 @@ void rt2800_mcu_request(struct rt2x00_de
- 		rt2x00_set_field32(&reg, H2M_MAILBOX_CSR_CMD_TOKEN, token);
- 		rt2x00_set_field32(&reg, H2M_MAILBOX_CSR_ARG0, arg0);
- 		rt2x00_set_field32(&reg, H2M_MAILBOX_CSR_ARG1, arg1);
-+		rt2800_shared_mem_lock(rt2x00dev);
- 		rt2800_register_write_lock(rt2x00dev, H2M_MAILBOX_CSR, reg);
- 
- 		reg = 0;
- 		rt2x00_set_field32(&reg, HOST_CMD_CSR_HOST_COMMAND, command);
- 		rt2800_register_write_lock(rt2x00dev, HOST_CMD_CSR, reg);
-+		rt2800_shared_mem_unlock(rt2x00dev);
- 	}
- 
- 	mutex_unlock(&rt2x00dev->csr_mutex);
-@@ -674,7 +676,9 @@ int rt2800_load_firmware(struct rt2x00_d
- 	 * Wait for device to stabilize.
- 	 */
- 	for (i = 0; i < REGISTER_BUSY_COUNT; i++) {
-+		rt2800_shared_mem_lock(rt2x00dev);
- 		rt2800_register_read(rt2x00dev, PBF_SYS_CTRL, &reg);
-+		rt2800_shared_mem_unlock(rt2x00dev);
- 		if (rt2x00_get_field32(reg, PBF_SYS_CTRL_READY))
- 			break;
- 		msleep(1);
-@@ -694,10 +698,16 @@ int rt2800_load_firmware(struct rt2x00_d
- 	/*
- 	 * Initialize firmware.
- 	 */
-+	rt2800_shared_mem_lock(rt2x00dev);
- 	rt2800_register_write(rt2x00dev, H2M_BBP_AGENT, 0);
- 	rt2800_register_write(rt2x00dev, H2M_MAILBOX_CSR, 0);
-+	rt2800_shared_mem_unlock(rt2x00dev);
-+
- 	if (rt2x00_is_usb(rt2x00dev)) {
-+		rt2800_shared_mem_lock(rt2x00dev);
- 		rt2800_register_write(rt2x00dev, H2M_INT_SRC, 0);
-+		rt2800_shared_mem_unlock(rt2x00dev);
-+
- 		rt2800_mcu_request(rt2x00dev, MCU_BOOT_SIGNAL, 0, 0, 0);
- 	}
- 	msleep(1);
-@@ -1035,8 +1045,10 @@ void rt2800_write_beacon(struct queue_en
- 
- 	beacon_base = rt2800_hw_beacon_base(rt2x00dev, entry->entry_idx);
- 
-+	rt2800_shared_mem_lock(rt2x00dev);
- 	rt2800_register_multiwrite(rt2x00dev, beacon_base, entry->skb->data,
- 				   entry->skb->len + padding_len);
-+	rt2800_shared_mem_unlock(rt2x00dev);
- 	__set_bit(ENTRY_BCN_ENABLED, &entry->flags);
- 
- 	/*
-@@ -1066,6 +1078,8 @@ static inline void rt2800_clear_beacon_r
- 
- 	beacon_base = rt2800_hw_beacon_base(rt2x00dev, index);
- 
-+	rt2800_shared_mem_lock(rt2x00dev);
-+
- 	/*
- 	 * For the Beacon base registers we only need to clear
- 	 * the whole TXWI which (when set to 0) will invalidate
-@@ -1073,6 +1087,8 @@ static inline void rt2800_clear_beacon_r
- 	 */
- 	for (i = 0; i < txwi_desc_size; i += sizeof(__le32))
- 		rt2800_register_write(rt2x00dev, beacon_base + i, 0);
-+
-+	rt2800_shared_mem_unlock(rt2x00dev);
- }
- 
- void rt2800_clear_beacon(struct queue_entry *entry)
-@@ -1261,7 +1277,9 @@ static void rt2800_delete_wcid_attr(stru
- {
- 	u32 offset;
- 	offset = MAC_WCID_ATTR_ENTRY(wcid);
-+	rt2800_shared_mem_lock(rt2x00dev);
- 	rt2800_register_write(rt2x00dev, offset, 0);
-+	rt2800_shared_mem_unlock(rt2x00dev);
- }
- 
- static void rt2800_config_wcid_attr_bssidx(struct rt2x00_dev *rt2x00dev,
-@@ -1274,11 +1292,13 @@ static void rt2800_config_wcid_attr_bssi
- 	 * The BSS Idx numbers is split in a main value of 3 bits,
- 	 * and a extended field for adding one additional bit to the value.
- 	 */
-+	rt2800_shared_mem_lock(rt2x00dev);
- 	rt2800_register_read(rt2x00dev, offset, &reg);
- 	rt2x00_set_field32(&reg, MAC_WCID_ATTRIBUTE_BSS_IDX, (bssidx & 0x7));
- 	rt2x00_set_field32(&reg, MAC_WCID_ATTRIBUTE_BSS_IDX_EXT,
- 			   (bssidx & 0x8) >> 3);
- 	rt2800_register_write(rt2x00dev, offset, reg);
-+	rt2800_shared_mem_unlock(rt2x00dev);
- }
- 
- static void rt2800_config_wcid_attr_cipher(struct rt2x00_dev *rt2x00dev,
-@@ -1291,6 +1311,7 @@ static void rt2800_config_wcid_attr_ciph
- 
- 	offset = MAC_WCID_ATTR_ENTRY(key->hw_key_idx);
- 
-+	rt2800_shared_mem_lock(rt2x00dev);
- 	if (crypto->cmd == SET_KEY) {
- 		rt2800_register_read(rt2x00dev, offset, &reg);
- 		rt2x00_set_field32(&reg, MAC_WCID_ATTRIBUTE_KEYTAB,
-@@ -1315,6 +1336,7 @@ static void rt2800_config_wcid_attr_ciph
- 		rt2x00_set_field32(&reg, MAC_WCID_ATTRIBUTE_RX_WIUDF, 0);
- 		rt2800_register_write(rt2x00dev, offset, reg);
- 	}
-+	rt2800_shared_mem_unlock(rt2x00dev);
- 
- 	offset = MAC_IVEIV_ENTRY(key->hw_key_idx);
- 
-@@ -1324,8 +1346,11 @@ static void rt2800_config_wcid_attr_ciph
- 	    (crypto->cipher == CIPHER_AES))
- 		iveiv_entry.iv[3] |= 0x20;
- 	iveiv_entry.iv[3] |= key->keyidx << 6;
-+
-+	rt2800_shared_mem_lock(rt2x00dev);
- 	rt2800_register_multiwrite(rt2x00dev, offset,
- 				      &iveiv_entry, sizeof(iveiv_entry));
-+	rt2800_shared_mem_unlock(rt2x00dev);
- }
- 
- int rt2800_config_shared_key(struct rt2x00_dev *rt2x00dev,
-@@ -1348,8 +1373,11 @@ int rt2800_config_shared_key(struct rt2x
- 		       sizeof(key_entry.rx_mic));
- 
- 		offset = SHARED_KEY_ENTRY(key->hw_key_idx);
-+
-+		rt2800_shared_mem_lock(rt2x00dev);
- 		rt2800_register_multiwrite(rt2x00dev, offset,
- 					      &key_entry, sizeof(key_entry));
-+		rt2800_shared_mem_unlock(rt2x00dev);
- 	}
- 
- 	/*
-@@ -1364,10 +1392,12 @@ int rt2800_config_shared_key(struct rt2x
- 
- 	offset = SHARED_KEY_MODE_ENTRY(key->hw_key_idx / 8);
- 
-+	rt2800_shared_mem_lock(rt2x00dev);
- 	rt2800_register_read(rt2x00dev, offset, &reg);
- 	rt2x00_set_field32(&reg, field,
- 			   (crypto->cmd == SET_KEY) * crypto->cipher);
- 	rt2800_register_write(rt2x00dev, offset, reg);
-+	rt2800_shared_mem_unlock(rt2x00dev);
- 
- 	/*
- 	 * Update WCID information
-@@ -1405,8 +1435,11 @@ int rt2800_config_pairwise_key(struct rt
- 		       sizeof(key_entry.rx_mic));
- 
- 		offset = PAIRWISE_KEY_ENTRY(key->hw_key_idx);
-+
-+		rt2800_shared_mem_lock(rt2x00dev);
- 		rt2800_register_multiwrite(rt2x00dev, offset,
- 					      &key_entry, sizeof(key_entry));
-+		rt2800_shared_mem_unlock(rt2x00dev);
- 	}
- 
- 	/*
-@@ -4885,14 +4918,19 @@ static int rt2800_init_registers(struct
- 	/*
- 	 * ASIC will keep garbage value after boot, clear encryption keys.
- 	 */
-+	rt2800_shared_mem_lock(rt2x00dev);
- 	for (i = 0; i < 4; i++)
- 		rt2800_register_write(rt2x00dev,
- 					 SHARED_KEY_MODE_ENTRY(i), 0);
-+	rt2800_shared_mem_unlock(rt2x00dev);
- 
- 	for (i = 0; i < 256; i++) {
- 		rt2800_config_wcid(rt2x00dev, NULL, i);
- 		rt2800_delete_wcid_attr(rt2x00dev, i);
-+
-+		rt2800_shared_mem_lock(rt2x00dev);
- 		rt2800_register_write(rt2x00dev, MAC_IVEIV_ENTRY(i), 0);
-+		rt2800_shared_mem_unlock(rt2x00dev);
- 	}
- 
- 	/*
-@@ -5018,8 +5056,10 @@ static int rt2800_wait_bbp_ready(struct
- 	 * BBP was enabled after firmware was loaded,
- 	 * but we need to reactivate it now.
- 	 */
-+	rt2800_shared_mem_lock(rt2x00dev);
- 	rt2800_register_write(rt2x00dev, H2M_BBP_AGENT, 0);
- 	rt2800_register_write(rt2x00dev, H2M_MAILBOX_CSR, 0);
-+	rt2800_shared_mem_unlock(rt2x00dev);
- 	msleep(1);
- 
- 	for (i = 0; i < REGISTER_BUSY_COUNT; i++) {
-@@ -6715,11 +6755,19 @@ int rt2800_enable_radio(struct rt2x00_de
- 	/*
- 	 * Send signal during boot time to initialize firmware.
- 	 */
-+	rt2800_shared_mem_lock(rt2x00dev);
- 	rt2800_register_write(rt2x00dev, H2M_BBP_AGENT, 0);
- 	rt2800_register_write(rt2x00dev, H2M_MAILBOX_CSR, 0);
--	if (rt2x00_is_usb(rt2x00dev))
-+	rt2800_shared_mem_unlock(rt2x00dev);
-+
-+	if (rt2x00_is_usb(rt2x00dev)) {
-+		rt2800_shared_mem_lock(rt2x00dev);
- 		rt2800_register_write(rt2x00dev, H2M_INT_SRC, 0);
-+		rt2800_shared_mem_unlock(rt2x00dev);
-+	}
-+
- 	rt2800_mcu_request(rt2x00dev, MCU_BOOT_SIGNAL, 0, 0, 0);
-+
- 	msleep(1);
- 
- 	/*
-@@ -7730,6 +7778,8 @@ int rt2800_probe_hw(struct rt2x00_dev *r
- 	int retval;
- 	u32 reg;
- 
-+	rt2800_shared_mem_init_lock(rt2x00dev);
-+
- 	retval = rt2800_probe_rt(rt2x00dev);
- 	if (retval)
- 		return retval;
-@@ -7813,8 +7863,11 @@ void rt2800_get_key_seq(struct ieee80211
- 		return;
- 
- 	offset = MAC_IVEIV_ENTRY(key->hw_key_idx);
-+
-+	rt2800_shared_mem_lock(rt2x00dev);
- 	rt2800_register_multiread(rt2x00dev, offset,
- 				      &iveiv_entry, sizeof(iveiv_entry));
-+	rt2800_shared_mem_unlock(rt2x00dev);
- 
- 	memcpy(&seq->tkip.iv16, &iveiv_entry.iv[0], 2);
- 	memcpy(&seq->tkip.iv32, &iveiv_entry.iv[4], 4);
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
-@@ -38,6 +38,11 @@ struct rt2800_drv_data {
- 	DECLARE_BITMAP(sta_ids, STA_IDS_SIZE);
- 
- 	unsigned long rt2800_flags;
-+
-+	union {
-+		spinlock_t spin;
-+		struct mutex mutex;
-+	} shmem_lock;
- };
- 
- struct rt2800_ops {
-@@ -68,6 +73,10 @@ struct rt2800_ops {
- 				  const u8 *data, const size_t len);
- 	int (*drv_init_registers)(struct rt2x00_dev *rt2x00dev);
- 	__le32 *(*drv_get_txwi)(struct queue_entry *entry);
-+
-+	void (*shmem_init_lock)(struct rt2x00_dev *rt2x00dev);
-+	void (*shmem_lock)(struct rt2x00_dev *rt2x00dev);
-+	void (*shmem_unlock)(struct rt2x00_dev *rt2x00dev);
- };
- 
- static inline bool rt2800_has_high_shared_mem(struct rt2x00_dev *rt2x00dev)
-@@ -77,6 +86,29 @@ static inline bool rt2800_has_high_share
- 	return test_bit(RT2800_HAS_HIGH_SHARED_MEM, &drv_data->rt2800_flags);
- }
- 
-+static inline void rt2800_shared_mem_init_lock(struct rt2x00_dev *rt2x00dev)
-+{
-+	const struct rt2800_ops *rt2800ops = rt2x00dev->ops->drv;
-+
-+	rt2800ops->shmem_init_lock(rt2x00dev);
-+}
-+
-+static inline void rt2800_shared_mem_lock(struct rt2x00_dev *rt2x00dev)
-+{
-+	const struct rt2800_ops *rt2800ops = rt2x00dev->ops->drv;
-+
-+	if (rt2800_has_high_shared_mem(rt2x00dev))
-+		rt2800ops->shmem_lock(rt2x00dev);
-+}
-+
-+static inline void rt2800_shared_mem_unlock(struct rt2x00_dev *rt2x00dev)
-+{
-+	const struct rt2800_ops *rt2800ops = rt2x00dev->ops->drv;
-+
-+	if (rt2800_has_high_shared_mem(rt2x00dev))
-+		rt2800ops->shmem_unlock(rt2x00dev);
-+}
-+
- static inline void rt2800_register_read(struct rt2x00_dev *rt2x00dev,
- 					const unsigned int offset,
- 					u32 *value)
---- a/drivers/net/wireless/ralink/rt2x00/rt2800mmio.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800mmio.c
-@@ -820,8 +820,10 @@ int rt2800mmio_init_registers(struct rt2
- 	rt2x00_set_field32(&reg, WPDMA_RST_IDX_DRX_IDX0, 1);
- 	rt2x00mmio_register_write(rt2x00dev, WPDMA_RST_IDX, reg);
- 
-+	rt2800_shared_mem_lock(rt2x00dev);
- 	rt2x00mmio_register_write(rt2x00dev, PBF_SYS_CTRL, 0x00000e1f);
- 	rt2x00mmio_register_write(rt2x00dev, PBF_SYS_CTRL, 0x00000e00);
-+	rt2800_shared_mem_unlock(rt2x00dev);
- 
- 	if (rt2x00_is_pcie(rt2x00dev) &&
- 	    (rt2x00_rt(rt2x00dev, RT3090) ||
-@@ -865,6 +867,30 @@ int rt2800mmio_enable_radio(struct rt2x0
- }
- EXPORT_SYMBOL_GPL(rt2800mmio_enable_radio);
- 
-+void rt2800mmio_shmem_init_lock(struct rt2x00_dev *rt2x00dev)
-+{
-+	struct rt2800_drv_data *drv_data = rt2x00dev->drv_data;
-+
-+	spin_lock_init(&drv_data->shmem_lock.spin);
-+}
-+EXPORT_SYMBOL_GPL(rt2800mmio_shmem_init_lock);
-+
-+void rt2800mmio_shmem_lock(struct rt2x00_dev *rt2x00dev)
-+{
-+	struct rt2800_drv_data *drv_data = rt2x00dev->drv_data;
-+
-+	spin_lock_bh(&drv_data->shmem_lock.spin);
-+}
-+EXPORT_SYMBOL_GPL(rt2800mmio_shmem_lock);
-+
-+void rt2800mmio_shmem_unlock(struct rt2x00_dev *rt2x00dev)
-+{
-+	struct rt2800_drv_data *drv_data = rt2x00dev->drv_data;
-+
-+	spin_unlock_bh(&drv_data->shmem_lock.spin);
-+}
-+EXPORT_SYMBOL_GPL(rt2800mmio_shmem_unlock);
-+
- MODULE_AUTHOR(DRV_PROJECT);
- MODULE_VERSION(DRV_VERSION);
- MODULE_DESCRIPTION("rt2800 MMIO library");
---- a/drivers/net/wireless/ralink/rt2x00/rt2800mmio.h
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800mmio.h
-@@ -160,4 +160,8 @@ int rt2800mmio_init_registers(struct rt2
- /* Device state switch handlers. */
- int rt2800mmio_enable_radio(struct rt2x00_dev *rt2x00dev);
- 
-+void rt2800mmio_shmem_init_lock(struct rt2x00_dev *rt2x00dev);
-+void rt2800mmio_shmem_lock(struct rt2x00_dev *rt2x00dev);
-+void rt2800mmio_shmem_unlock(struct rt2x00_dev *rt2x00dev);
-+
- #endif /* RT2800MMIO_H */
---- a/drivers/net/wireless/ralink/rt2x00/rt2800pci.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800pci.c
-@@ -69,7 +69,9 @@ static void rt2800pci_mcu_status(struct
- 		return;
- 
- 	for (i = 0; i < 200; i++) {
-+		rt2800_shared_mem_lock(rt2x00dev);
- 		rt2x00mmio_register_read(rt2x00dev, H2M_MAILBOX_CID, &reg);
-+		rt2800_shared_mem_unlock(rt2x00dev);
- 
- 		if ((rt2x00_get_field32(reg, H2M_MAILBOX_CID_CMD0) == token) ||
- 		    (rt2x00_get_field32(reg, H2M_MAILBOX_CID_CMD1) == token) ||
-@@ -83,8 +85,10 @@ static void rt2800pci_mcu_status(struct
- 	if (i == 200)
- 		rt2x00_err(rt2x00dev, "MCU request failed, no response from hardware\n");
- 
-+	rt2800_shared_mem_lock(rt2x00dev);
- 	rt2x00mmio_register_write(rt2x00dev, H2M_MAILBOX_STATUS, ~0);
- 	rt2x00mmio_register_write(rt2x00dev, H2M_MAILBOX_CID, ~0);
-+	rt2800_shared_mem_unlock(rt2x00dev);
- }
- 
- static void rt2800pci_eepromregister_read(struct eeprom_93cx6 *eeprom)
-@@ -184,6 +188,8 @@ static int rt2800pci_write_firmware(stru
- 	 */
- 	reg = 0;
- 	rt2x00_set_field32(&reg, PBF_SYS_CTRL_HOST_RAM_WRITE, 1);
-+
-+	rt2800_shared_mem_lock(rt2x00dev);
- 	rt2x00mmio_register_write(rt2x00dev, PBF_SYS_CTRL, reg);
- 
- 	/*
-@@ -197,6 +203,7 @@ static int rt2800pci_write_firmware(stru
- 
- 	rt2x00mmio_register_write(rt2x00dev, H2M_BBP_AGENT, 0);
- 	rt2x00mmio_register_write(rt2x00dev, H2M_MAILBOX_CSR, 0);
-+	rt2800_shared_mem_unlock(rt2x00dev);
- 
- 	return 0;
- }
-@@ -213,8 +220,10 @@ static int rt2800pci_enable_radio(struct
- 		return retval;
- 
- 	/* After resume MCU_BOOT_SIGNAL will trash these. */
-+	rt2800_shared_mem_lock(rt2x00dev);
- 	rt2x00mmio_register_write(rt2x00dev, H2M_MAILBOX_STATUS, ~0);
- 	rt2x00mmio_register_write(rt2x00dev, H2M_MAILBOX_CID, ~0);
-+	rt2800_shared_mem_unlock(rt2x00dev);
- 
- 	rt2800_mcu_request(rt2x00dev, MCU_SLEEP, TOKEN_RADIO_OFF, 0xff, 0x02);
- 	rt2800pci_mcu_status(rt2x00dev, TOKEN_RADIO_OFF);
-@@ -233,10 +242,12 @@ static int rt2800pci_set_state(struct rt
- 				   0, 0x02);
- 		rt2800pci_mcu_status(rt2x00dev, TOKEN_WAKEUP);
- 	} else if (state == STATE_SLEEP) {
-+		rt2800_shared_mem_lock(rt2x00dev);
- 		rt2x00mmio_register_write(rt2x00dev, H2M_MAILBOX_STATUS,
- 					  0xffffffff);
- 		rt2x00mmio_register_write(rt2x00dev, H2M_MAILBOX_CID,
- 					  0xffffffff);
-+		rt2800_shared_mem_unlock(rt2x00dev);
- 		rt2800_mcu_request(rt2x00dev, MCU_SLEEP, TOKEN_SLEEP,
- 				   0xff, 0x01);
- 	}
-@@ -337,6 +348,9 @@ static const struct rt2800_ops rt2800pci
- 	.drv_write_firmware	= rt2800pci_write_firmware,
- 	.drv_init_registers	= rt2800mmio_init_registers,
- 	.drv_get_txwi		= rt2800mmio_get_txwi,
-+	.shmem_init_lock	= rt2800mmio_shmem_init_lock,
-+	.shmem_lock		= rt2800mmio_shmem_lock,
-+	.shmem_unlock		= rt2800mmio_shmem_unlock,
- };
- 
- static const struct rt2x00lib_ops rt2800pci_rt2x00_ops = {
---- a/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
-@@ -176,6 +176,9 @@ static const struct rt2800_ops rt2800soc
- 	.drv_write_firmware	= rt2800soc_write_firmware,
- 	.drv_init_registers	= rt2800mmio_init_registers,
- 	.drv_get_txwi		= rt2800mmio_get_txwi,
-+	.shmem_init_lock	= rt2800mmio_shmem_init_lock,
-+	.shmem_lock		= rt2800mmio_shmem_lock,
-+	.shmem_unlock		= rt2800mmio_shmem_unlock,
- };
- 
- static const struct rt2x00lib_ops rt2800soc_rt2x00_ops = {
---- a/drivers/net/wireless/ralink/rt2x00/rt2800usb.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800usb.c
-@@ -51,6 +51,27 @@ static bool rt2800usb_hwcrypt_disabled(s
- 	return modparam_nohwcrypt;
- }
- 
-+static void rt2800usb_shmem_init_lock(struct rt2x00_dev *rt2x00dev)
-+{
-+	struct rt2800_drv_data *drv_data = rt2x00dev->drv_data;
-+
-+	mutex_init(&drv_data->shmem_lock.mutex);
-+}
-+
-+static void rt2800usb_shmem_lock(struct rt2x00_dev *rt2x00dev)
-+{
-+	struct rt2800_drv_data *drv_data = rt2x00dev->drv_data;
-+
-+	mutex_lock(&drv_data->shmem_lock.mutex);
-+}
-+
-+static void rt2800usb_shmem_unlock(struct rt2x00_dev *rt2x00dev)
-+{
-+	struct rt2800_drv_data *drv_data = rt2x00dev->drv_data;
-+
-+	mutex_unlock(&drv_data->shmem_lock.mutex);
-+}
-+
- /*
-  * Queue handlers.
-  */
-@@ -299,8 +320,10 @@ static int rt2800usb_write_firmware(stru
- 					      data + offset, length);
- 	}
- 
-+	rt2800_shared_mem_lock(rt2x00dev);
- 	rt2x00usb_register_write(rt2x00dev, H2M_MAILBOX_CID, ~0);
- 	rt2x00usb_register_write(rt2x00dev, H2M_MAILBOX_STATUS, ~0);
-+	rt2800_shared_mem_unlock(rt2x00dev);
- 
- 	/*
- 	 * Send firmware request to device to load firmware,
-@@ -315,7 +338,10 @@ static int rt2800usb_write_firmware(stru
- 	}
- 
- 	msleep(10);
-+
-+	rt2800_shared_mem_lock(rt2x00dev);
- 	rt2x00usb_register_write(rt2x00dev, H2M_MAILBOX_CSR, 0);
-+	rt2800_shared_mem_unlock(rt2x00dev);
- 
- 	return 0;
- }
-@@ -333,8 +359,10 @@ static int rt2800usb_init_registers(stru
- 	if (rt2800_wait_csr_ready(rt2x00dev))
- 		return -EBUSY;
- 
-+	rt2800_shared_mem_lock(rt2x00dev);
- 	rt2x00usb_register_read(rt2x00dev, PBF_SYS_CTRL, &reg);
- 	rt2x00usb_register_write(rt2x00dev, PBF_SYS_CTRL, reg & ~0x00002000);
-+	rt2800_shared_mem_unlock(rt2x00dev);
- 
- 	reg = 0;
- 	rt2x00_set_field32(&reg, MAC_SYS_CTRL_RESET_CSR, 1);
-@@ -863,6 +891,9 @@ static const struct rt2800_ops rt2800usb
- 	.drv_write_firmware	= rt2800usb_write_firmware,
- 	.drv_init_registers	= rt2800usb_init_registers,
- 	.drv_get_txwi		= rt2800usb_get_txwi,
-+	.shmem_init_lock	= rt2800usb_shmem_init_lock,
-+	.shmem_lock		= rt2800usb_shmem_lock,
-+	.shmem_unlock		= rt2800usb_shmem_unlock,
- };
- 
- static const struct rt2x00lib_ops rt2800usb_rt2x00_ops = {
diff --git a/package/kernel/mac80211/patches/600-0004-rt2x00-rt2800lib-fix-beacon-generation-on-RT3593.patch b/package/kernel/mac80211/patches/600-0004-rt2x00-rt2800lib-fix-beacon-generation-on-RT3593.patch
deleted file mode 100644
index 985a3b9..0000000
--- a/package/kernel/mac80211/patches/600-0004-rt2x00-rt2800lib-fix-beacon-generation-on-RT3593.patch
+++ /dev/null
@@ -1,131 +0,0 @@
-From dcfe3dd46242050f100162dce2bcad24d2c942c6 Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Sat, 17 Aug 2013 19:31:42 +0200
-Subject: [PATCH] rt2x00: rt2800lib: fix beacon generation on RT3593
-
-On the RT3593 chipset, the beacon registers are located
-in the high 8KB part of the shared memory.
-
-The high part of the shared memory is only accessible
-if it is explicitly selected. Add a helper function
-in order to be able to control the SHR_MSEL bit in
-the PBF_SYS_CTRL register. Also add a few more helper
-functions and use those to select the correct part of
-the shared memory before and after accessing the beacon
-registers.
-
-The base addresses of the beacon registers are also
-different from the actually used values, so fix the
-'rt2800_hw_beacon_base' function to return the correct
-values.
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
-Changes since v1: ---
----
- drivers/net/wireless/ralink/rt2x00/rt2800.h    |    3 +++
- drivers/net/wireless/ralink/rt2x00/rt2800lib.c |   44 +++++++++++++++++++++++++++++++
- 2 files changed, 47 insertions(+)
-
---- a/drivers/net/wireless/ralink/rt2x00/rt2800.h
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800.h
-@@ -574,6 +574,7 @@
- #define PBF_SYS_CTRL			0x0400
- #define PBF_SYS_CTRL_READY		FIELD32(0x00000080)
- #define PBF_SYS_CTRL_HOST_RAM_WRITE	FIELD32(0x00010000)
-+#define PBF_SYS_CTRL_SHR_MSEL		FIELD32(0x00080000)
- 
- /*
-  * HOST-MCU shared memory
-@@ -2026,6 +2027,8 @@ struct mac_iveiv_entry {
- 	  (((__index) < 6) ? (HW_BEACON_BASE4 + ((__index - 4) * 0x0200)) : \
- 	  (HW_BEACON_BASE6 - ((__index - 6) * 0x0200))))
- 
-+#define HW_BEACON_BASE_HIGH(__index)	(0x4000 + (__index) * 512)
-+
- #define BEACON_BASE_TO_OFFSET(_base)	(((_base) - 0x4000) / 64)
- 
- /*
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -82,6 +82,39 @@ static inline bool rt2800_is_305x_soc(st
- 	return false;
- }
- 
-+static inline void rt2800_shared_mem_select(struct rt2x00_dev *rt2x00dev,
-+					    bool high)
-+{
-+	u32 reg;
-+
-+	if (WARN_ON_ONCE(!rt2800_has_high_shared_mem(rt2x00dev)))
-+		return;
-+
-+	rt2800_register_read(rt2x00dev, PBF_SYS_CTRL, &reg);
-+	rt2x00_set_field32(&reg, PBF_SYS_CTRL_SHR_MSEL, high);
-+	rt2800_register_write(rt2x00dev, PBF_SYS_CTRL, reg);
-+}
-+
-+static inline bool rt2800_beacon_uses_high_mem(struct rt2x00_dev *rt2x00dev)
-+{
-+	if (rt2x00_rt(rt2x00dev, RT3593))
-+		return true;
-+
-+	return false;
-+}
-+
-+static inline void rt2800_select_beacon_mem(struct rt2x00_dev *rt2x00dev)
-+{
-+	if (rt2800_beacon_uses_high_mem(rt2x00dev))
-+		rt2800_shared_mem_select(rt2x00dev, true);
-+}
-+
-+static inline void rt2800_deselect_beacon_mem(struct rt2x00_dev *rt2x00dev)
-+{
-+	if (rt2800_beacon_uses_high_mem(rt2x00dev))
-+		rt2800_shared_mem_select(rt2x00dev, false);
-+}
-+
- static void rt2800_bbp_write(struct rt2x00_dev *rt2x00dev,
- 			     const unsigned int word, const u8 value)
- {
-@@ -948,6 +981,9 @@ EXPORT_SYMBOL_GPL(rt2800_txdone_entry);
- static unsigned int rt2800_hw_beacon_base(struct rt2x00_dev *rt2x00dev,
- 					  unsigned int index)
- {
-+	if (rt2x00_rt(rt2x00dev, RT3593))
-+		return HW_BEACON_BASE_HIGH(index);
-+
- 	return HW_BEACON_BASE(index);
- }
- 
-@@ -1046,8 +1082,12 @@ void rt2800_write_beacon(struct queue_en
- 	beacon_base = rt2800_hw_beacon_base(rt2x00dev, entry->entry_idx);
- 
- 	rt2800_shared_mem_lock(rt2x00dev);
-+
-+	rt2800_select_beacon_mem(rt2x00dev);
- 	rt2800_register_multiwrite(rt2x00dev, beacon_base, entry->skb->data,
- 				   entry->skb->len + padding_len);
-+	rt2800_deselect_beacon_mem(rt2x00dev);
-+
- 	rt2800_shared_mem_unlock(rt2x00dev);
- 	__set_bit(ENTRY_BCN_ENABLED, &entry->flags);
- 
-@@ -1080,6 +1120,8 @@ static inline void rt2800_clear_beacon_r
- 
- 	rt2800_shared_mem_lock(rt2x00dev);
- 
-+	rt2800_select_beacon_mem(rt2x00dev);
-+
- 	/*
- 	 * For the Beacon base registers we only need to clear
- 	 * the whole TXWI which (when set to 0) will invalidate
-@@ -1088,6 +1130,8 @@ static inline void rt2800_clear_beacon_r
- 	for (i = 0; i < txwi_desc_size; i += sizeof(__le32))
- 		rt2800_register_write(rt2x00dev, beacon_base + i, 0);
- 
-+	rt2800_deselect_beacon_mem(rt2x00dev);
-+
- 	rt2800_shared_mem_unlock(rt2x00dev);
- }
- 
diff --git a/package/kernel/mac80211/patches/600-0005-rt2x00-rt2800lib-add-hw_beacon_count-field-to-struct.patch b/package/kernel/mac80211/patches/600-0005-rt2x00-rt2800lib-add-hw_beacon_count-field-to-struct.patch
deleted file mode 100644
index f41a160..0000000
--- a/package/kernel/mac80211/patches/600-0005-rt2x00-rt2800lib-add-hw_beacon_count-field-to-struct.patch
+++ /dev/null
@@ -1,62 +0,0 @@
-From a058825fa7b53fab3b003d8928b60e5b686b3421 Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Sun, 4 Aug 2013 14:36:11 +0200
-Subject: [PATCH] rt2x00: rt2800lib: add hw_beacon_count field to struct
- rt2800_drv_data
-
-Some chipsets can handle more than 8 beacons at once.
-Add a new field to the rt2800_drv_data structure which
-will hold the number of supported beacons of the given
-chipset.
-
-Update the rt2x00_init_registers function to get the
-beacon count from the new field instead of using a
-hardcoded value.
-
-In order to keep the current behaviour, initialize the
-new field with the actually used value.
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/net/wireless/ralink/rt2x00/rt2800lib.c |    5 ++++-
- drivers/net/wireless/ralink/rt2x00/rt2800lib.h |    1 +
- 2 files changed, 5 insertions(+), 1 deletion(-)
-
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -4615,6 +4615,7 @@ EXPORT_SYMBOL_GPL(rt2800_link_tuner);
-  */
- static int rt2800_init_registers(struct rt2x00_dev *rt2x00dev)
- {
-+	struct rt2800_drv_data *drv_data = rt2x00dev->drv_data;
- 	u32 reg;
- 	u16 eeprom;
- 	unsigned int i;
-@@ -4980,7 +4981,7 @@ static int rt2800_init_registers(struct
- 	/*
- 	 * Clear all beacons
- 	 */
--	for (i = 0; i < 8; i++)
-+	for (i = 0; i < drv_data->hw_beacon_count; i++)
- 		rt2800_clear_beacon_register(rt2x00dev, i);
- 
- 	if (rt2x00_is_usb(rt2x00dev)) {
-@@ -7831,6 +7832,8 @@ int rt2800_probe_hw(struct rt2x00_dev *r
- 	if (rt2x00_rt(rt2x00dev, RT3593))
- 		__set_bit(RT2800_HAS_HIGH_SHARED_MEM, &drv_data->rt2800_flags);
- 
-+	drv_data->hw_beacon_count = 8;
-+
- 	/*
- 	 * Allocate eeprom data.
- 	 */
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
-@@ -35,6 +35,7 @@ struct rt2800_drv_data {
- 	u8 txmixer_gain_24g;
- 	u8 txmixer_gain_5g;
- 	unsigned int tbtt_tick;
-+	unsigned int hw_beacon_count;
- 	DECLARE_BITMAP(sta_ids, STA_IDS_SIZE);
- 
- 	unsigned long rt2800_flags;
diff --git a/package/kernel/mac80211/patches/600-0006-rt2x00-rt2800lib-init-additional-beacon-offset-regis.patch b/package/kernel/mac80211/patches/600-0006-rt2x00-rt2800lib-init-additional-beacon-offset-regis.patch
deleted file mode 100644
index 4e735d3..0000000
--- a/package/kernel/mac80211/patches/600-0006-rt2x00-rt2800lib-init-additional-beacon-offset-regis.patch
+++ /dev/null
@@ -1,67 +0,0 @@
-From 1bfa43ca8f30be53ce4fa79cfc3e219642a812b6 Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Mon, 2 Sep 2013 10:58:32 +0200
-Subject: [PATCH] rt2x00: rt2800lib: init additional beacon offset registers
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/net/wireless/ralink/rt2x00/rt2800.h    |   14 ++++++++++++++
- drivers/net/wireless/ralink/rt2x00/rt2800lib.c |   24 ++++++++++++++++++++++++
- 2 files changed, 38 insertions(+)
-
---- a/drivers/net/wireless/ralink/rt2x00/rt2800.h
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800.h
-@@ -629,6 +629,20 @@
-  */
- #define PBF_DBG				0x043c
- 
-+/* BCN_OFFSET2 */
-+#define BCN_OFFSET2			0x0444
-+#define BCN_OFFSET2_BCN8		FIELD32(0x000000ff)
-+#define BCN_OFFSET2_BCN9		FIELD32(0x0000ff00)
-+#define BCN_OFFSET2_BCN10		FIELD32(0x00ff0000)
-+#define BCN_OFFSET2_BCN11		FIELD32(0xff000000)
-+
-+/* BCN_OFFSET3 */
-+#define BCN_OFFSET3			0x0448
-+#define BCN_OFFSET3_BCN12		FIELD32(0x000000ff)
-+#define BCN_OFFSET3_BCN13		FIELD32(0x0000ff00)
-+#define BCN_OFFSET3_BCN14		FIELD32(0x00ff0000)
-+#define BCN_OFFSET3_BCN15		FIELD32(0xff000000)
-+
- /*
-  * RF registers
-  */
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -4627,6 +4627,30 @@ static int rt2800_init_registers(struct
- 	if (ret)
- 		return ret;
- 
-+	if (drv_data->hw_beacon_count == 16) {
-+		rt2800_register_read(rt2x00dev, BCN_OFFSET2, &reg);
-+		rt2x00_set_field32(&reg, BCN_OFFSET2_BCN8,
-+				   rt2800_get_beacon_offset(rt2x00dev, 8));
-+		rt2x00_set_field32(&reg, BCN_OFFSET2_BCN9,
-+				   rt2800_get_beacon_offset(rt2x00dev, 9));
-+		rt2x00_set_field32(&reg, BCN_OFFSET2_BCN10,
-+				   rt2800_get_beacon_offset(rt2x00dev, 10));
-+		rt2x00_set_field32(&reg, BCN_OFFSET2_BCN11,
-+				   rt2800_get_beacon_offset(rt2x00dev, 11));
-+		rt2800_register_write(rt2x00dev, BCN_OFFSET2, reg);
-+
-+		rt2800_register_read(rt2x00dev, BCN_OFFSET3, &reg);
-+		rt2x00_set_field32(&reg, BCN_OFFSET3_BCN12,
-+				   rt2800_get_beacon_offset(rt2x00dev, 12));
-+		rt2x00_set_field32(&reg, BCN_OFFSET3_BCN13,
-+				   rt2800_get_beacon_offset(rt2x00dev, 13));
-+		rt2x00_set_field32(&reg, BCN_OFFSET3_BCN14,
-+				   rt2800_get_beacon_offset(rt2x00dev, 14));
-+		rt2x00_set_field32(&reg, BCN_OFFSET3_BCN15,
-+				   rt2800_get_beacon_offset(rt2x00dev, 15));
-+		rt2800_register_write(rt2x00dev, BCN_OFFSET3, reg);
-+	}
-+
- 	rt2800_register_write(rt2x00dev, LEGACY_BASIC_RATE, 0x0000013f);
- 	rt2800_register_write(rt2x00dev, HT_BASIC_RATE, 0x00008003);
- 
diff --git a/package/kernel/mac80211/patches/600-0007-rt2x00-rt2800lib-fix-max-supported-beacon-count-for-.patch b/package/kernel/mac80211/patches/600-0007-rt2x00-rt2800lib-fix-max-supported-beacon-count-for-.patch
deleted file mode 100644
index 5099c64..0000000
--- a/package/kernel/mac80211/patches/600-0007-rt2x00-rt2800lib-fix-max-supported-beacon-count-for-.patch
+++ /dev/null
@@ -1,24 +0,0 @@
-From 9bea8b61f6025cd633bd5ac71be258620b49bcb3 Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Mon, 2 Sep 2013 11:00:06 +0200
-Subject: [PATCH] rt2x00: rt2800lib: fix max supported beacon count for RT3593
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/net/wireless/ralink/rt2x00/rt2800lib.c |    5 ++++-
- 1 file changed, 4 insertions(+), 1 deletion(-)
-
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -7856,7 +7856,10 @@ int rt2800_probe_hw(struct rt2x00_dev *r
- 	if (rt2x00_rt(rt2x00dev, RT3593))
- 		__set_bit(RT2800_HAS_HIGH_SHARED_MEM, &drv_data->rt2800_flags);
- 
--	drv_data->hw_beacon_count = 8;
-+	if (rt2x00_rt(rt2x00dev, RT3593))
-+		drv_data->hw_beacon_count = 16;
-+	else
-+		drv_data->hw_beacon_count = 8;
- 
- 	/*
- 	 * Allocate eeprom data.
diff --git a/package/kernel/mac80211/patches/600-0008-rt2x00-allow-to-build-rt2800soc-module-for-RT3883.patch b/package/kernel/mac80211/patches/600-0008-rt2x00-allow-to-build-rt2800soc-module-for-RT3883.patch
deleted file mode 100644
index 565e39d..0000000
--- a/package/kernel/mac80211/patches/600-0008-rt2x00-allow-to-build-rt2800soc-module-for-RT3883.patch
+++ /dev/null
@@ -1,30 +0,0 @@
-From 91094ed065f7794886b4a5490fd6de942f036bb4 Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Sun, 24 Mar 2013 19:26:26 +0100
-Subject: [PATCH] rt2x00: allow to build rt2800soc module for RT3883
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/net/wireless/ralink/rt2x00/Kconfig |    2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/drivers/net/wireless/ralink/rt2x00/Kconfig
-+++ b/drivers/net/wireless/ralink/rt2x00/Kconfig
-@@ -210,7 +210,7 @@ endif
- config RT2800SOC
- 	tristate "Ralink WiSoC support"
- 	depends on m
--	depends on SOC_RT288X || SOC_RT305X
-+	depends on SOC_RT288X || SOC_RT305X || SOC_RT3883
- 	select RT2X00_LIB_SOC
- 	select RT2X00_LIB_MMIO
- 	select RT2X00_LIB_CRYPTO
-@@ -245,7 +245,7 @@ config RT2X00_LIB_PCI
- 
- config RT2X00_LIB_SOC
- 	tristate "RT2x00 SoC support"
--	depends on SOC_RT288X || SOC_RT305X
-+	depends on SOC_RT288X || SOC_RT305X || SOC_RT3883
- 	depends on m
- 	select RT2X00_LIB
- 
diff --git a/package/kernel/mac80211/patches/600-0009-rt2x00-rt2800lib-enable-support-for-RT3883.patch b/package/kernel/mac80211/patches/600-0009-rt2x00-rt2800lib-enable-support-for-RT3883.patch
deleted file mode 100644
index a2e7015..0000000
--- a/package/kernel/mac80211/patches/600-0009-rt2x00-rt2800lib-enable-support-for-RT3883.patch
+++ /dev/null
@@ -1,20 +0,0 @@
-From 4f16582c93a71eba9d389e0f0a8aa9099a9587cd Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Sun, 24 Mar 2013 19:26:26 +0100
-Subject: [PATCH] rt2x00: rt2800lib: enable support for RT3883
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/net/wireless/ralink/rt2x00/rt2800lib.c |    1 +
- 1 file changed, 1 insertion(+)
-
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -7826,6 +7826,7 @@ static int rt2800_probe_rt(struct rt2x00
- 	case RT3390:
- 	case RT3572:
- 	case RT3593:
-+	case RT3883:
- 	case RT5390:
- 	case RT5392:
- 	case RT5592:
diff --git a/package/kernel/mac80211/patches/600-0010-rt2x00-rt2800lib-add-rf_vals-for-RF3853.patch b/package/kernel/mac80211/patches/600-0010-rt2x00-rt2800lib-add-rf_vals-for-RF3853.patch
deleted file mode 100644
index 89bd0ac..0000000
--- a/package/kernel/mac80211/patches/600-0010-rt2x00-rt2800lib-add-rf_vals-for-RF3853.patch
+++ /dev/null
@@ -1,112 +0,0 @@
-From ecb394ccf248d8652c463133c4f404458a57a9c1 Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Sun, 24 Mar 2013 19:26:26 +0100
-Subject: [PATCH] rt2x00: rt2800lib: add rf_vals for RF3853
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/net/wireless/ralink/rt2x00/rt2800.h    |    4 +-
- drivers/net/wireless/ralink/rt2x00/rt2800lib.c |   65 +++++++++++++++++++++++++++++++
- 2 files changed, 68 insertions(+), 1 deletion(-)
-
---- a/drivers/net/wireless/ralink/rt2x00/rt2800.h
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800.h
-@@ -48,7 +48,8 @@
-  * RF2853 2.4G/5G 3T3R
-  * RF3320 2.4G 1T1R(RT3350/RT3370/RT3390)
-  * RF3322 2.4G 2T2R(RT3352/RT3371/RT3372/RT3391/RT3392)
-- * RF3053 2.4G/5G 3T3R(RT3883/RT3563/RT3573/RT3593/RT3662)
-+ * RF3053 2.4G/5G 3T3R(RT3563/RT3573/RT3593)
-+ * RF3853 2.4G/5G 3T3R(RT3883/RT3662)
-  * RF5592 2.4G/5G 2T2R
-  * RF3070 2.4G 1T1R
-  * RF5360 2.4G 1T1R
-@@ -72,6 +73,7 @@
- #define RF5592				0x000f
- #define RF3070				0x3070
- #define RF3290				0x3290
-+#define RF3853				0x3853
- #define RF5360				0x5360
- #define RF5362				0x5362
- #define RF5370				0x5370
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -7442,6 +7442,66 @@ static const struct rf_channel rf_vals_3
- 	{173, 0x61, 0, 9},
- };
- 
-+static const struct rf_channel rf_vals_3853[] = {
-+	{1,  241, 6, 2},
-+	{2,  241, 6, 7},
-+	{3,  242, 6, 2},
-+	{4,  242, 6, 7},
-+	{5,  243, 6, 2},
-+	{6,  243, 6, 7},
-+	{7,  244, 6, 2},
-+	{8,  244, 6, 7},
-+	{9,  245, 6, 2},
-+	{10, 245, 6, 7},
-+	{11, 246, 6, 2},
-+	{12, 246, 6, 7},
-+	{13, 247, 6, 2},
-+	{14, 248, 6, 4},
-+
-+	{36, 0x56, 8, 4},
-+	{38, 0x56, 8, 6},
-+	{40, 0x56, 8, 8},
-+	{44, 0x57, 8, 0},
-+	{46, 0x57, 8, 2},
-+	{48, 0x57, 8, 4},
-+	{52, 0x57, 8, 8},
-+	{54, 0x57, 8, 10},
-+	{56, 0x58, 8, 0},
-+	{60, 0x58, 8, 4},
-+	{62, 0x58, 8, 6},
-+	{64, 0x58, 8, 8},
-+
-+	{100, 0x5b, 8, 8},
-+	{102, 0x5b, 8, 10},
-+	{104, 0x5c, 8, 0},
-+	{108, 0x5c, 8, 4},
-+	{110, 0x5c, 8, 6},
-+	{112, 0x5c, 8, 8},
-+	{114, 0x5c, 8, 10},
-+	{116, 0x5d, 8, 0},
-+	{118, 0x5d, 8, 2},
-+	{120, 0x5d, 8, 4},
-+	{124, 0x5d, 8, 8},
-+	{126, 0x5d, 8, 10},
-+	{128, 0x5e, 8, 0},
-+	{132, 0x5e, 8, 4},
-+	{134, 0x5e, 8, 6},
-+	{136, 0x5e, 8, 8},
-+	{140, 0x5f, 8, 0},
-+
-+	{149, 0x5f, 8, 9},
-+	{151, 0x5f, 8, 11},
-+	{153, 0x60, 8, 1},
-+	{157, 0x60, 8, 5},
-+	{159, 0x60, 8, 7},
-+	{161, 0x60, 8, 9},
-+	{165, 0x61, 8, 1},
-+	{167, 0x61, 8, 3},
-+	{169, 0x61, 8, 5},
-+	{171, 0x61, 8, 7},
-+	{173, 0x61, 8, 9},
-+};
-+
- static const struct rf_channel rf_vals_5592_xtal20[] = {
- 	/* Channel, N, K, mod, R */
- 	{1, 482, 4, 10, 3},
-@@ -7673,6 +7733,11 @@ static int rt2800_probe_hw_mode(struct r
- 		spec->channels = rf_vals_3x;
- 		break;
- 
-+	case RF3853:
-+		spec->num_channels = ARRAY_SIZE(rf_vals_3853);
-+		spec->channels = rf_vals_3853;
-+		break;
-+
- 	case RF5592:
- 		rt2800_register_read(rt2x00dev, MAC_DEBUG_INDEX, &reg);
- 		if (rt2x00_get_field32(reg, MAC_DEBUG_INDEX_XTAL)) {
diff --git a/package/kernel/mac80211/patches/600-0011-rt2x00-rt2800lib-enable-VCO-calibration-for-RF3853.patch b/package/kernel/mac80211/patches/600-0011-rt2x00-rt2800lib-enable-VCO-calibration-for-RF3853.patch
deleted file mode 100644
index b7efc9f..0000000
--- a/package/kernel/mac80211/patches/600-0011-rt2x00-rt2800lib-enable-VCO-calibration-for-RF3853.patch
+++ /dev/null
@@ -1,28 +0,0 @@
-From f8e3fcf18e1f2d7f9e6a9680c5452da090f33d88 Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Thu, 1 Aug 2013 14:40:44 +0200
-Subject: [PATCH] rt2x00: rt2800lib: enable VCO calibration for RF3853
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/net/wireless/ralink/rt2x00/rt2800lib.c |    2 ++
- 1 file changed, 2 insertions(+)
-
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -4379,6 +4379,7 @@ void rt2800_vco_calibration(struct rt2x0
- 	case RF3053:
- 	case RF3070:
- 	case RF3290:
-+	case RF3853:
- 	case RF5360:
- 	case RF5362:
- 	case RF5370:
-@@ -7852,6 +7853,7 @@ static int rt2800_probe_hw_mode(struct r
- 	case RF3053:
- 	case RF3070:
- 	case RF3290:
-+	case RF3853:
- 	case RF5360:
- 	case RF5362:
- 	case RF5370:
diff --git a/package/kernel/mac80211/patches/600-0012-rt2x00-rt2800lib-add-channel-configuration-function-.patch b/package/kernel/mac80211/patches/600-0012-rt2x00-rt2800lib-add-channel-configuration-function-.patch
deleted file mode 100644
index c120f2c..0000000
--- a/package/kernel/mac80211/patches/600-0012-rt2x00-rt2800lib-add-channel-configuration-function-.patch
+++ /dev/null
@@ -1,235 +0,0 @@
-From 6e3a17190815c6aa4dc53c2cfe9125fb1154f187 Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Sun, 24 Mar 2013 19:26:27 +0100
-Subject: [PATCH] rt2x00: rt2800lib: add channel configuration function for
- RF3853
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/net/wireless/ralink/rt2x00/rt2800lib.c |  208 +++++++++++++++++++++++++++++++
- 1 file changed, 208 insertions(+)
-
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -2626,6 +2626,211 @@ static void rt2800_config_channel_rf3053
- 	}
- }
- 
-+static void rt2800_config_channel_rf3853(struct rt2x00_dev *rt2x00dev,
-+					 struct ieee80211_conf *conf,
-+					 struct rf_channel *rf,
-+					 struct channel_info *info)
-+{
-+	u8 rfcsr;
-+	u8 bbp;
-+	u8 pwr1, pwr2, pwr3;
-+
-+	const bool txbf_enabled = false; /* TODO */
-+
-+	/* TODO: add band selection */
-+
-+	if (rf->channel <= 14)
-+		rt2800_rfcsr_write(rt2x00dev, 6, 0x40);
-+	else if (rf->channel < 132)
-+		rt2800_rfcsr_write(rt2x00dev, 6, 0x80);
-+	else
-+		rt2800_rfcsr_write(rt2x00dev, 6, 0x40);
-+
-+	rt2800_rfcsr_write(rt2x00dev, 8, rf->rf1);
-+	rt2800_rfcsr_write(rt2x00dev, 9, rf->rf3);
-+
-+	if (rf->channel <= 14)
-+		rt2800_rfcsr_write(rt2x00dev, 11, 0x46);
-+	else
-+		rt2800_rfcsr_write(rt2x00dev, 11, 0x48);
-+
-+	if (rf->channel <= 14)
-+		rt2800_rfcsr_write(rt2x00dev, 12, 0x1a);
-+	else
-+		rt2800_rfcsr_write(rt2x00dev, 12, 0x52);
-+
-+	rt2800_rfcsr_write(rt2x00dev, 13, 0x12);
-+
-+	rt2800_rfcsr_read(rt2x00dev, 1, &rfcsr);
-+	rt2x00_set_field8(&rfcsr, RFCSR1_RX0_PD, 0);
-+	rt2x00_set_field8(&rfcsr, RFCSR1_TX0_PD, 0);
-+	rt2x00_set_field8(&rfcsr, RFCSR1_RX1_PD, 0);
-+	rt2x00_set_field8(&rfcsr, RFCSR1_TX1_PD, 0);
-+	rt2x00_set_field8(&rfcsr, RFCSR1_RX2_PD, 0);
-+	rt2x00_set_field8(&rfcsr, RFCSR1_TX2_PD, 0);
-+	rt2x00_set_field8(&rfcsr, RFCSR1_RF_BLOCK_EN, 1);
-+	rt2x00_set_field8(&rfcsr, RFCSR1_PLL_PD, 1);
-+
-+	switch (rt2x00dev->default_ant.tx_chain_num) {
-+	case 3:
-+		rt2x00_set_field8(&rfcsr, RFCSR1_TX2_PD, 1);
-+		/* fallthrough */
-+	case 2:
-+		rt2x00_set_field8(&rfcsr, RFCSR1_TX1_PD, 1);
-+		/* fallthrough */
-+	case 1:
-+		rt2x00_set_field8(&rfcsr, RFCSR1_TX0_PD, 1);
-+		break;
-+	}
-+
-+	switch (rt2x00dev->default_ant.rx_chain_num) {
-+	case 3:
-+		rt2x00_set_field8(&rfcsr, RFCSR1_RX2_PD, 1);
-+		/* fallthrough */
-+	case 2:
-+		rt2x00_set_field8(&rfcsr, RFCSR1_RX1_PD, 1);
-+		/* fallthrough */
-+	case 1:
-+		rt2x00_set_field8(&rfcsr, RFCSR1_RX0_PD, 1);
-+		break;
-+	}
-+	rt2800_rfcsr_write(rt2x00dev, 1, rfcsr);
-+
-+	rt2800_adjust_freq_offset(rt2x00dev);
-+
-+	rt2800_rfcsr_read(rt2x00dev, 30, &rfcsr);
-+	if (!conf_is_ht40(conf))
-+		rfcsr &= ~(0x06);
-+	else
-+		rfcsr |= 0x06;
-+	rt2800_rfcsr_write(rt2x00dev, 30, rfcsr);
-+
-+	if (rf->channel <= 14)
-+		rt2800_rfcsr_write(rt2x00dev, 31, 0xa0);
-+	else
-+		rt2800_rfcsr_write(rt2x00dev, 31, 0x80);
-+
-+	if (conf_is_ht40(conf))
-+		rt2800_rfcsr_write(rt2x00dev, 32, 0x80);
-+	else
-+		rt2800_rfcsr_write(rt2x00dev, 32, 0xd8);
-+
-+	if (rf->channel <= 14)
-+		rt2800_rfcsr_write(rt2x00dev, 34, 0x3c);
-+	else
-+		rt2800_rfcsr_write(rt2x00dev, 34, 0x20);
-+
-+	/* loopback RF_BS */
-+	rt2800_rfcsr_read(rt2x00dev, 36, &rfcsr);
-+	if (rf->channel <= 14)
-+		rt2x00_set_field8(&rfcsr, RFCSR36_RF_BS, 1);
-+	else
-+		rt2x00_set_field8(&rfcsr, RFCSR36_RF_BS, 0);
-+	rt2800_rfcsr_write(rt2x00dev, 36, rfcsr);
-+
-+	if (rf->channel <= 14)
-+		rfcsr = 0x23;
-+	else if (rf->channel < 100)
-+		rfcsr = 0x36;
-+	else if (rf->channel < 132)
-+		rfcsr = 0x32;
-+	else
-+		rfcsr = 0x30;
-+
-+	if (txbf_enabled)
-+		rfcsr |= 0x40;
-+
-+	rt2800_rfcsr_write(rt2x00dev, 39, rfcsr);
-+
-+	if (rf->channel <= 14)
-+		rt2800_rfcsr_write(rt2x00dev, 44, 0x93);
-+	else
-+		rt2800_rfcsr_write(rt2x00dev, 44, 0x9b);
-+
-+	if (rf->channel <= 14)
-+		rfcsr = 0xbb;
-+	else if (rf->channel < 100)
-+		rfcsr = 0xeb;
-+	else if (rf->channel < 132)
-+		rfcsr = 0xb3;
-+	else
-+		rfcsr = 0x9b;
-+	rt2800_rfcsr_write(rt2x00dev, 45, rfcsr);
-+
-+	if (rf->channel <= 14)
-+		rfcsr = 0x8e;
-+	else
-+		rfcsr = 0x8a;
-+
-+	if (txbf_enabled)
-+		rfcsr |= 0x20;
-+
-+	rt2800_rfcsr_write(rt2x00dev, 49, rfcsr);
-+
-+	rt2800_rfcsr_write(rt2x00dev, 50, 0x86);
-+
-+	rt2800_rfcsr_read(rt2x00dev, 51, &rfcsr);
-+	if (rf->channel <= 14)
-+		rt2800_rfcsr_write(rt2x00dev, 51, 0x75);
-+	else
-+		rt2800_rfcsr_write(rt2x00dev, 51, 0x51);
-+
-+	rt2800_rfcsr_read(rt2x00dev, 52, &rfcsr);
-+	if (rf->channel <= 14)
-+		rt2800_rfcsr_write(rt2x00dev, 52, 0x45);
-+	else
-+		rt2800_rfcsr_write(rt2x00dev, 52, 0x05);
-+
-+	if (rf->channel <= 14) {
-+		pwr1 = info->default_power1 & 0x1f;
-+		pwr2 = info->default_power2 & 0x1f;
-+		pwr3 = info->default_power3 & 0x1f;
-+	} else {
-+		pwr1 = 0x48 | ((info->default_power1 & 0x18) << 1) |
-+			(info->default_power1 & 0x7);
-+		pwr2 = 0x48 | ((info->default_power2 & 0x18) << 1) |
-+			(info->default_power2 & 0x7);
-+		pwr3 = 0x48 | ((info->default_power3 & 0x18) << 1) |
-+			(info->default_power3 & 0x7);
-+	}
-+
-+	rt2800_rfcsr_write(rt2x00dev, 53, pwr1);
-+	rt2800_rfcsr_write(rt2x00dev, 54, pwr2);
-+	rt2800_rfcsr_write(rt2x00dev, 55, pwr3);
-+
-+	rt2x00_dbg(rt2x00dev, "Channel:%d, pwr1:%02x, pwr2:%02x, pwr3:%02x\n",
-+		   rf->channel, pwr1, pwr2, pwr3);
-+
-+	bbp = (info->default_power1 >> 5) |
-+	      ((info->default_power2 & 0xe0) >> 1);
-+	rt2800_bbp_write(rt2x00dev, 109, bbp);
-+
-+	rt2800_bbp_read(rt2x00dev, 110, &bbp);
-+	bbp &= 0x0f;
-+	bbp |= (info->default_power3 & 0xe0) >> 1;
-+	rt2800_bbp_write(rt2x00dev, 110, bbp);
-+
-+	rt2800_rfcsr_read(rt2x00dev, 57, &rfcsr);
-+	if (rf->channel <= 14)
-+		rt2800_rfcsr_write(rt2x00dev, 57, 0x6e);
-+	else
-+		rt2800_rfcsr_write(rt2x00dev, 57, 0x3e);
-+
-+	/* Enable RF tuning */
-+	rt2800_rfcsr_read(rt2x00dev, 3, &rfcsr);
-+	rt2x00_set_field8(&rfcsr, RFCSR3_VCOCAL_EN, 1);
-+	rt2800_rfcsr_write(rt2x00dev, 3, rfcsr);
-+
-+	udelay(2000);
-+
-+	rt2800_bbp_read(rt2x00dev, 49, &bbp);
-+	/* clear update flag */
-+	rt2800_bbp_write(rt2x00dev, 49, bbp & 0xfe);
-+	rt2800_bbp_write(rt2x00dev, 49, bbp);
-+
-+	/* TODO: add calibration for TxBF */
-+}
-+
- #define POWER_BOUND		0x27
- #define POWER_BOUND_5G		0x2b
- 
-@@ -3238,6 +3443,9 @@ static void rt2800_config_channel(struct
- 	case RF3322:
- 		rt2800_config_channel_rf3322(rt2x00dev, conf, rf, info);
- 		break;
-+	case RF3853:
-+		rt2800_config_channel_rf3853(rt2x00dev, conf, rf, info);
-+		break;
- 	case RF3070:
- 	case RF5360:
- 	case RF5362:
diff --git a/package/kernel/mac80211/patches/600-0013-rt2x00-rt2800lib-enable-RF3853-support.patch b/package/kernel/mac80211/patches/600-0013-rt2x00-rt2800lib-enable-RF3853-support.patch
deleted file mode 100644
index f006304..0000000
--- a/package/kernel/mac80211/patches/600-0013-rt2x00-rt2800lib-enable-RF3853-support.patch
+++ /dev/null
@@ -1,20 +0,0 @@
-From afd38ae82226551bf879b6c7c4b620c271fee9d2 Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Thu, 1 Aug 2013 14:42:05 +0200
-Subject: [PATCH] rt2x00: rt2800lib: enable RF3853 support
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/net/wireless/ralink/rt2x00/rt2800lib.c |    1 +
- 1 file changed, 1 insertion(+)
-
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -7407,6 +7407,7 @@ static int rt2800_init_eeprom(struct rt2
- 	case RF3290:
- 	case RF3320:
- 	case RF3322:
-+	case RF3853:
- 	case RF5360:
- 	case RF5362:
- 	case RF5370:
diff --git a/package/kernel/mac80211/patches/600-0014-rt2x00-rt2800lib-add-MAC-register-initialization-for.patch b/package/kernel/mac80211/patches/600-0014-rt2x00-rt2800lib-add-MAC-register-initialization-for.patch
deleted file mode 100644
index a56bfa8..0000000
--- a/package/kernel/mac80211/patches/600-0014-rt2x00-rt2800lib-add-MAC-register-initialization-for.patch
+++ /dev/null
@@ -1,77 +0,0 @@
-From 0094872a5e8e4664c6ea1b2dfa487063d39ae363 Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Sun, 24 Mar 2013 19:26:26 +0100
-Subject: [PATCH] rt2x00: rt2800lib: add MAC register initialization for
- RT3883
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/net/wireless/ralink/rt2x00/rt2800.h    |   14 ++++++++++++++
- drivers/net/wireless/ralink/rt2x00/rt2800lib.c |   19 ++++++++++++++++---
- 2 files changed, 30 insertions(+), 3 deletions(-)
-
---- a/drivers/net/wireless/ralink/rt2x00/rt2800.h
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800.h
-@@ -1588,6 +1588,20 @@
- #define TX_PWR_CFG_9_STBC7_CH2		FIELD32(0x00000f00)
- 
- /*
-+ * TX_TXBF_CFG:
-+ */
-+#define TX_TXBF_CFG_0			0x138c
-+#define TX_TXBF_CFG_1			0x13a4
-+#define TX_TXBF_CFG_2			0x13a8
-+#define TX_TXBF_CFG_3			0x13ac
-+
-+/*
-+ * TX_FBK_CFG_3S:
-+ */
-+#define TX_FBK_CFG_3S_0			0x13c4
-+#define TX_FBK_CFG_3S_1			0x13c8
-+
-+/*
-  * RX_FILTER_CFG: RX configuration register.
-  */
- #define RX_FILTER_CFG			0x1400
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -4982,6 +4982,12 @@ static int rt2800_init_registers(struct
- 			rt2800_register_write(rt2x00dev, TX_SW_CFG2,
- 					      0x00000000);
- 		}
-+	} else if (rt2x00_rt(rt2x00dev, RT3883)) {
-+		rt2800_register_write(rt2x00dev, TX_SW_CFG0, 0x00000402);
-+		rt2800_register_write(rt2x00dev, TX_SW_CFG1, 0x00000000);
-+		rt2800_register_write(rt2x00dev, TX_SW_CFG2, 0x00040000);
-+		rt2800_register_write(rt2x00dev, TX_TXBF_CFG_0, 0x8000fc21);
-+		rt2800_register_write(rt2x00dev, TX_TXBF_CFG_3, 0x00009c40);
- 	} else if (rt2x00_rt(rt2x00dev, RT5390) ||
- 		   rt2x00_rt(rt2x00dev, RT5392) ||
- 		   rt2x00_rt(rt2x00dev, RT5592)) {
-@@ -5012,9 +5018,11 @@ static int rt2800_init_registers(struct
- 
- 	rt2800_register_read(rt2x00dev, MAX_LEN_CFG, &reg);
- 	rt2x00_set_field32(&reg, MAX_LEN_CFG_MAX_MPDU, AGGREGATION_SIZE);
--	if (rt2x00_rt_rev_gte(rt2x00dev, RT2872, REV_RT2872E) ||
--	    rt2x00_rt(rt2x00dev, RT2883) ||
--	    rt2x00_rt_rev_lt(rt2x00dev, RT3070, REV_RT3070E))
-+	if (rt2x00_rt(rt2x00dev, RT3883))
-+		rt2x00_set_field32(&reg, MAX_LEN_CFG_MAX_PSDU, 3);
-+	else if (rt2x00_rt_rev_gte(rt2x00dev, RT2872, REV_RT2872E) ||
-+		 rt2x00_rt(rt2x00dev, RT2883) ||
-+		 rt2x00_rt_rev_lt(rt2x00dev, RT3070, REV_RT3070E))
- 		rt2x00_set_field32(&reg, MAX_LEN_CFG_MAX_PSDU, 2);
- 	else
- 		rt2x00_set_field32(&reg, MAX_LEN_CFG_MAX_PSDU, 1);
-@@ -5167,6 +5175,11 @@ static int rt2800_init_registers(struct
- 	reg = rt2x00_rt(rt2x00dev, RT5592) ? 0x00000082 : 0x00000002;
- 	rt2800_register_write(rt2x00dev, TXOP_HLDR_ET, reg);
- 
-+	if (rt2x00_rt(rt2x00dev, RT3883)) {
-+		rt2800_register_write(rt2x00dev, TX_FBK_CFG_3S_0, 0x12111008);
-+		rt2800_register_write(rt2x00dev, TX_FBK_CFG_3S_1, 0x16151413);
-+	}
-+
- 	rt2800_register_read(rt2x00dev, TX_RTS_CFG, &reg);
- 	rt2x00_set_field32(&reg, TX_RTS_CFG_AUTO_RTS_RETRY_LIMIT, 32);
- 	rt2x00_set_field32(&reg, TX_RTS_CFG_RTS_THRES,
diff --git a/package/kernel/mac80211/patches/600-0015-rt2x00-rt2800soc-fix-rt2800soc_disable_radio-for-RT3.patch b/package/kernel/mac80211/patches/600-0015-rt2x00-rt2800soc-fix-rt2800soc_disable_radio-for-RT3.patch
deleted file mode 100644
index d68ad50..0000000
--- a/package/kernel/mac80211/patches/600-0015-rt2x00-rt2800soc-fix-rt2800soc_disable_radio-for-RT3.patch
+++ /dev/null
@@ -1,30 +0,0 @@
-From 6c2d32478159fffff0b85abb6817a21bb2338231 Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Sun, 24 Mar 2013 19:26:27 +0100
-Subject: [PATCH] rt2x00: rt2800soc: fix rt2800soc_disable_radio for RT3883
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/net/wireless/ralink/rt2x00/rt2800soc.c |    9 ++++++++-
- 1 file changed, 8 insertions(+), 1 deletion(-)
-
---- a/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
-@@ -51,9 +51,16 @@ static bool rt2800soc_hwcrypt_disabled(s
- 
- static void rt2800soc_disable_radio(struct rt2x00_dev *rt2x00dev)
- {
-+	u32 reg;
-+
- 	rt2800_disable_radio(rt2x00dev);
- 	rt2x00mmio_register_write(rt2x00dev, PWR_PIN_CFG, 0);
--	rt2x00mmio_register_write(rt2x00dev, TX_PIN_CFG, 0);
-+
-+	reg = 0;
-+	if (rt2x00_rt(rt2x00dev, RT3883))
-+		rt2x00_set_field32(&reg, TX_PIN_CFG_RFTR_EN, 1);
-+
-+	rt2x00mmio_register_write(rt2x00dev, TX_PIN_CFG, reg);
- }
- 
- static int rt2800soc_set_device_state(struct rt2x00_dev *rt2x00dev,
diff --git a/package/kernel/mac80211/patches/600-0016-rt2x00-rt2800lib-add-BBP-register-initialization-for.patch b/package/kernel/mac80211/patches/600-0016-rt2x00-rt2800lib-add-BBP-register-initialization-for.patch
deleted file mode 100644
index 9532632..0000000
--- a/package/kernel/mac80211/patches/600-0016-rt2x00-rt2800lib-add-BBP-register-initialization-for.patch
+++ /dev/null
@@ -1,71 +0,0 @@
-From 84833056aa7dd25f5b097e31c78f2a0914c5160c Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Sun, 24 Mar 2013 19:26:26 +0100
-Subject: [PATCH] rt2x00: rt2800lib: add BBP register initialization for
- RT3883
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/net/wireless/ralink/rt2x00/rt2800lib.c |   44 +++++++++++++++++++++++++++++++
- 1 file changed, 44 insertions(+)
-
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -5785,6 +5785,47 @@ static void rt2800_init_bbp_3593(struct
- 		rt2800_bbp_write(rt2x00dev, 103, 0xc0);
- }
- 
-+static void rt2800_init_bbp_3883(struct rt2x00_dev *rt2x00dev)
-+{
-+	rt2800_init_bbp_early(rt2x00dev);
-+
-+	rt2800_bbp_write(rt2x00dev, 4, 0x50);
-+	rt2800_bbp_write(rt2x00dev, 47, 0x48);
-+
-+	rt2800_bbp_write(rt2x00dev, 86, 0x46);
-+	rt2800_bbp_write(rt2x00dev, 88, 0x90);
-+
-+	rt2800_bbp_write(rt2x00dev, 92, 0x02);
-+
-+	rt2800_bbp_write(rt2x00dev, 103, 0xc0);
-+	rt2800_bbp_write(rt2x00dev, 104, 0x92);
-+	rt2800_bbp_write(rt2x00dev, 105, 0x34);
-+	rt2800_bbp_write(rt2x00dev, 106, 0x12);
-+	rt2800_bbp_write(rt2x00dev, 120, 0x50);
-+	rt2800_bbp_write(rt2x00dev, 137, 0x0f);
-+	rt2800_bbp_write(rt2x00dev, 163, 0x9d);
-+
-+	/* Set ITxBF timeout to 0x9C40=1000msec */
-+	rt2800_bbp_write(rt2x00dev, 179, 0x02);
-+	rt2800_bbp_write(rt2x00dev, 180, 0x00);
-+	rt2800_bbp_write(rt2x00dev, 182, 0x40);
-+	rt2800_bbp_write(rt2x00dev, 180, 0x01);
-+	rt2800_bbp_write(rt2x00dev, 182, 0x9c);
-+
-+	rt2800_bbp_write(rt2x00dev, 179, 0x00);
-+
-+	/* Reprogram the inband interface to put right values in RXWI */
-+	rt2800_bbp_write(rt2x00dev, 142, 0x04);
-+	rt2800_bbp_write(rt2x00dev, 143, 0x3b);
-+	rt2800_bbp_write(rt2x00dev, 142, 0x06);
-+	rt2800_bbp_write(rt2x00dev, 143, 0xa0);
-+	rt2800_bbp_write(rt2x00dev, 142, 0x07);
-+	rt2800_bbp_write(rt2x00dev, 143, 0xa1);
-+	rt2800_bbp_write(rt2x00dev, 142, 0x08);
-+	rt2800_bbp_write(rt2x00dev, 143, 0xa2);
-+	rt2800_bbp_write(rt2x00dev, 148, 0xc8);
-+}
-+
- static void rt2800_init_bbp_53xx(struct rt2x00_dev *rt2x00dev)
- {
- 	int ant, div_mode;
-@@ -6003,6 +6044,9 @@ static void rt2800_init_bbp(struct rt2x0
- 	case RT3593:
- 		rt2800_init_bbp_3593(rt2x00dev);
- 		return;
-+	case RT3883:
-+		rt2800_init_bbp_3883(rt2x00dev);
-+		return;
- 	case RT5390:
- 	case RT5392:
- 		rt2800_init_bbp_53xx(rt2x00dev);
diff --git a/package/kernel/mac80211/patches/600-0017-rt2x00-rt2800lib-add-RFCSR-initialization-for-RT3883.patch b/package/kernel/mac80211/patches/600-0017-rt2x00-rt2800lib-add-RFCSR-initialization-for-RT3883.patch
deleted file mode 100644
index 936fa35..0000000
--- a/package/kernel/mac80211/patches/600-0017-rt2x00-rt2800lib-add-RFCSR-initialization-for-RT3883.patch
+++ /dev/null
@@ -1,178 +0,0 @@
-From 99c659cf345640fd0f733cbcaf4583cc2c868ec0 Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Mon, 29 Apr 2013 13:21:48 +0200
-Subject: [PATCH] rt2x00: rt2800lib: add RFCSR initialization for RT3883
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/net/wireless/ralink/rt2x00/rt2800.h    |    1 +
- drivers/net/wireless/ralink/rt2x00/rt2800lib.c |  141 +++++++++++++++++++++++++++++++
- 2 files changed, 142 insertions(+)
-
---- a/drivers/net/wireless/ralink/rt2x00/rt2800.h
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800.h
-@@ -2171,6 +2171,7 @@ struct mac_iveiv_entry {
- /*
-  * RFCSR 2:
-  */
-+#define RFCSR2_RESCAL_BP		FIELD8(0x40)
- #define RFCSR2_RESCAL_EN		FIELD8(0x80)
- 
- /*
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -6820,6 +6820,144 @@ static void rt2800_init_rfcsr_3593(struc
- 	/* TODO: enable stream mode support */
- }
- 
-+static void rt2800_init_rfcsr_3883(struct rt2x00_dev *rt2x00dev)
-+{
-+	u8 rfcsr;
-+
-+	/* TODO: get the actual ECO value from the SoC */
-+	const unsigned int eco = 5;
-+
-+	rt2800_rf_init_calibration(rt2x00dev, 2);
-+
-+	rt2800_rfcsr_write(rt2x00dev, 0, 0xe0);
-+	rt2800_rfcsr_write(rt2x00dev, 1, 0x03);
-+	rt2800_rfcsr_write(rt2x00dev, 2, 0x50);
-+	rt2800_rfcsr_write(rt2x00dev, 3, 0x20);
-+	rt2800_rfcsr_write(rt2x00dev, 4, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 5, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 6, 0x40);
-+	rt2800_rfcsr_write(rt2x00dev, 7, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 8, 0x5b);
-+	rt2800_rfcsr_write(rt2x00dev, 9, 0x08);
-+	rt2800_rfcsr_write(rt2x00dev, 10, 0xd3);
-+	rt2800_rfcsr_write(rt2x00dev, 11, 0x48);
-+	rt2800_rfcsr_write(rt2x00dev, 12, 0x1a);
-+	rt2800_rfcsr_write(rt2x00dev, 13, 0x12);
-+	rt2800_rfcsr_write(rt2x00dev, 14, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 15, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 16, 0x00);
-+
-+	/* RFCSR 17 will be initialized later based on the
-+	 * frequency offset stored in the EEPROM
-+	 */
-+
-+	rt2800_rfcsr_write(rt2x00dev, 18, 0x40);
-+	rt2800_rfcsr_write(rt2x00dev, 19, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 20, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 21, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 22, 0x20);
-+	rt2800_rfcsr_write(rt2x00dev, 23, 0xc0);
-+	rt2800_rfcsr_write(rt2x00dev, 24, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 25, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 26, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 27, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 28, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 29, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 30, 0x10);
-+	rt2800_rfcsr_write(rt2x00dev, 31, 0x80);
-+	rt2800_rfcsr_write(rt2x00dev, 32, 0x80);
-+	rt2800_rfcsr_write(rt2x00dev, 33, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 34, 0x20);
-+	rt2800_rfcsr_write(rt2x00dev, 35, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 36, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 37, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 38, 0x86);
-+	rt2800_rfcsr_write(rt2x00dev, 39, 0x23);
-+	rt2800_rfcsr_write(rt2x00dev, 40, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 41, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 42, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 43, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 44, 0x93);
-+	rt2800_rfcsr_write(rt2x00dev, 45, 0xbb);
-+	rt2800_rfcsr_write(rt2x00dev, 46, 0x60);
-+	rt2800_rfcsr_write(rt2x00dev, 47, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 48, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 49, 0x8e);
-+	rt2800_rfcsr_write(rt2x00dev, 50, 0x86);
-+	rt2800_rfcsr_write(rt2x00dev, 51, 0x51);
-+	rt2800_rfcsr_write(rt2x00dev, 52, 0x05);
-+	rt2800_rfcsr_write(rt2x00dev, 53, 0x76);
-+	rt2800_rfcsr_write(rt2x00dev, 54, 0x76);
-+	rt2800_rfcsr_write(rt2x00dev, 55, 0x76);
-+	rt2800_rfcsr_write(rt2x00dev, 56, 0xdb);
-+	rt2800_rfcsr_write(rt2x00dev, 57, 0x3e);
-+	rt2800_rfcsr_write(rt2x00dev, 58, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 59, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 60, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 61, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 62, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 63, 0x00);
-+
-+	/* TODO: rx filter calibration? */
-+
-+	rt2800_bbp_write(rt2x00dev, 137, 0x0f);
-+
-+	rt2800_bbp_write(rt2x00dev, 163, 0x9d);
-+
-+	rt2800_bbp_write(rt2x00dev, 105, 0x05);
-+
-+	rt2800_bbp_write(rt2x00dev, 179, 0x02);
-+	rt2800_bbp_write(rt2x00dev, 180, 0x00);
-+	rt2800_bbp_write(rt2x00dev, 182, 0x40);
-+	rt2800_bbp_write(rt2x00dev, 180, 0x01);
-+	rt2800_bbp_write(rt2x00dev, 182, 0x9c);
-+
-+	rt2800_bbp_write(rt2x00dev, 179, 0x00);
-+
-+	rt2800_bbp_write(rt2x00dev, 142, 0x04);
-+	rt2800_bbp_write(rt2x00dev, 143, 0x3b);
-+	rt2800_bbp_write(rt2x00dev, 142, 0x06);
-+	rt2800_bbp_write(rt2x00dev, 143, 0xa0);
-+	rt2800_bbp_write(rt2x00dev, 142, 0x07);
-+	rt2800_bbp_write(rt2x00dev, 143, 0xa1);
-+	rt2800_bbp_write(rt2x00dev, 142, 0x08);
-+	rt2800_bbp_write(rt2x00dev, 143, 0xa2);
-+	rt2800_bbp_write(rt2x00dev, 148, 0xc8);
-+
-+	if (eco == 5) {
-+		rt2800_rfcsr_write(rt2x00dev, 32, 0xd8);
-+		rt2800_rfcsr_write(rt2x00dev, 33, 0x32);
-+	}
-+
-+	rt2800_rfcsr_read(rt2x00dev, 2, &rfcsr);
-+	rt2x00_set_field8(&rfcsr, RFCSR2_RESCAL_BP, 0);
-+	rt2x00_set_field8(&rfcsr, RFCSR2_RESCAL_EN, 1);
-+	rt2800_rfcsr_write(rt2x00dev, 2, rfcsr);
-+	msleep(1);
-+	rt2x00_set_field8(&rfcsr, RFCSR2_RESCAL_EN, 0);
-+	rt2800_rfcsr_write(rt2x00dev, 2, rfcsr);
-+
-+	rt2800_rfcsr_read(rt2x00dev, 1, &rfcsr);
-+	rt2x00_set_field8(&rfcsr, RFCSR1_RF_BLOCK_EN, 1);
-+	rt2800_rfcsr_write(rt2x00dev, 1, rfcsr);
-+
-+	rt2800_rfcsr_read(rt2x00dev, 6, &rfcsr);
-+	rfcsr |= 0xc0;
-+	rt2800_rfcsr_write(rt2x00dev, 6, rfcsr);
-+
-+	rt2800_rfcsr_read(rt2x00dev, 22, &rfcsr);
-+	rfcsr |= 0x20;
-+	rt2800_rfcsr_write(rt2x00dev, 22, rfcsr);
-+
-+	rt2800_rfcsr_read(rt2x00dev, 46, &rfcsr);
-+	rfcsr |= 0x20;
-+	rt2800_rfcsr_write(rt2x00dev, 46, rfcsr);
-+
-+	rt2800_rfcsr_read(rt2x00dev, 20, &rfcsr);
-+	rfcsr &= ~0xee;
-+	rt2800_rfcsr_write(rt2x00dev, 20, rfcsr);
-+}
-+
- static void rt2800_init_rfcsr_5390(struct rt2x00_dev *rt2x00dev)
- {
- 	rt2800_rf_init_calibration(rt2x00dev, 2);
-@@ -7051,6 +7189,9 @@ static void rt2800_init_rfcsr(struct rt2
- 	case RT3390:
- 		rt2800_init_rfcsr_3390(rt2x00dev);
- 		break;
-+	case RT3883:
-+		rt2800_init_rfcsr_3883(rt2x00dev);
-+		break;
- 	case RT3572:
- 		rt2800_init_rfcsr_3572(rt2x00dev);
- 		break;
diff --git a/package/kernel/mac80211/patches/600-0018-rt2x00-rt2800lib-use-the-extended-EEPROM-map-for-RT3.patch b/package/kernel/mac80211/patches/600-0018-rt2x00-rt2800lib-use-the-extended-EEPROM-map-for-RT3.patch
deleted file mode 100644
index ae899f7..0000000
--- a/package/kernel/mac80211/patches/600-0018-rt2x00-rt2800lib-use-the-extended-EEPROM-map-for-RT3.patch
+++ /dev/null
@@ -1,22 +0,0 @@
-From 86022438ffeb1b87dfcd018bf477fdbb43076691 Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Wed, 8 May 2013 19:35:33 +0200
-Subject: [PATCH] rt2x00: rt2800lib: use the extended EEPROM map for RT3883
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/net/wireless/ralink/rt2x00/rt2800lib.c |    3 ++-
- 1 file changed, 2 insertions(+), 1 deletion(-)
-
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -342,7 +342,8 @@ static unsigned int rt2800_eeprom_word_i
- 		      wiphy_name(rt2x00dev->hw->wiphy), word))
- 		return 0;
- 
--	if (rt2x00_rt(rt2x00dev, RT3593))
-+	if (rt2x00_rt(rt2x00dev, RT3593) ||
-+	    rt2x00_rt(rt2x00dev, RT3883))
- 		map = rt2800_eeprom_map_ext;
- 	else
- 		map = rt2800_eeprom_map;
diff --git a/package/kernel/mac80211/patches/600-0019-rt2x00-rt2800lib-force-rf-type-to-RF3853-on-RT3883.patch b/package/kernel/mac80211/patches/600-0019-rt2x00-rt2800lib-force-rf-type-to-RF3853-on-RT3883.patch
deleted file mode 100644
index bcaf676..0000000
--- a/package/kernel/mac80211/patches/600-0019-rt2x00-rt2800lib-force-rf-type-to-RF3853-on-RT3883.patch
+++ /dev/null
@@ -1,21 +0,0 @@
-From 4cf5403f02fa65dc2207f61d223cffa9ae50e907 Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Thu, 1 Aug 2013 14:48:21 +0200
-Subject: [PATCH] rt2x00: rt2800lib: force rf type to RF3853 on RT3883
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/net/wireless/ralink/rt2x00/rt2800lib.c |    2 ++
- 1 file changed, 2 insertions(+)
-
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -7588,6 +7588,8 @@ static int rt2800_init_eeprom(struct rt2
- 	    rt2x00_rt(rt2x00dev, RT5390) ||
- 	    rt2x00_rt(rt2x00dev, RT5392))
- 		rt2800_eeprom_read(rt2x00dev, EEPROM_CHIP_ID, &rf);
-+	else if (rt2x00_rt(rt2x00dev, RT3883))
-+		rf = RF3853;
- 	else
- 		rf = rt2x00_get_field16(eeprom, EEPROM_NIC_CONF0_RF_TYPE);
- 
diff --git a/package/kernel/mac80211/patches/600-0020-rt2x00-rt2800lib-add-channel-configuration-code-for-.patch b/package/kernel/mac80211/patches/600-0020-rt2x00-rt2800lib-add-channel-configuration-code-for-.patch
deleted file mode 100644
index 3169c10..0000000
--- a/package/kernel/mac80211/patches/600-0020-rt2x00-rt2800lib-add-channel-configuration-code-for-.patch
+++ /dev/null
@@ -1,136 +0,0 @@
-From 269f19c848a2380db03a3f207cafb88e28d71c53 Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Sun, 24 Mar 2013 19:26:28 +0100
-Subject: [PATCH] rt2x00: rt2800lib: add channel configuration code for RT3883
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/net/wireless/ralink/rt2x00/rt2800lib.c |   72 +++++++++++++++++++++++++++++--
- 1 file changed, 69 insertions(+), 3 deletions(-)
-
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -3406,6 +3406,36 @@ static char rt2800_txpower_to_dev(struct
- 		return clamp_t(char, txpower, MIN_A_TXPOWER, MAX_A_TXPOWER);
- }
- 
-+static void rt3883_bbp_adjust(struct rt2x00_dev *rt2x00dev,
-+			      struct rf_channel *rf)
-+{
-+	u8 bbp;
-+
-+	bbp = (rf->channel > 14) ? 0x48 : 0x38;
-+	rt2800_bbp_write_with_rx_chain(rt2x00dev, 66, bbp);
-+
-+	rt2800_bbp_write(rt2x00dev, 69, 0x12);
-+
-+	if (rf->channel <= 14) {
-+		rt2800_bbp_write(rt2x00dev, 70, 0x0a);
-+	} else {
-+		/* Disable CCK packet detection */
-+		rt2800_bbp_write(rt2x00dev, 70, 0x00);
-+	}
-+
-+	rt2800_bbp_write(rt2x00dev, 73, 0x10);
-+
-+	if (rf->channel > 14) {
-+		rt2800_bbp_write(rt2x00dev, 62, 0x1d);
-+		rt2800_bbp_write(rt2x00dev, 63, 0x1d);
-+		rt2800_bbp_write(rt2x00dev, 64, 0x1d);
-+	} else {
-+		rt2800_bbp_write(rt2x00dev, 62, 0x2d);
-+		rt2800_bbp_write(rt2x00dev, 63, 0x2d);
-+		rt2800_bbp_write(rt2x00dev, 64, 0x2d);
-+	}
-+}
-+
- static void rt2800_config_channel(struct rt2x00_dev *rt2x00dev,
- 				  struct ieee80211_conf *conf,
- 				  struct rf_channel *rf,
-@@ -3424,6 +3454,12 @@ static void rt2800_config_channel(struct
- 			rt2800_txpower_to_dev(rt2x00dev, rf->channel,
- 					      info->default_power3);
- 
-+	switch (rt2x00dev->chip.rt) {
-+	case RT3883:
-+		rt3883_bbp_adjust(rt2x00dev, rf);
-+		break;
-+	}
-+
- 	switch (rt2x00dev->chip.rf) {
- 	case RF2020:
- 	case RF3020:
-@@ -3507,6 +3543,15 @@ static void rt2800_config_channel(struct
- 		rt2800_bbp_write(rt2x00dev, 63, 0x37 - rt2x00dev->lna_gain);
- 		rt2800_bbp_write(rt2x00dev, 64, 0x37 - rt2x00dev->lna_gain);
- 		rt2800_bbp_write(rt2x00dev, 77, 0x98);
-+	} else if (rt2x00_rt(rt2x00dev, RT3883)) {
-+		rt2800_bbp_write(rt2x00dev, 62, 0x37 - rt2x00dev->lna_gain);
-+		rt2800_bbp_write(rt2x00dev, 63, 0x37 - rt2x00dev->lna_gain);
-+		rt2800_bbp_write(rt2x00dev, 64, 0x37 - rt2x00dev->lna_gain);
-+
-+		if (rt2x00dev->default_ant.rx_chain_num > 1)
-+			rt2800_bbp_write(rt2x00dev, 86, 0x46);
-+		else
-+			rt2800_bbp_write(rt2x00dev, 86, 0);
- 	} else {
- 		rt2800_bbp_write(rt2x00dev, 62, 0x37 - rt2x00dev->lna_gain);
- 		rt2800_bbp_write(rt2x00dev, 63, 0x37 - rt2x00dev->lna_gain);
-@@ -3519,6 +3564,7 @@ static void rt2800_config_channel(struct
- 		    !rt2x00_rt(rt2x00dev, RT5392)) {
- 			if (rt2x00_has_cap_external_lna_bg(rt2x00dev)) {
- 				rt2800_bbp_write(rt2x00dev, 82, 0x62);
-+				rt2800_bbp_write(rt2x00dev, 82, 0x62);
- 				rt2800_bbp_write(rt2x00dev, 75, 0x46);
- 			} else {
- 				if (rt2x00_rt(rt2x00dev, RT3593))
-@@ -3527,19 +3573,22 @@ static void rt2800_config_channel(struct
- 					rt2800_bbp_write(rt2x00dev, 82, 0x84);
- 				rt2800_bbp_write(rt2x00dev, 75, 0x50);
- 			}
--			if (rt2x00_rt(rt2x00dev, RT3593))
-+			if (rt2x00_rt(rt2x00dev, RT3593) ||
-+			    rt2x00_rt(rt2x00dev, RT3883))
- 				rt2800_bbp_write(rt2x00dev, 83, 0x8a);
- 		}
- 
- 	} else {
- 		if (rt2x00_rt(rt2x00dev, RT3572))
- 			rt2800_bbp_write(rt2x00dev, 82, 0x94);
--		else if (rt2x00_rt(rt2x00dev, RT3593))
-+		else if (rt2x00_rt(rt2x00dev, RT3593) ||
-+			 rt2x00_rt(rt2x00dev, RT3883))
- 			rt2800_bbp_write(rt2x00dev, 82, 0x82);
- 		else
- 			rt2800_bbp_write(rt2x00dev, 82, 0xf2);
- 
--		if (rt2x00_rt(rt2x00dev, RT3593))
-+		if (rt2x00_rt(rt2x00dev, RT3593) ||
-+		    rt2x00_rt(rt2x00dev, RT3883))
- 			rt2800_bbp_write(rt2x00dev, 83, 0x9a);
- 
- 		if (rt2x00_has_cap_external_lna_a(rt2x00dev))
-@@ -3661,6 +3710,23 @@ static void rt2800_config_channel(struct
- 
- 		rt2800_bbp_write_with_rx_chain(rt2x00dev, 66, reg);
- 
-+		usleep_range(1000, 1500);
-+	}
-+
-+	if (rt2x00_rt(rt2x00dev, RT3883)) {
-+		if (!conf_is_ht40(conf))
-+			rt2800_bbp_write(rt2x00dev, 105, 0x34);
-+		else
-+			rt2800_bbp_write(rt2x00dev, 105, 0x04);
-+
-+		/* AGC init */
-+		if (rf->channel <= 14)
-+			reg = 0x2e + rt2x00dev->lna_gain;
-+		else
-+			reg = 0x20 + ((rt2x00dev->lna_gain * 5) / 3);
-+
-+		rt2800_bbp_write_with_rx_chain(rt2x00dev, 66, reg);
-+
- 		usleep_range(1000, 1500);
- 	}
- 
diff --git a/package/kernel/mac80211/patches/600-0021-rt2x00-rt2800lib-fix-txpower_to_dev-function-for-RT3.patch b/package/kernel/mac80211/patches/600-0021-rt2x00-rt2800lib-fix-txpower_to_dev-function-for-RT3.patch
deleted file mode 100644
index fa646d2..0000000
--- a/package/kernel/mac80211/patches/600-0021-rt2x00-rt2800lib-fix-txpower_to_dev-function-for-RT3.patch
+++ /dev/null
@@ -1,30 +0,0 @@
-From e37d93abaabe3ab72b0332a18092acc162307274 Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Mon, 30 Sep 2013 13:57:26 +0200
-Subject: [PATCH] rt2x00: rt2800lib: fix txpower_to_dev function for RT3883
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/net/wireless/ralink/rt2x00/rt2800lib.c |    6 ++++--
- 1 file changed, 4 insertions(+), 2 deletions(-)
-
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -3393,13 +3393,15 @@ static char rt2800_txpower_to_dev(struct
- 				  unsigned int channel,
- 				  char txpower)
- {
--	if (rt2x00_rt(rt2x00dev, RT3593))
-+	if (rt2x00_rt(rt2x00dev, RT3593) ||
-+	    rt2x00_rt(rt2x00dev, RT3883))
- 		txpower = rt2x00_get_field8(txpower, EEPROM_TXPOWER_ALC);
- 
- 	if (channel <= 14)
- 		return clamp_t(char, txpower, MIN_G_TXPOWER, MAX_G_TXPOWER);
- 
--	if (rt2x00_rt(rt2x00dev, RT3593))
-+	if (rt2x00_rt(rt2x00dev, RT3593) ||
-+	    rt2x00_rt(rt2x00dev, RT3883))
- 		return clamp_t(char, txpower, MIN_A_TXPOWER_3593,
- 			       MAX_A_TXPOWER_3593);
- 	else
diff --git a/package/kernel/mac80211/patches/600-0022-rt2x00-rt2800lib-use-correct-txpower-calculation-fun.patch b/package/kernel/mac80211/patches/600-0022-rt2x00-rt2800lib-use-correct-txpower-calculation-fun.patch
deleted file mode 100644
index c068769..0000000
--- a/package/kernel/mac80211/patches/600-0022-rt2x00-rt2800lib-use-correct-txpower-calculation-fun.patch
+++ /dev/null
@@ -1,23 +0,0 @@
-From c4d79e344bd580d85821390d49f92dced7d8e125 Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Sun, 24 Mar 2013 19:26:29 +0100
-Subject: [PATCH] rt2x00: rt2800lib: use correct txpower calculation function
- for RT3883
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/net/wireless/ralink/rt2x00/rt2800lib.c |    3 ++-
- 1 file changed, 2 insertions(+), 1 deletion(-)
-
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -4612,7 +4612,8 @@ static void rt2800_config_txpower(struct
- 				  struct ieee80211_channel *chan,
- 				  int power_level)
- {
--	if (rt2x00_rt(rt2x00dev, RT3593))
-+	if (rt2x00_rt(rt2x00dev, RT3593) ||
-+	    rt2x00_rt(rt2x00dev, RT3883))
- 		rt2800_config_txpower_rt3593(rt2x00dev, chan, power_level);
- 	else
- 		rt2800_config_txpower_rt28xx(rt2x00dev, chan, power_level);
diff --git a/package/kernel/mac80211/patches/600-0023-rt2x00-rt2800lib-hardcode-txmixer-gain-values-to-zer.patch b/package/kernel/mac80211/patches/600-0023-rt2x00-rt2800lib-hardcode-txmixer-gain-values-to-zer.patch
deleted file mode 100644
index 74d80de..0000000
--- a/package/kernel/mac80211/patches/600-0023-rt2x00-rt2800lib-hardcode-txmixer-gain-values-to-zer.patch
+++ /dev/null
@@ -1,33 +0,0 @@
-From caea0671cd8fd9ade4f5969cbe0ee545e94ae105 Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Sat, 24 Aug 2013 11:49:55 +0200
-Subject: [PATCH] rt2x00: rt2800lib: hardcode txmixer gain values to zero for
- RT3883
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/net/wireless/ralink/rt2x00/rt2800lib.c |    6 ++++--
- 1 file changed, 4 insertions(+), 2 deletions(-)
-
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -7470,7 +7470,8 @@ static u8 rt2800_get_txmixer_gain_24g(st
- {
- 	u16 word;
- 
--	if (rt2x00_rt(rt2x00dev, RT3593))
-+	if (rt2x00_rt(rt2x00dev, RT3593) ||
-+	    rt2x00_rt(rt2x00dev, RT3883))
- 		return 0;
- 
- 	rt2800_eeprom_read(rt2x00dev, EEPROM_TXMIXER_GAIN_BG, &word);
-@@ -7484,7 +7485,8 @@ static u8 rt2800_get_txmixer_gain_5g(str
- {
- 	u16 word;
- 
--	if (rt2x00_rt(rt2x00dev, RT3593))
-+	if (rt2x00_rt(rt2x00dev, RT3593) ||
-+	    rt2x00_rt(rt2x00dev, RT3883))
- 		return 0;
- 
- 	rt2800_eeprom_read(rt2x00dev, EEPROM_TXMIXER_GAIN_A, &word);
diff --git a/package/kernel/mac80211/patches/600-0024-rt2x00-rt2800lib-use-correct-RT-XWI-size-for-RT3883.patch b/package/kernel/mac80211/patches/600-0024-rt2x00-rt2800lib-use-correct-RT-XWI-size-for-RT3883.patch
deleted file mode 100644
index 1259286..0000000
--- a/package/kernel/mac80211/patches/600-0024-rt2x00-rt2800lib-use-correct-RT-XWI-size-for-RT3883.patch
+++ /dev/null
@@ -1,20 +0,0 @@
-From 11c40fb47c4a4dd6ad060c2ae127ced89ffb9fe1 Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Thu, 18 Apr 2013 14:33:33 +0200
-Subject: [PATCH] rt2x00: rt2800lib: use correct [RT]XWI size for RT3883
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/net/wireless/ralink/rt2x00/rt2800lib.c |    1 +
- 1 file changed, 1 insertion(+)
-
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -558,6 +558,7 @@ void rt2800_get_txwi_rxwi_size(struct rt
- {
- 	switch (rt2x00dev->chip.rt) {
- 	case RT3593:
-+	case RT3883:
- 		*txwi_size = TXWI_DESC_SIZE_4WORDS;
- 		*rxwi_size = RXWI_DESC_SIZE_5WORDS;
- 		break;
diff --git a/package/kernel/mac80211/patches/600-0025-rt2x00-rt2800lib-use-correct-beacon-base-for-RT3883.patch b/package/kernel/mac80211/patches/600-0025-rt2x00-rt2800lib-use-correct-beacon-base-for-RT3883.patch
deleted file mode 100644
index 0dcc027..0000000
--- a/package/kernel/mac80211/patches/600-0025-rt2x00-rt2800lib-use-correct-beacon-base-for-RT3883.patch
+++ /dev/null
@@ -1,22 +0,0 @@
-From b403bdfa00665ce6b53583bdb837ffad0b91c09f Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Sun, 24 Mar 2013 19:26:29 +0100
-Subject: [PATCH] rt2x00: rt2800lib: use correct beacon base for RT3883
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/net/wireless/ralink/rt2x00/rt2800lib.c |    3 ++-
- 1 file changed, 2 insertions(+), 1 deletion(-)
-
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -983,7 +983,8 @@ EXPORT_SYMBOL_GPL(rt2800_txdone_entry);
- static unsigned int rt2800_hw_beacon_base(struct rt2x00_dev *rt2x00dev,
- 					  unsigned int index)
- {
--	if (rt2x00_rt(rt2x00dev, RT3593))
-+	if (rt2x00_rt(rt2x00dev, RT3593) ||
-+	    rt2x00_rt(rt2x00dev, RT3883))
- 		return HW_BEACON_BASE_HIGH(index);
- 
- 	return HW_BEACON_BASE(index);
diff --git a/package/kernel/mac80211/patches/600-0026-rt2x00-rt2800lib-use-correct-beacon-count-for-RT3883.patch b/package/kernel/mac80211/patches/600-0026-rt2x00-rt2800lib-use-correct-beacon-count-for-RT3883.patch
deleted file mode 100644
index 220e35f..0000000
--- a/package/kernel/mac80211/patches/600-0026-rt2x00-rt2800lib-use-correct-beacon-count-for-RT3883.patch
+++ /dev/null
@@ -1,22 +0,0 @@
-From 74b7eaf75fc6eb86292056ef705e543f9cd6086b Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Sun, 18 Aug 2013 09:57:58 +0200
-Subject: [PATCH] rt2x00: rt2800lib: use correct beacon count for RT3883
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/net/wireless/ralink/rt2x00/rt2800lib.c |    3 ++-
- 1 file changed, 2 insertions(+), 1 deletion(-)
-
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -8407,7 +8407,8 @@ int rt2800_probe_hw(struct rt2x00_dev *r
- 	if (rt2x00_rt(rt2x00dev, RT3593))
- 		__set_bit(RT2800_HAS_HIGH_SHARED_MEM, &drv_data->rt2800_flags);
- 
--	if (rt2x00_rt(rt2x00dev, RT3593))
-+	if (rt2x00_rt(rt2x00dev, RT3593) ||
-+	    rt2x00_rt(rt2x00dev, RT3883))
- 		drv_data->hw_beacon_count = 16;
- 	else
- 		drv_data->hw_beacon_count = 8;
diff --git a/package/kernel/mac80211/patches/600-0027-rt2x00-rt2800lib-fix-antenna-configuration-for-RT388.patch b/package/kernel/mac80211/patches/600-0027-rt2x00-rt2800lib-fix-antenna-configuration-for-RT388.patch
deleted file mode 100644
index 3936368..0000000
--- a/package/kernel/mac80211/patches/600-0027-rt2x00-rt2800lib-fix-antenna-configuration-for-RT388.patch
+++ /dev/null
@@ -1,22 +0,0 @@
-From fa5ad9c025610c22048add2f0ad03f62b6ca1e74 Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Mon, 30 Sep 2013 16:53:33 +0200
-Subject: [PATCH] rt2x00: rt2800lib: fix antenna configuration for RT3883
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/net/wireless/ralink/rt2x00/rt2800lib.c |    3 ++-
- 1 file changed, 2 insertions(+), 1 deletion(-)
-
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -1938,7 +1938,8 @@ void rt2800_config_ant(struct rt2x00_dev
- 	rt2800_bbp_write(rt2x00dev, 3, r3);
- 	rt2800_bbp_write(rt2x00dev, 1, r1);
- 
--	if (rt2x00_rt(rt2x00dev, RT3593)) {
-+	if (rt2x00_rt(rt2x00dev, RT3593) ||
-+	    rt2x00_rt(rt2x00dev, RT3883)) {
- 		if (ant->rx_chain_num == 1)
- 			rt2800_bbp_write(rt2x00dev, 86, 0x00);
- 		else
diff --git a/package/kernel/mac80211/patches/600-0028-rt2x00-rt2800lib-fix-LNA-gain-configuration-for-RT38.patch b/package/kernel/mac80211/patches/600-0028-rt2x00-rt2800lib-fix-LNA-gain-configuration-for-RT38.patch
deleted file mode 100644
index f028587..0000000
--- a/package/kernel/mac80211/patches/600-0028-rt2x00-rt2800lib-fix-LNA-gain-configuration-for-RT38.patch
+++ /dev/null
@@ -1,32 +0,0 @@
-From 6d668fef3a1baa60bdd715ee062ddb6333d2647c Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Mon, 30 Sep 2013 16:58:23 +0200
-Subject: [PATCH] rt2x00: rt2800lib: fix LNA gain configuration for RT3883
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/net/wireless/ralink/rt2x00/rt2800lib.c |    6 ++++--
- 1 file changed, 4 insertions(+), 2 deletions(-)
-
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -1961,7 +1961,8 @@ static void rt2800_config_lna_gain(struc
- 		rt2800_eeprom_read(rt2x00dev, EEPROM_LNA, &eeprom);
- 		lna_gain = rt2x00_get_field16(eeprom, EEPROM_LNA_A0);
- 	} else if (libconf->rf.channel <= 128) {
--		if (rt2x00_rt(rt2x00dev, RT3593)) {
-+		if (rt2x00_rt(rt2x00dev, RT3593) ||
-+		    rt2x00_rt(rt2x00dev, RT3883)) {
- 			rt2800_eeprom_read(rt2x00dev, EEPROM_EXT_LNA2, &eeprom);
- 			lna_gain = rt2x00_get_field16(eeprom,
- 						      EEPROM_EXT_LNA2_A1);
-@@ -1971,7 +1972,8 @@ static void rt2800_config_lna_gain(struc
- 						      EEPROM_RSSI_BG2_LNA_A1);
- 		}
- 	} else {
--		if (rt2x00_rt(rt2x00dev, RT3593)) {
-+		if (rt2x00_rt(rt2x00dev, RT3593) ||
-+		    rt2x00_rt(rt2x00dev, RT3883)) {
- 			rt2800_eeprom_read(rt2x00dev, EEPROM_EXT_LNA2, &eeprom);
- 			lna_gain = rt2x00_get_field16(eeprom,
- 						      EEPROM_EXT_LNA2_A2);
diff --git a/package/kernel/mac80211/patches/600-0029-rt2x00-rt2800lib-fix-VGC-setup-for-RT3883.patch b/package/kernel/mac80211/patches/600-0029-rt2x00-rt2800lib-fix-VGC-setup-for-RT3883.patch
deleted file mode 100644
index ab8c625..0000000
--- a/package/kernel/mac80211/patches/600-0029-rt2x00-rt2800lib-fix-VGC-setup-for-RT3883.patch
+++ /dev/null
@@ -1,44 +0,0 @@
-From c49b2d829aa1c816a46a577cdec6d2ff14d9f06e Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Tue, 1 Oct 2013 15:40:08 +0200
-Subject: [PATCH] rt2x00: rt2800lib: fix VGC setup for RT3883
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/net/wireless/ralink/rt2x00/rt2800lib.c |   11 +++++++++--
- 1 file changed, 9 insertions(+), 2 deletions(-)
-
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -4812,7 +4812,8 @@ static u8 rt2800_get_default_vgc(struct
- 		else
- 			vgc = 0x2e + rt2x00dev->lna_gain;
- 	} else { /* 5GHZ band */
--		if (rt2x00_rt(rt2x00dev, RT3593))
-+		if (rt2x00_rt(rt2x00dev, RT3593) ||
-+		    rt2x00_rt(rt2x00dev, RT3883))
- 			vgc = 0x20 + (rt2x00dev->lna_gain * 5) / 3;
- 		else if (rt2x00_rt(rt2x00dev, RT5592))
- 			vgc = 0x24 + (2 * rt2x00dev->lna_gain);
-@@ -4832,7 +4833,8 @@ static inline void rt2800_set_vgc(struct
- {
- 	if (qual->vgc_level != vgc_level) {
- 		if (rt2x00_rt(rt2x00dev, RT3572) ||
--		    rt2x00_rt(rt2x00dev, RT3593)) {
-+		    rt2x00_rt(rt2x00dev, RT3593) ||
-+		    rt2x00_rt(rt2x00dev, RT3883)) {
- 			rt2800_bbp_write_with_rx_chain(rt2x00dev, 66,
- 						       vgc_level);
- 		} else if (rt2x00_rt(rt2x00dev, RT5592)) {
-@@ -4879,6 +4881,11 @@ void rt2800_link_tuner(struct rt2x00_dev
- 		}
- 		break;
- 
-+	case RT3883:
-+		if (qual->rssi > -65)
-+			vgc += 0x10;
-+		break;
-+
- 	case RT5592:
- 		if (qual->rssi > -65)
- 			vgc += 0x20;
diff --git a/package/kernel/mac80211/patches/600-0030-rt2x00-rt2800lib-fix-EEPROM-LNA-validation-for-RT388.patch b/package/kernel/mac80211/patches/600-0030-rt2x00-rt2800lib-fix-EEPROM-LNA-validation-for-RT388.patch
deleted file mode 100644
index 49830a1..0000000
--- a/package/kernel/mac80211/patches/600-0030-rt2x00-rt2800lib-fix-EEPROM-LNA-validation-for-RT388.patch
+++ /dev/null
@@ -1,42 +0,0 @@
-From 1616650aea676541d4dc8adc6f4219856d193c8b Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Tue, 1 Oct 2013 17:27:57 +0200
-Subject: [PATCH] rt2x00: rt2800lib: fix EEPROM LNA validation for RT3883
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/net/wireless/ralink/rt2x00/rt2800lib.c |    9 ++++++---
- 1 file changed, 6 insertions(+), 3 deletions(-)
-
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -7607,7 +7607,8 @@ static int rt2800_validate_eeprom(struct
- 	rt2800_eeprom_read(rt2x00dev, EEPROM_RSSI_BG2, &word);
- 	if (abs(rt2x00_get_field16(word, EEPROM_RSSI_BG2_OFFSET2)) > 10)
- 		rt2x00_set_field16(&word, EEPROM_RSSI_BG2_OFFSET2, 0);
--	if (!rt2x00_rt(rt2x00dev, RT3593)) {
-+	if (!rt2x00_rt(rt2x00dev, RT3593) &&
-+	    !rt2x00_rt(rt2x00dev, RT3883)) {
- 		if (rt2x00_get_field16(word, EEPROM_RSSI_BG2_LNA_A1) == 0x00 ||
- 		    rt2x00_get_field16(word, EEPROM_RSSI_BG2_LNA_A1) == 0xff)
- 			rt2x00_set_field16(&word, EEPROM_RSSI_BG2_LNA_A1,
-@@ -7627,7 +7628,8 @@ static int rt2800_validate_eeprom(struct
- 	rt2800_eeprom_read(rt2x00dev, EEPROM_RSSI_A2, &word);
- 	if (abs(rt2x00_get_field16(word, EEPROM_RSSI_A2_OFFSET2)) > 10)
- 		rt2x00_set_field16(&word, EEPROM_RSSI_A2_OFFSET2, 0);
--	if (!rt2x00_rt(rt2x00dev, RT3593)) {
-+	if (!rt2x00_rt(rt2x00dev, RT3593) &&
-+	    !rt2x00_rt(rt2x00dev, RT3883)) {
- 		if (rt2x00_get_field16(word, EEPROM_RSSI_A2_LNA_A2) == 0x00 ||
- 		    rt2x00_get_field16(word, EEPROM_RSSI_A2_LNA_A2) == 0xff)
- 			rt2x00_set_field16(&word, EEPROM_RSSI_A2_LNA_A2,
-@@ -7635,7 +7637,8 @@ static int rt2800_validate_eeprom(struct
- 	}
- 	rt2800_eeprom_write(rt2x00dev, EEPROM_RSSI_A2, word);
- 
--	if (rt2x00_rt(rt2x00dev, RT3593)) {
-+	if (rt2x00_rt(rt2x00dev, RT3593) ||
-+	    rt2x00_rt(rt2x00dev, RT3883)) {
- 		rt2800_eeprom_read(rt2x00dev, EEPROM_EXT_LNA2, &word);
- 		if (rt2x00_get_field16(word, EEPROM_EXT_LNA2_A1) == 0x00 ||
- 		    rt2x00_get_field16(word, EEPROM_EXT_LNA2_A1) == 0xff)
diff --git a/package/kernel/mac80211/patches/600-0031-rt2x00-rt2800lib-fix-txpower-compensation-for-RT3883.patch b/package/kernel/mac80211/patches/600-0031-rt2x00-rt2800lib-fix-txpower-compensation-for-RT3883.patch
deleted file mode 100644
index 6e22847..0000000
--- a/package/kernel/mac80211/patches/600-0031-rt2x00-rt2800lib-fix-txpower-compensation-for-RT3883.patch
+++ /dev/null
@@ -1,22 +0,0 @@
-From e3871034a0e7c8a95152dc3eafbcc4535398cbdc Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Wed, 2 Oct 2013 10:11:59 +0200
-Subject: [PATCH] rt2x00: rt2800lib: fix txpower compensation for RT3883
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/net/wireless/ralink/rt2x00/rt2800lib.c |    3 +++
- 1 file changed, 3 insertions(+)
-
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -3982,6 +3982,9 @@ static u8 rt2800_compensate_txpower(stru
- 	if (rt2x00_rt(rt2x00dev, RT3593))
- 		return min_t(u8, txpower, 0xc);
- 
-+	if (rt2x00_rt(rt2x00dev, RT3883))
-+		return min_t(u8, txpower, 0xf);
-+
- 	if (rt2x00_has_cap_power_limit(rt2x00dev)) {
- 		/*
- 		 * Check if eirp txpower exceed txpower_limit.
diff --git a/package/kernel/mac80211/patches/600-0032-rt2x00-rt2800lib-enable-RT2800_HAS_HIGH_SHARED_MEM-f.patch b/package/kernel/mac80211/patches/600-0032-rt2x00-rt2800lib-enable-RT2800_HAS_HIGH_SHARED_MEM-f.patch
deleted file mode 100644
index 2ffa5a4..0000000
--- a/package/kernel/mac80211/patches/600-0032-rt2x00-rt2800lib-enable-RT2800_HAS_HIGH_SHARED_MEM-f.patch
+++ /dev/null
@@ -1,23 +0,0 @@
-From f6734ec72da936989a8ce4186b3ede28fbc47836 Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Sun, 18 Aug 2013 21:57:34 +0200
-Subject: [PATCH] rt2x00: rt2800lib: enable RT2800_HAS_HIGH_SHARED_MEM for
- RT3883
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/net/wireless/ralink/rt2x00/rt2800lib.c |    3 ++-
- 1 file changed, 2 insertions(+), 1 deletion(-)
-
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -8420,7 +8420,8 @@ int rt2800_probe_hw(struct rt2x00_dev *r
- 	if (retval)
- 		return retval;
- 
--	if (rt2x00_rt(rt2x00dev, RT3593))
-+	if (rt2x00_rt(rt2x00dev, RT3593) ||
-+	    rt2x00_rt(rt2x00dev, RT3883))
- 		__set_bit(RT2800_HAS_HIGH_SHARED_MEM, &drv_data->rt2800_flags);
- 
- 	if (rt2x00_rt(rt2x00dev, RT3593) ||
diff --git a/package/kernel/mac80211/patches/600-0033-rt2x00-rt2800lib-use-high-memory-for-beacons-on-RT38.patch b/package/kernel/mac80211/patches/600-0033-rt2x00-rt2800lib-use-high-memory-for-beacons-on-RT38.patch
deleted file mode 100644
index 4f2e754..0000000
--- a/package/kernel/mac80211/patches/600-0033-rt2x00-rt2800lib-use-high-memory-for-beacons-on-RT38.patch
+++ /dev/null
@@ -1,22 +0,0 @@
-From f1acfc2f397e86548ae1b479c198d4bef57050f6 Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Sun, 29 Sep 2013 18:10:34 +0200
-Subject: [PATCH] rt2x00: rt2800lib: use high memory for beacons on RT3883
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/net/wireless/ralink/rt2x00/rt2800lib.c |    3 ++-
- 1 file changed, 2 insertions(+), 1 deletion(-)
-
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -97,7 +97,8 @@ static inline void rt2800_shared_mem_sel
- 
- static inline bool rt2800_beacon_uses_high_mem(struct rt2x00_dev *rt2x00dev)
- {
--	if (rt2x00_rt(rt2x00dev, RT3593))
-+	if (rt2x00_rt(rt2x00dev, RT3593) ||
-+	    rt2x00_rt(rt2x00dev, RT3883))
- 		return true;
- 
- 	return false;
diff --git a/package/kernel/mac80211/patches/600-0034-rt2x00-rt2800mmio-add-a-workaround-for-spurious-TX_F.patch b/package/kernel/mac80211/patches/600-0034-rt2x00-rt2800mmio-add-a-workaround-for-spurious-TX_F.patch
deleted file mode 100644
index a497b5e..0000000
--- a/package/kernel/mac80211/patches/600-0034-rt2x00-rt2800mmio-add-a-workaround-for-spurious-TX_F.patch
+++ /dev/null
@@ -1,136 +0,0 @@
-From 5e67d4f8a46d19748b501c2ef86de3f50d3cfd51 Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Sun, 24 Mar 2013 19:26:27 +0100
-Subject: [PATCH] rt2x00: rt2800mmio: add a workaround for spurious
- TX_FIFO_STATUS interrupts
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/net/wireless/ralink/rt2x00/rt2800mmio.c |   72 +++++++++++++++++++++++++-----
- drivers/net/wireless/ralink/rt2x00/rt2x00.h     |    5 +++
- 2 files changed, 65 insertions(+), 12 deletions(-)
-
---- a/drivers/net/wireless/ralink/rt2x00/rt2800mmio.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800mmio.c
-@@ -415,9 +415,9 @@ void rt2800mmio_autowake_tasklet(unsigne
- }
- EXPORT_SYMBOL_GPL(rt2800mmio_autowake_tasklet);
- 
--static void rt2800mmio_txstatus_interrupt(struct rt2x00_dev *rt2x00dev)
-+static void rt2800mmio_txstatus_interrupt(struct rt2x00_dev *rt2x00dev,
-+					  u32 status)
- {
--	u32 status;
- 	int i;
- 
- 	/*
-@@ -438,29 +438,77 @@ static void rt2800mmio_txstatus_interrup
- 	 * Since we have only one producer and one consumer we don't
- 	 * need to lock the kfifo.
- 	 */
--	for (i = 0; i < rt2x00dev->tx->limit; i++) {
--		rt2x00mmio_register_read(rt2x00dev, TX_STA_FIFO, &status);
--
--		if (!rt2x00_get_field32(status, TX_STA_FIFO_VALID))
--			break;
--
-+	i = 0;
-+	do {
- 		if (!kfifo_put(&rt2x00dev->txstatus_fifo, status)) {
--			rt2x00_warn(rt2x00dev, "TX status FIFO overrun, drop tx status report\n");
-+			rt2x00_warn(rt2x00dev,
-+				    "TX status FIFO overrun, drop TX status report\n");
- 			break;
- 		}
--	}
-+
-+		if (++i >= rt2x00dev->tx->limit)
-+			break;
-+
-+ 		rt2x00mmio_register_read(rt2x00dev, TX_STA_FIFO, &status);
-+	} while (rt2x00_get_field32(status, TX_STA_FIFO_VALID));
- 
- 	/* Schedule the tasklet for processing the tx status. */
- 	tasklet_schedule(&rt2x00dev->txstatus_tasklet);
- }
- 
-+#define RT2800MMIO_TXSTATUS_IRQ_MAX_RETRIES	4
-+
-+static bool rt2800mmio_txstatus_is_spurious(struct rt2x00_dev *rt2x00dev,
-+					   u32 txstatus)
-+{
-+	if (likely(rt2x00_get_field32(txstatus, TX_STA_FIFO_VALID))) {
-+		rt2x00dev->txstatus_irq_retries = 0;
-+		return false;
-+	}
-+
-+	rt2x00dev->txstatus_irq_retries++;
-+
-+	/* Ensure that we don't go into an infinite IRQ loop. */
-+	if (rt2x00dev->txstatus_irq_retries >=
-+	    RT2800MMIO_TXSTATUS_IRQ_MAX_RETRIES) {
-+		rt2x00_warn(rt2x00dev,
-+			    "%u spurious TX_FIFO_STATUS interrupt(s)\n",
-+			    rt2x00dev->txstatus_irq_retries);
-+		rt2x00dev->txstatus_irq_retries = 0;
-+		return false;
-+	}
-+
-+	return true;
-+}
-+
- irqreturn_t rt2800mmio_interrupt(int irq, void *dev_instance)
- {
- 	struct rt2x00_dev *rt2x00dev = dev_instance;
- 	u32 reg, mask;
-+	u32 txstatus = 0;
- 
--	/* Read status and ACK all interrupts */
-+	/* Read status */
- 	rt2x00mmio_register_read(rt2x00dev, INT_SOURCE_CSR, &reg);
-+
-+	if (rt2x00_get_field32(reg, INT_SOURCE_CSR_TX_FIFO_STATUS)) {
-+		/* Due to unknown reason the hardware generates a
-+		 * TX_FIFO_STATUS interrupt before the TX_STA_FIFO
-+		 * register contain valid data. Read the TX status
-+		 * here to see if we have to process the actual
-+		 * request.
-+		 */
-+		rt2x00mmio_register_read(rt2x00dev, TX_STA_FIFO, &txstatus);
-+		if (rt2800mmio_txstatus_is_spurious(rt2x00dev, txstatus)) {
-+			/* Remove the TX_FIFO_STATUS bit so it won't be
-+			 * processed in this turn. The hardware will
-+			 * generate another IRQ for us.
-+			 */
-+			rt2x00_set_field32(&reg,
-+					   INT_SOURCE_CSR_TX_FIFO_STATUS, 0);
-+		}
-+	}
-+
-+	/* ACK interrupts */
- 	rt2x00mmio_register_write(rt2x00dev, INT_SOURCE_CSR, reg);
- 
- 	if (!reg)
-@@ -477,7 +525,7 @@ irqreturn_t rt2800mmio_interrupt(int irq
- 	mask = ~reg;
- 
- 	if (rt2x00_get_field32(reg, INT_SOURCE_CSR_TX_FIFO_STATUS)) {
--		rt2800mmio_txstatus_interrupt(rt2x00dev);
-+		rt2800mmio_txstatus_interrupt(rt2x00dev, txstatus);
- 		/*
- 		 * Never disable the TX_FIFO_STATUS interrupt.
- 		 */
---- a/drivers/net/wireless/ralink/rt2x00/rt2x00.h
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
-@@ -991,6 +991,11 @@ struct rt2x00_dev {
- 	int rf_channel;
- 
- 	/*
-+	 * Counter for tx status irq retries (rt2800pci).
-+	 */
-+	unsigned int txstatus_irq_retries;
-+
-+	/*
- 	 * Protect the interrupt mask register.
- 	 */
- 	spinlock_t irqmask_lock;
diff --git a/package/kernel/mac80211/patches/601-rt2x00-set_pci_mwi.patch b/package/kernel/mac80211/patches/601-rt2x00-set_pci_mwi.patch
deleted file mode 100644
index a407161..0000000
--- a/package/kernel/mac80211/patches/601-rt2x00-set_pci_mwi.patch
+++ /dev/null
@@ -1,13 +0,0 @@
---- a/drivers/net/wireless/ralink/rt2x00/rt2x00pci.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00pci.c
-@@ -94,8 +94,10 @@ int rt2x00pci_probe(struct pci_dev *pci_
- 
- 	pci_set_master(pci_dev);
- 
-+#ifdef CONFIG_PCI_SET_MWI
- 	if (pci_set_mwi(pci_dev))
- 		rt2x00_probe_err("MWI not available\n");
-+#endif
- 
- 	if (dma_set_mask(&pci_dev->dev, DMA_BIT_MASK(32))) {
- 		rt2x00_probe_err("PCI DMA not supported\n");
diff --git a/package/kernel/mac80211/patches/602-rt2x00-introduce-rt2x00_platform_h.patch b/package/kernel/mac80211/patches/602-rt2x00-introduce-rt2x00_platform_h.patch
deleted file mode 100644
index daa5dc6..0000000
--- a/package/kernel/mac80211/patches/602-rt2x00-introduce-rt2x00_platform_h.patch
+++ /dev/null
@@ -1,32 +0,0 @@
---- /dev/null
-+++ b/include/linux/rt2x00_platform.h
-@@ -0,0 +1,19 @@
-+/*
-+ * Platform data definition for the rt2x00 driver
-+ *
-+ * Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
-+ *
-+ * This program is free software; you can redistribute it and/or modify it
-+ * under the terms of the GNU General Public License version 2 as published
-+ * by the Free Software Foundation.
-+ *
-+ */
-+
-+#ifndef _RT2X00_PLATFORM_H
-+#define _RT2X00_PLATFORM_H
-+
-+struct rt2x00_platform_data {
-+	char *eeprom_file_name;
-+};
-+
-+#endif /* _RT2X00_PLATFORM_H */
---- a/drivers/net/wireless/ralink/rt2x00/rt2x00.h
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
-@@ -39,6 +39,7 @@
- #include <linux/hrtimer.h>
- #include <linux/average.h>
- #include <linux/usb.h>
-+#include <linux/rt2x00_platform.h>
- 
- #include <net/mac80211.h>
- 
diff --git a/package/kernel/mac80211/patches/603-rt2x00-introduce-rt2x00eeprom.patch b/package/kernel/mac80211/patches/603-rt2x00-introduce-rt2x00eeprom.patch
deleted file mode 100644
index 8ae5da3..0000000
--- a/package/kernel/mac80211/patches/603-rt2x00-introduce-rt2x00eeprom.patch
+++ /dev/null
@@ -1,301 +0,0 @@
---- a/.local-symbols
-+++ b/.local-symbols
-@@ -331,6 +331,7 @@ RT2X00_LIB_FIRMWARE=
- RT2X00_LIB_CRYPTO=
- RT2X00_LIB_LEDS=
- RT2X00_LIB_DEBUGFS=
-+RT2X00_LIB_EEPROM=
- RT2X00_DEBUG=
- WLAN_VENDOR_REALTEK=
- RTL8180=
---- a/drivers/net/wireless/ralink/rt2x00/Kconfig
-+++ b/drivers/net/wireless/ralink/rt2x00/Kconfig
-@@ -69,6 +69,7 @@ config RT2800PCI
- 	select RT2X00_LIB_MMIO
- 	select RT2X00_LIB_PCI
- 	select RT2X00_LIB_FIRMWARE
-+	select RT2X00_LIB_EEPROM
- 	select RT2X00_LIB_CRYPTO
- 	depends on CRC_CCITT
- 	depends on EEPROM_93CX6
-@@ -215,6 +216,7 @@ config RT2800SOC
- 	select RT2X00_LIB_MMIO
- 	select RT2X00_LIB_CRYPTO
- 	select RT2X00_LIB_FIRMWARE
-+	select RT2X00_LIB_EEPROM
- 	select RT2800_LIB
- 	select RT2800_LIB_MMIO
- 	---help---
-@@ -265,6 +267,9 @@ config RT2X00_LIB_FIRMWARE
- config RT2X00_LIB_CRYPTO
- 	bool
- 
-+config RT2X00_LIB_EEPROM
-+	boolean
-+
- config RT2X00_LIB_LEDS
- 	bool
- 	default y if (RT2X00_LIB=y && LEDS_CLASS=y) || (RT2X00_LIB=m && LEDS_CLASS!=n)
---- a/drivers/net/wireless/ralink/rt2x00/Makefile
-+++ b/drivers/net/wireless/ralink/rt2x00/Makefile
-@@ -7,6 +7,7 @@ rt2x00lib-$(CPTCFG_RT2X00_LIB_DEBUGFS)	+
- rt2x00lib-$(CPTCFG_RT2X00_LIB_CRYPTO)	+= rt2x00crypto.o
- rt2x00lib-$(CPTCFG_RT2X00_LIB_FIRMWARE)	+= rt2x00firmware.o
- rt2x00lib-$(CPTCFG_RT2X00_LIB_LEDS)	+= rt2x00leds.o
-+rt2x00lib-$(CPTCFG_RT2X00_LIB_EEPROM)	+= rt2x00eeprom.o
- 
- obj-$(CPTCFG_RT2X00_LIB)		+= rt2x00lib.o
- obj-$(CPTCFG_RT2X00_LIB_MMIO)		+= rt2x00mmio.o
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
-@@ -46,6 +46,8 @@ struct rt2800_drv_data {
- 	} shmem_lock;
- };
- 
-+#include "rt2800.h"
-+
- struct rt2800_ops {
- 	void (*register_read)(struct rt2x00_dev *rt2x00dev,
- 			      const unsigned int offset, u32 *value);
-@@ -179,6 +181,15 @@ static inline int rt2800_read_eeprom(str
- {
- 	const struct rt2800_ops *rt2800ops = rt2x00dev->ops->drv;
- 
-+	if (rt2x00dev->eeprom_file) {
-+		memcpy(rt2x00dev->eeprom, rt2x00dev->eeprom_file->data,
-+		       EEPROM_SIZE);
-+		return 0;
-+	}
-+
-+	if (!rt2800ops->read_eeprom)
-+		return -EINVAL;
-+
- 	return rt2800ops->read_eeprom(rt2x00dev);
- }
- 
---- a/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
-@@ -102,19 +102,6 @@ static int rt2800soc_set_device_state(st
- 	return retval;
- }
- 
--static int rt2800soc_read_eeprom(struct rt2x00_dev *rt2x00dev)
--{
--	void __iomem *base_addr = ioremap(0x1F040000, EEPROM_SIZE);
--
--	if (!base_addr)
--		return -ENOMEM;
--
--	memcpy_fromio(rt2x00dev->eeprom, base_addr, EEPROM_SIZE);
--
--	iounmap(base_addr);
--	return 0;
--}
--
- /* Firmware functions */
- static char *rt2800soc_get_firmware_name(struct rt2x00_dev *rt2x00dev)
- {
-@@ -178,7 +165,6 @@ static const struct rt2800_ops rt2800soc
- 	.register_multiread	= rt2x00mmio_register_multiread,
- 	.register_multiwrite	= rt2x00mmio_register_multiwrite,
- 	.regbusy_read		= rt2x00mmio_regbusy_read,
--	.read_eeprom		= rt2800soc_read_eeprom,
- 	.hwcrypt_disabled	= rt2800soc_hwcrypt_disabled,
- 	.drv_write_firmware	= rt2800soc_write_firmware,
- 	.drv_init_registers	= rt2800mmio_init_registers,
---- a/drivers/net/wireless/ralink/rt2x00/rt2x00.h
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
-@@ -699,6 +699,7 @@ enum rt2x00_capability_flags {
- 	REQUIRE_HT_TX_DESC,
- 	REQUIRE_PS_AUTOWAKE,
- 	REQUIRE_DELAYED_RFKILL,
-+	REQUIRE_EEPROM_FILE,
- 
- 	/*
- 	 * Capabilities
-@@ -968,6 +969,11 @@ struct rt2x00_dev {
- 	const struct firmware *fw;
- 
- 	/*
-+	 * EEPROM image.
-+	 */
-+	const struct firmware *eeprom_file;
-+
-+	/*
- 	 * FIFO for storing tx status reports between isr and tasklet.
- 	 */
- 	DECLARE_KFIFO_PTR(txstatus_fifo, u32);
---- a/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
-@@ -1334,6 +1334,10 @@ int rt2x00lib_probe_dev(struct rt2x00_de
- 	INIT_DELAYED_WORK(&rt2x00dev->autowakeup_work, rt2x00lib_autowakeup);
- 	INIT_WORK(&rt2x00dev->sleep_work, rt2x00lib_sleep);
- 
-+	retval = rt2x00lib_load_eeprom_file(rt2x00dev);
-+	if (retval)
-+		goto exit;
-+
- 	/*
- 	 * Let the driver probe the device to detect the capabilities.
- 	 */
-@@ -1477,6 +1481,11 @@ void rt2x00lib_remove_dev(struct rt2x00_
- 	 * Free the driver data.
- 	 */
- 	kfree(rt2x00dev->drv_data);
-+
-+	/*
-+	 * Free EEPROM image.
-+	 */
-+	rt2x00lib_free_eeprom_file(rt2x00dev);
- }
- EXPORT_SYMBOL_GPL(rt2x00lib_remove_dev);
- 
---- /dev/null
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00eeprom.c
-@@ -0,0 +1,111 @@
-+/*
-+	Copyright (C) 2004 - 2009 Ivo van Doorn <IvDoorn@gmail.com>
-+	Copyright (C) 2004 - 2009 Gertjan van Wingerde <gwingerde@gmail.com>
-+	<http://rt2x00.serialmonkey.com>
-+
-+	This program is free software; you can redistribute it and/or modify
-+	it under the terms of the GNU General Public License as published by
-+	the Free Software Foundation; either version 2 of the License, or
-+	(at your option) any later version.
-+
-+	This program is distributed in the hope that it will be useful,
-+	but WITHOUT ANY WARRANTY; without even the implied warranty of
-+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-+	GNU General Public License for more details.
-+
-+	You should have received a copy of the GNU General Public License
-+	along with this program; if not, write to the
-+	Free Software Foundation, Inc.,
-+	59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
-+ */
-+
-+/*
-+	Module: rt2x00lib
-+	Abstract: rt2x00 eeprom file loading routines.
-+ */
-+
-+#include <linux/kernel.h>
-+#include <linux/module.h>
-+
-+#include "rt2x00.h"
-+#include "rt2x00lib.h"
-+
-+static const char *
-+rt2x00lib_get_eeprom_file_name(struct rt2x00_dev *rt2x00dev)
-+{
-+	struct rt2x00_platform_data *pdata = rt2x00dev->dev->platform_data;
-+
-+	if (pdata && pdata->eeprom_file_name)
-+		return pdata->eeprom_file_name;
-+
-+	return NULL
-+}
-+
-+static int rt2x00lib_request_eeprom_file(struct rt2x00_dev *rt2x00dev)
-+{
-+	const struct firmware *ee;
-+	const char *ee_name;
-+	int retval;
-+
-+	ee_name = rt2x00lib_get_eeprom_file_name(rt2x00dev);
-+	if (!ee_name) {
-+		rt2x00_err(rt2x00dev,
-+			   "Invalid EEPROM filename.\n"
-+			   "Please file bug report to %s.\n", DRV_PROJECT);
-+		return -EINVAL;
-+	}
-+
-+	rt2x00_info(rt2x00dev, "Loading EEPROM data from '%s'.\n", ee_name);
-+
-+	retval = request_firmware(&ee, ee_name, rt2x00dev->dev);
-+	if (retval) {
-+		rt2x00_err(rt2x00dev, "Failed to request EEPROM.\n");
-+		return retval;
-+	}
-+
-+	if (!ee || !ee->size || !ee->data) {
-+		rt2x00_err(rt2x00dev, "Failed to read EEPROM file.\n");
-+		retval = -ENOENT;
-+		goto err_exit;
-+	}
-+
-+	if (ee->size != rt2x00dev->ops->eeprom_size) {
-+		rt2x00_err(rt2x00dev,
-+			   "EEPROM file size is invalid, it should be %d bytes\n",
-+			   rt2x00dev->ops->eeprom_size);
-+		retval = -EINVAL;
-+		goto err_release_ee;
-+	}
-+
-+	rt2x00dev->eeprom_file = ee;
-+	return 0;
-+
-+err_release_ee:
-+	release_firmware(ee);
-+err_exit:
-+	return retval;
-+}
-+
-+int rt2x00lib_load_eeprom_file(struct rt2x00_dev *rt2x00dev)
-+{
-+	int retval;
-+
-+	if (!rt2x00lib_get_eeprom_file_name(rt2x00dev))
-+		return 0;
-+
-+	set_bit(REQUIRE_EEPROM_FILE, &rt2x00dev->cap_flags);
-+
-+	if (!rt2x00dev->eeprom_file) {
-+		retval = rt2x00lib_request_eeprom_file(rt2x00dev);
-+		if (retval)
-+			return retval;
-+	}
-+
-+	return 0;
-+}
-+
-+void rt2x00lib_free_eeprom_file(struct rt2x00_dev *rt2x00dev)
-+{
-+	release_firmware(rt2x00dev->eeprom_file);
-+	rt2x00dev->eeprom_file = NULL;
-+}
---- a/drivers/net/wireless/ralink/rt2x00/rt2x00lib.h
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00lib.h
-@@ -320,6 +320,22 @@ static inline void rt2x00lib_free_firmwa
- #endif /* CPTCFG_RT2X00_LIB_FIRMWARE */
- 
- /*
-+ * EEPROM file handlers.
-+ */
-+#ifdef CPTCFG_RT2X00_LIB_EEPROM
-+int rt2x00lib_load_eeprom_file(struct rt2x00_dev *rt2x00dev);
-+void rt2x00lib_free_eeprom_file(struct rt2x00_dev *rt2x00dev);
-+#else
-+static inline int rt2x00lib_load_eeprom_file(struct rt2x00_dev *rt2x00dev)
-+{
-+	return 0;
-+}
-+static inline void rt2x00lib_free_eeprom_file(struct rt2x00_dev *rt2x00dev)
-+{
-+}
-+#endif /* CPTCFG_RT2X00_LIB_EEPROM */
-+
-+/*
-  * Debugfs handlers.
-  */
- #ifdef CPTCFG_RT2X00_LIB_DEBUGFS
---- a/drivers/net/wireless/ralink/rt2x00/rt2x00soc.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00soc.c
-@@ -92,6 +92,7 @@ int rt2x00soc_probe(struct platform_devi
- 	rt2x00dev->hw = hw;
- 	rt2x00dev->irq = platform_get_irq(pdev, 0);
- 	rt2x00dev->name = pdev->dev.driver->name;
-+	set_bit(REQUIRE_EEPROM_FILE, &rt2x00dev->cap_flags);
- 
- 	rt2x00_set_chip_intf(rt2x00dev, RT2X00_CHIP_INTF_SOC);
- 
diff --git a/package/kernel/mac80211/patches/604-rt2x00-of_load_eeprom_filename.patch b/package/kernel/mac80211/patches/604-rt2x00-of_load_eeprom_filename.patch
deleted file mode 100644
index 9dffef1..0000000
--- a/package/kernel/mac80211/patches/604-rt2x00-of_load_eeprom_filename.patch
+++ /dev/null
@@ -1,33 +0,0 @@
---- a/drivers/net/wireless/ralink/rt2x00/rt2x00eeprom.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00eeprom.c
-@@ -26,6 +26,7 @@
- 
- #include <linux/kernel.h>
- #include <linux/module.h>
-+#include <linux/of.h>
- 
- #include "rt2x00.h"
- #include "rt2x00lib.h"
-@@ -34,11 +35,21 @@ static const char *
- rt2x00lib_get_eeprom_file_name(struct rt2x00_dev *rt2x00dev)
- {
- 	struct rt2x00_platform_data *pdata = rt2x00dev->dev->platform_data;
-+#ifdef CONFIG_OF
-+	struct device_node *np;
-+	const char *eep;
-+#endif
- 
- 	if (pdata && pdata->eeprom_file_name)
- 		return pdata->eeprom_file_name;
- 
--	return NULL
-+#ifdef CONFIG_OF
-+	np = rt2x00dev->dev->of_node;
-+	if (np && of_property_read_string(np, "ralink,eeprom", &eep) == 0)
-+	    return eep;
-+#endif
-+
-+	return NULL;
- }
- 
- static int rt2x00lib_request_eeprom_file(struct rt2x00_dev *rt2x00dev)
diff --git a/package/kernel/mac80211/patches/605-rt2x00-load-eeprom-on-SoC-from-a-mtd-device-defines-.patch b/package/kernel/mac80211/patches/605-rt2x00-load-eeprom-on-SoC-from-a-mtd-device-defines-.patch
deleted file mode 100644
index 5dceff8..0000000
--- a/package/kernel/mac80211/patches/605-rt2x00-load-eeprom-on-SoC-from-a-mtd-device-defines-.patch
+++ /dev/null
@@ -1,101 +0,0 @@
-From 339fe73f340161a624cc08e738d2244814852c3e Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Sun, 17 Mar 2013 00:55:04 +0100
-Subject: [PATCH] rt2x00: load eeprom on SoC from a mtd device defines inside
- OF
-
-Signed-off-by: John Crispin <blogic@openwrt.org>
----
- drivers/net/wireless/ralink/rt2x00/Kconfig     |    1 +
- drivers/net/wireless/ralink/rt2x00/rt2800pci.c |   44 ++++++++++++++++++++++++++-----
- 2 files changed, 39 insertions(+), 6 deletions(-)
-
---- a/drivers/net/wireless/ralink/rt2x00/Kconfig
-+++ b/drivers/net/wireless/ralink/rt2x00/Kconfig
-@@ -219,6 +219,7 @@ config RT2800SOC
- 	select RT2X00_LIB_EEPROM
- 	select RT2800_LIB
- 	select RT2800_LIB_MMIO
-+	select MTD if SOC_RT288X || SOC_RT305X
- 	---help---
- 	  This adds support for Ralink WiSoC devices.
- 	  Supported chips: RT2880, RT3050, RT3052, RT3350, RT3352.
---- a/drivers/net/wireless/ralink/rt2x00/rt2x00eeprom.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00eeprom.c
-@@ -26,11 +26,66 @@
- 
- #include <linux/kernel.h>
- #include <linux/module.h>
-+#include <linux/mtd/mtd.h>
-+#include <linux/mtd/partitions.h>
- #include <linux/of.h>
- 
- #include "rt2x00.h"
- #include "rt2x00lib.h"
- 
-+static int rt2800lib_read_eeprom_mtd(struct rt2x00_dev *rt2x00dev)
-+{
-+	int ret = -EINVAL;
-+#ifdef CONFIG_OF
-+	static struct firmware mtd_fw;
-+	struct device_node *np = rt2x00dev->dev->of_node, *mtd_np = NULL;
-+	size_t retlen, len = rt2x00dev->ops->eeprom_size;
-+	int size, offset = 0;
-+	struct mtd_info *mtd;
-+	const char *part;
-+	const __be32 *list;
-+	phandle phandle;
-+
-+	list = of_get_property(np, "ralink,mtd-eeprom", &size);
-+	if (!list) {
-+		dev_err(rt2x00dev->dev, "failed to load eeprom property\n");
-+		return -ENOENT;
-+	}
-+
-+	phandle = be32_to_cpup(list++);
-+	if (phandle)
-+		mtd_np = of_find_node_by_phandle(phandle);
-+	if (!mtd_np) {
-+		dev_err(rt2x00dev->dev, "failed to load mtd phandle\n");
-+		return -EINVAL;
-+	}
-+
-+	part = of_get_property(mtd_np, "label", NULL);
-+	if (!part)
-+		part = mtd_np->name;
-+
-+	mtd = get_mtd_device_nm(part);
-+	if (IS_ERR(mtd)) {
-+		dev_err(rt2x00dev->dev, "failed to get mtd device \"%s\"\n", part);
-+		return PTR_ERR(mtd);
-+	}
-+
-+	if (size > sizeof(*list))
-+		offset = be32_to_cpup(list);
-+
-+	ret = mtd_read(mtd, offset, len, &retlen, (u_char *) rt2x00dev->eeprom);
-+	put_mtd_device(mtd);
-+
-+	if (!ret) {
-+		rt2x00dev->eeprom_file = &mtd_fw;
-+		mtd_fw.size = len;
-+		mtd_fw.data = (const u8 *) rt2x00dev->eeprom;
-+	}
-+#endif
-+
-+	return ret;
-+}
-+
- static const char *
- rt2x00lib_get_eeprom_file_name(struct rt2x00_dev *rt2x00dev)
- {
-@@ -58,6 +113,9 @@ static int rt2x00lib_request_eeprom_file
- 	const char *ee_name;
- 	int retval;
- 
-+	if (!rt2800lib_read_eeprom_mtd(rt2x00dev))
-+		return 0;
-+
- 	ee_name = rt2x00lib_get_eeprom_file_name(rt2x00dev);
- 	if (!ee_name) {
- 		rt2x00_err(rt2x00dev,
diff --git a/package/kernel/mac80211/patches/607-rt2x00-allow_disabling_bands_through_platform_data.patch b/package/kernel/mac80211/patches/607-rt2x00-allow_disabling_bands_through_platform_data.patch
deleted file mode 100644
index a2e1faf..0000000
--- a/package/kernel/mac80211/patches/607-rt2x00-allow_disabling_bands_through_platform_data.patch
+++ /dev/null
@@ -1,47 +0,0 @@
---- a/include/linux/rt2x00_platform.h
-+++ b/include/linux/rt2x00_platform.h
-@@ -14,6 +14,9 @@
- 
- struct rt2x00_platform_data {
- 	char *eeprom_file_name;
-+
-+	int disable_2ghz;
-+	int disable_5ghz;
- };
- 
- #endif /* _RT2X00_PLATFORM_H */
---- a/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
-@@ -940,6 +940,22 @@ static int rt2x00lib_probe_hw_modes(stru
- 	unsigned int num_rates;
- 	unsigned int i;
- 
-+	if (rt2x00dev->dev->platform_data) {
-+		struct rt2x00_platform_data *pdata;
-+
-+		pdata = rt2x00dev->dev->platform_data;
-+		if (pdata->disable_2ghz)
-+			spec->supported_bands &= ~SUPPORT_BAND_2GHZ;
-+		if (pdata->disable_5ghz)
-+			spec->supported_bands &= ~SUPPORT_BAND_5GHZ;
-+	}
-+
-+	if ((spec->supported_bands & SUPPORT_BAND_BOTH) == 0) {
-+		rt2x00_err(rt2x00dev, "No supported bands\n");
-+		return -EINVAL;
-+	}
-+
-+
- 	num_rates = 0;
- 	if (spec->supported_rates & SUPPORT_RATE_CCK)
- 		num_rates += 4;
---- a/drivers/net/wireless/ralink/rt2x00/rt2x00.h
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
-@@ -406,6 +406,7 @@ struct hw_mode_spec {
- 	unsigned int supported_bands;
- #define SUPPORT_BAND_2GHZ	0x00000001
- #define SUPPORT_BAND_5GHZ	0x00000002
-+#define SUPPORT_BAND_BOTH	(SUPPORT_BAND_2GHZ | SUPPORT_BAND_5GHZ)
- 
- 	unsigned int supported_rates;
- #define SUPPORT_RATE_CCK	0x00000001
diff --git a/package/kernel/mac80211/patches/608-add_platform_data_mac_addr.patch b/package/kernel/mac80211/patches/608-add_platform_data_mac_addr.patch
deleted file mode 100644
index 6704ff8..0000000
--- a/package/kernel/mac80211/patches/608-add_platform_data_mac_addr.patch
+++ /dev/null
@@ -1,63 +0,0 @@
---- a/include/linux/rt2x00_platform.h
-+++ b/include/linux/rt2x00_platform.h
-@@ -14,6 +14,7 @@
- 
- struct rt2x00_platform_data {
- 	char *eeprom_file_name;
-+	const u8 *mac_address;
- 
- 	int disable_2ghz;
- 	int disable_5ghz;
---- a/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
-@@ -931,6 +931,18 @@ static void rt2x00lib_rate(struct ieee80
- 		entry->flags |= IEEE80211_RATE_SHORT_PREAMBLE;
- }
- 
-+const u8 *rt2x00lib_get_mac_address(struct rt2x00_dev *rt2x00dev)
-+{
-+	struct rt2x00_platform_data *pdata;
-+
-+	pdata = rt2x00dev->dev->platform_data;
-+	if (!pdata)
-+		return NULL;
-+
-+	return pdata->mac_address;
-+}
-+EXPORT_SYMBOL_GPL(rt2x00lib_get_mac_address);
-+
- static int rt2x00lib_probe_hw_modes(struct rt2x00_dev *rt2x00dev,
- 				    struct hw_mode_spec *spec)
- {
---- a/drivers/net/wireless/ralink/rt2x00/rt2x00.h
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
-@@ -1416,6 +1416,7 @@ static inline void rt2x00debug_dump_fram
-  */
- u32 rt2x00lib_get_bssidx(struct rt2x00_dev *rt2x00dev,
- 			 struct ieee80211_vif *vif);
-+const u8 *rt2x00lib_get_mac_address(struct rt2x00_dev *rt2x00dev);
- 
- /*
-  * Interrupt context handlers.
---- a/drivers/net/wireless/ralink/rt2x00/rt61pci.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt61pci.c
-@@ -2392,6 +2392,7 @@ static int rt61pci_validate_eeprom(struc
- 	u32 reg;
- 	u16 word;
- 	u8 *mac;
-+	const u8 *pdata_mac;
- 	s8 value;
- 
- 	rt2x00mmio_register_read(rt2x00dev, E2PROM_CSR, &reg);
-@@ -2412,7 +2413,11 @@ static int rt61pci_validate_eeprom(struc
- 	/*
- 	 * Start validation of the data that has been read.
- 	 */
-+	pdata_mac = rt2x00lib_get_mac_address(rt2x00dev);
- 	mac = rt2x00_eeprom_addr(rt2x00dev, EEPROM_MAC_ADDR_0);
-+	if (pdata_mac)
-+		memcpy(mac, pdata_mac, 6);
-+
- 	if (!is_valid_ether_addr(mac)) {
- 		eth_random_addr(mac);
- 		rt2x00_eeprom_dbg(rt2x00dev, "MAC: %pM\n", mac);
diff --git a/package/kernel/mac80211/patches/609-rt2x00-allow_disabling_bands_through_dts.patch b/package/kernel/mac80211/patches/609-rt2x00-allow_disabling_bands_through_dts.patch
deleted file mode 100644
index 3fdaae7..0000000
--- a/package/kernel/mac80211/patches/609-rt2x00-allow_disabling_bands_through_dts.patch
+++ /dev/null
@@ -1,27 +0,0 @@
---- a/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
-@@ -26,6 +26,7 @@
- #include <linux/module.h>
- #include <linux/slab.h>
- #include <linux/log2.h>
-+#include <linux/of.h>
- 
- #include "rt2x00.h"
- #include "rt2x00lib.h"
-@@ -951,6 +952,16 @@ static int rt2x00lib_probe_hw_modes(stru
- 	struct ieee80211_rate *rates;
- 	unsigned int num_rates;
- 	unsigned int i;
-+#ifdef CONFIG_OF
-+	struct device_node *np = rt2x00dev->dev->of_node;
-+	unsigned int enabled;
-+	if (!of_property_read_u32(np, "ralink,2ghz",
-+                                          &enabled) && !enabled)
-+		spec->supported_bands &= ~SUPPORT_BAND_2GHZ;
-+	if (!of_property_read_u32(np, "ralink,5ghz",
-+                                          &enabled) && !enabled)
-+		spec->supported_bands &= ~SUPPORT_BAND_5GHZ;
-+#endif /* CONFIG_OF */
- 
- 	if (rt2x00dev->dev->platform_data) {
- 		struct rt2x00_platform_data *pdata;
diff --git a/package/kernel/mac80211/patches/610-rt2x00-fix-rt3352-ext-pa.patch b/package/kernel/mac80211/patches/610-rt2x00-fix-rt3352-ext-pa.patch
deleted file mode 100644
index 9f10fe3..0000000
--- a/package/kernel/mac80211/patches/610-rt2x00-fix-rt3352-ext-pa.patch
+++ /dev/null
@@ -1,211 +0,0 @@
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -3529,11 +3529,18 @@ static void rt2800_config_channel(struct
- 	/*
- 	 * Change BBP settings
- 	 */
-+
- 	if (rt2x00_rt(rt2x00dev, RT3352)) {
-+		rt2800_bbp_write(rt2x00dev, 62, 0x37 - rt2x00dev->lna_gain);
-+		rt2800_bbp_write(rt2x00dev, 63, 0x37 - rt2x00dev->lna_gain);
-+		rt2800_bbp_write(rt2x00dev, 64, 0x37 - rt2x00dev->lna_gain);
-+
- 		rt2800_bbp_write(rt2x00dev, 27, 0x0);
- 		rt2800_bbp_write(rt2x00dev, 66, 0x26 + rt2x00dev->lna_gain);
- 		rt2800_bbp_write(rt2x00dev, 27, 0x20);
- 		rt2800_bbp_write(rt2x00dev, 66, 0x26 + rt2x00dev->lna_gain);
-+		rt2800_bbp_write(rt2x00dev, 86, 0x38);
-+		rt2800_bbp_write(rt2x00dev, 83, 0x6a);
- 	} else if (rt2x00_rt(rt2x00dev, RT3593)) {
- 		if (rf->channel > 14) {
- 			/* Disable CCK Packet detection on 5GHz */
-@@ -6595,6 +6602,12 @@ static void rt2800_init_rfcsr_3290(struc
- 
- static void rt2800_init_rfcsr_3352(struct rt2x00_dev *rt2x00dev)
- {
-+	int tx0_int_pa = test_bit(CAPABILITY_INTERNAL_PA_TX0,
-+				  &rt2x00dev->cap_flags);
-+	int tx1_int_pa = test_bit(CAPABILITY_INTERNAL_PA_TX1,
-+				  &rt2x00dev->cap_flags);
-+	u8 rfcsr;
-+
- 	rt2800_rf_init_calibration(rt2x00dev, 30);
- 
- 	rt2800_rfcsr_write(rt2x00dev, 0, 0xf0);
-@@ -6630,15 +6643,30 @@ static void rt2800_init_rfcsr_3352(struc
- 	rt2800_rfcsr_write(rt2x00dev, 31, 0x80);
- 	rt2800_rfcsr_write(rt2x00dev, 32, 0x80);
- 	rt2800_rfcsr_write(rt2x00dev, 33, 0x00);
--	rt2800_rfcsr_write(rt2x00dev, 34, 0x01);
-+	rfcsr = 0x01;
-+	if (!tx0_int_pa)
-+		rt2x00_set_field8(&rfcsr, RFCSR34_TX0_EXT_PA, 1);
-+	if (!tx1_int_pa)
-+		rt2x00_set_field8(&rfcsr, RFCSR34_TX1_EXT_PA, 1);
-+	rt2800_rfcsr_write(rt2x00dev, 34, rfcsr);
- 	rt2800_rfcsr_write(rt2x00dev, 35, 0x03);
- 	rt2800_rfcsr_write(rt2x00dev, 36, 0xbd);
- 	rt2800_rfcsr_write(rt2x00dev, 37, 0x3c);
- 	rt2800_rfcsr_write(rt2x00dev, 38, 0x5f);
- 	rt2800_rfcsr_write(rt2x00dev, 39, 0xc5);
- 	rt2800_rfcsr_write(rt2x00dev, 40, 0x33);
--	rt2800_rfcsr_write(rt2x00dev, 41, 0x5b);
--	rt2800_rfcsr_write(rt2x00dev, 42, 0x5b);
-+	rfcsr = 0x52;
-+	if (tx0_int_pa) {
-+		rt2x00_set_field8(&rfcsr, RFCSR41_BIT1, 1);
-+		rt2x00_set_field8(&rfcsr, RFCSR41_BIT4, 1);
-+	}
-+	rt2800_rfcsr_write(rt2x00dev, 41, rfcsr);
-+	rfcsr = 0x52;
-+	if (tx1_int_pa) {
-+		rt2x00_set_field8(&rfcsr, RFCSR42_BIT1, 1);
-+		rt2x00_set_field8(&rfcsr, RFCSR42_BIT4, 1);
-+	}
-+	rt2800_rfcsr_write(rt2x00dev, 42, rfcsr);
- 	rt2800_rfcsr_write(rt2x00dev, 43, 0xdb);
- 	rt2800_rfcsr_write(rt2x00dev, 44, 0xdb);
- 	rt2800_rfcsr_write(rt2x00dev, 45, 0xdb);
-@@ -6646,15 +6674,20 @@ static void rt2800_init_rfcsr_3352(struc
- 	rt2800_rfcsr_write(rt2x00dev, 47, 0x0d);
- 	rt2800_rfcsr_write(rt2x00dev, 48, 0x14);
- 	rt2800_rfcsr_write(rt2x00dev, 49, 0x00);
--	rt2800_rfcsr_write(rt2x00dev, 50, 0x2d);
--	rt2800_rfcsr_write(rt2x00dev, 51, 0x7f);
--	rt2800_rfcsr_write(rt2x00dev, 52, 0x00);
--	rt2800_rfcsr_write(rt2x00dev, 53, 0x52);
--	rt2800_rfcsr_write(rt2x00dev, 54, 0x1b);
--	rt2800_rfcsr_write(rt2x00dev, 55, 0x7f);
--	rt2800_rfcsr_write(rt2x00dev, 56, 0x00);
--	rt2800_rfcsr_write(rt2x00dev, 57, 0x52);
--	rt2800_rfcsr_write(rt2x00dev, 58, 0x1b);
-+	rfcsr = 0x2d;
-+	if (!tx0_int_pa)
-+		rt2x00_set_field8(&rfcsr, RFCSR50_TX0_EXT_PA, 1);
-+	if (!tx1_int_pa)
-+		rt2x00_set_field8(&rfcsr, RFCSR50_TX1_EXT_PA, 1);
-+	rt2800_rfcsr_write(rt2x00dev, 50, rfcsr);
-+	rt2800_rfcsr_write(rt2x00dev, 51, (tx0_int_pa ? 0x7f : 0x52));
-+	rt2800_rfcsr_write(rt2x00dev, 52, (tx0_int_pa ? 0x00 : 0xc0));
-+	rt2800_rfcsr_write(rt2x00dev, 53, (tx0_int_pa ? 0x52 : 0xd2));
-+	rt2800_rfcsr_write(rt2x00dev, 54, (tx0_int_pa ? 0x1b : 0xc0));
-+	rt2800_rfcsr_write(rt2x00dev, 55, (tx1_int_pa ? 0x7f : 0x52));
-+	rt2800_rfcsr_write(rt2x00dev, 56, (tx1_int_pa ? 0x00 : 0xc0));
-+	rt2800_rfcsr_write(rt2x00dev, 57, (tx0_int_pa ? 0x52 : 0x49));
-+	rt2800_rfcsr_write(rt2x00dev, 58, (tx1_int_pa ? 0x1b : 0xc0));
- 	rt2800_rfcsr_write(rt2x00dev, 59, 0x00);
- 	rt2800_rfcsr_write(rt2x00dev, 60, 0x00);
- 	rt2800_rfcsr_write(rt2x00dev, 61, 0x00);
-@@ -7675,6 +7708,7 @@ static int rt2800_init_eeprom(struct rt2
- 	 * RT53xx: defined in "EEPROM_CHIP_ID" field
- 	 */
- 	if (rt2x00_rt(rt2x00dev, RT3290) ||
-+	    rt2x00_rt(rt2x00dev, RT3352) ||
- 	    rt2x00_rt(rt2x00dev, RT5390) ||
- 	    rt2x00_rt(rt2x00dev, RT5392))
- 		rt2800_eeprom_read(rt2x00dev, EEPROM_CHIP_ID, &rf);
-@@ -7770,7 +7804,8 @@ static int rt2800_init_eeprom(struct rt2
- 	/*
- 	 * Detect if this device has Bluetooth co-existence.
- 	 */
--	if (rt2x00_get_field16(eeprom, EEPROM_NIC_CONF1_BT_COEXIST))
-+	if (!rt2x00_rt(rt2x00dev, RT3352) &&
-+	    rt2x00_get_field16(eeprom, EEPROM_NIC_CONF1_BT_COEXIST))
- 		__set_bit(CAPABILITY_BT_COEXIST, &rt2x00dev->cap_flags);
- 
- 	/*
-@@ -7799,6 +7834,22 @@ static int rt2800_init_eeprom(struct rt2
- 					EIRP_MAX_TX_POWER_LIMIT)
- 		__set_bit(CAPABILITY_POWER_LIMIT, &rt2x00dev->cap_flags);
- 
-+	/*
-+	 * Detect if device uses internal or external PA
-+	 */
-+	rt2800_eeprom_read(rt2x00dev, EEPROM_NIC_CONF1, &eeprom);
-+
-+	if (rt2x00_rt(rt2x00dev, RT3352)) {
-+		if (!rt2x00_get_field16(eeprom,
-+		    EEPROM_NIC_CONF1_EXTERNAL_TX0_PA_3352))
-+			__set_bit(CAPABILITY_INTERNAL_PA_TX0,
-+				  &rt2x00dev->cap_flags);
-+		if (!rt2x00_get_field16(eeprom,
-+		    EEPROM_NIC_CONF1_EXTERNAL_TX1_PA_3352))
-+			__set_bit(CAPABILITY_INTERNAL_PA_TX1,
-+				  &rt2x00dev->cap_flags);
-+	}
-+
- 	return 0;
- }
- 
---- a/drivers/net/wireless/ralink/rt2x00/rt2800.h
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800.h
-@@ -2335,6 +2335,12 @@ struct mac_iveiv_entry {
- #define RFCSR36_RF_BS			FIELD8(0x80)
- 
- /*
-+ * RFCSR 34:
-+ */
-+#define RFCSR34_TX0_EXT_PA		FIELD8(0x04)
-+#define RFCSR34_TX1_EXT_PA		FIELD8(0x08)
-+
-+/*
-  * RFCSR 38:
-  */
- #define RFCSR38_RX_LO1_EN		FIELD8(0x20)
-@@ -2346,6 +2352,18 @@ struct mac_iveiv_entry {
- #define RFCSR39_RX_LO2_EN		FIELD8(0x80)
- 
- /*
-+ * RFCSR 41:
-+ */
-+#define RFCSR41_BIT1			FIELD8(0x01)
-+#define RFCSR41_BIT4			FIELD8(0x08)
-+
-+/*
-+ * RFCSR 42:
-+ */
-+#define RFCSR42_BIT1			FIELD8(0x01)
-+#define RFCSR42_BIT4			FIELD8(0x08)
-+
-+/*
-  * RFCSR 49:
-  */
- #define RFCSR49_TX			FIELD8(0x3f)
-@@ -2358,6 +2376,8 @@ struct mac_iveiv_entry {
-  * RFCSR 50:
-  */
- #define RFCSR50_TX			FIELD8(0x3f)
-+#define RFCSR50_TX0_EXT_PA		FIELD8(0x02)
-+#define RFCSR50_TX1_EXT_PA		FIELD8(0x10)
- #define RFCSR50_EP			FIELD8(0xc0)
- /* bits for RT3593 */
- #define RFCSR50_TX_LO1_EN		FIELD8(0x20)
-@@ -2505,6 +2525,8 @@ enum rt2800_eeprom_word {
-  * INTERNAL_TX_ALC: 0: disable, 1: enable
-  * BT_COEXIST: 0: disable, 1: enable
-  * DAC_TEST: 0: disable, 1: enable
-+ * EXTERNAL_TX0_PA: 0: disable, 1: enable (only on RT3352)
-+ * EXTERNAL_TX1_PA: 0: disable, 1: enable (only on RT3352)
-  */
- #define EEPROM_NIC_CONF1_HW_RADIO		FIELD16(0x0001)
- #define EEPROM_NIC_CONF1_EXTERNAL_TX_ALC	FIELD16(0x0002)
-@@ -2521,6 +2543,8 @@ enum rt2800_eeprom_word {
- #define EEPROM_NIC_CONF1_INTERNAL_TX_ALC	FIELD16(0x2000)
- #define EEPROM_NIC_CONF1_BT_COEXIST		FIELD16(0x4000)
- #define EEPROM_NIC_CONF1_DAC_TEST		FIELD16(0x8000)
-+#define EEPROM_NIC_CONF1_EXTERNAL_TX0_PA_3352	FIELD16(0x4000)
-+#define EEPROM_NIC_CONF1_EXTERNAL_TX1_PA_3352	FIELD16(0x8000)
- 
- /*
-  * EEPROM frequency
---- a/drivers/net/wireless/ralink/rt2x00/rt2x00.h
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
-@@ -719,6 +719,8 @@ enum rt2x00_capability_flags {
- 	CAPABILITY_DOUBLE_ANTENNA,
- 	CAPABILITY_BT_COEXIST,
- 	CAPABILITY_VCO_RECALIBRATION,
-+	CAPABILITY_INTERNAL_PA_TX0,
-+	CAPABILITY_INTERNAL_PA_TX1,
- };
- 
- /*
diff --git a/package/kernel/mac80211/patches/611-rt2x00-rf_vals-rt3352-xtal20.patch b/package/kernel/mac80211/patches/611-rt2x00-rf_vals-rt3352-xtal20.patch
deleted file mode 100644
index 860fdc0..0000000
--- a/package/kernel/mac80211/patches/611-rt2x00-rf_vals-rt3352-xtal20.patch
+++ /dev/null
@@ -1,106 +0,0 @@
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -8186,6 +8186,27 @@ static const struct rf_channel rf_vals_5
- 	{196, 83, 0, 12, 1},
- };
- 
-+/*
-+ * RF value list for rt3xxx with Xtal20MHz
-+ * Supports: 2.4 GHz (all) (RF3322)
-+ */
-+static const struct rf_channel rf_vals_xtal20mhz_3x[] = {
-+	{1,    0xE2,	 2,  0x14},
-+	{2,    0xE3,	 2,  0x14},
-+	{3,    0xE4,	 2,  0x14},
-+	{4,    0xE5,	 2,  0x14},
-+	{5,    0xE6,	 2,  0x14},
-+	{6,    0xE7,	 2,  0x14},
-+	{7,    0xE8,	 2,  0x14},
-+	{8,    0xE9,	 2,  0x14},
-+	{9,    0xEA,	 2,  0x14},
-+	{10,   0xEB,	 2,  0x14},
-+	{11,   0xEC,	 2,  0x14},
-+	{12,   0xED,	 2,  0x14},
-+	{13,   0xEE,	 2,  0x14},
-+	{14,   0xF0,	 2,  0x18},
-+};
-+
- static int rt2800_probe_hw_mode(struct rt2x00_dev *rt2x00dev)
- {
- 	struct hw_mode_spec *spec = &rt2x00dev->spec;
-@@ -8276,7 +8297,10 @@ static int rt2800_probe_hw_mode(struct r
- 	case RF5390:
- 	case RF5392:
- 		spec->num_channels = 14;
--		spec->channels = rf_vals_3x;
-+		if (spec->clk_is_20mhz)
-+			spec->channels = rf_vals_xtal20mhz_3x;
-+		else
-+			spec->channels = rf_vals_3x;
- 		break;
- 
- 	case RF3052:
-@@ -8460,6 +8484,19 @@ static int rt2800_probe_rt(struct rt2x00
- 	return 0;
- }
- 
-+int rt2800_probe_clk(struct rt2x00_dev *rt2x00dev)
-+{
-+	struct rt2x00_platform_data *pdata = rt2x00dev->dev->platform_data;
-+	struct hw_mode_spec *spec = &rt2x00dev->spec;
-+
-+	if (!pdata)
-+		return -EINVAL;
-+
-+	spec->clk_is_20mhz = pdata->clk_is_20mhz;
-+
-+	return 0;
-+}
-+
- int rt2800_probe_hw(struct rt2x00_dev *rt2x00dev)
- {
- 	struct rt2800_drv_data *drv_data = rt2x00dev->drv_data;
-@@ -8502,6 +8539,15 @@ int rt2800_probe_hw(struct rt2x00_dev *r
- 	rt2800_register_write(rt2x00dev, GPIO_CTRL, reg);
- 
- 	/*
-+	 * Probe SoC clock.
-+	 */
-+	if (rt2x00_is_soc(rt2x00dev)) {
-+		retval = rt2800_probe_clk(rt2x00dev);
-+		if (retval)
-+			return retval;
-+	}
-+
-+	/*
- 	 * Initialize hw specifications.
- 	 */
- 	retval = rt2800_probe_hw_mode(rt2x00dev);
---- a/drivers/net/wireless/ralink/rt2x00/rt2x00.h
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
-@@ -401,6 +401,7 @@ static inline struct rt2x00_intf* vif_to
-  * @channels: Device/chipset specific channel values (See &struct rf_channel).
-  * @channels_info: Additional information for channels (See &struct channel_info).
-  * @ht: Driver HT Capabilities (See &ieee80211_sta_ht_cap).
-+ * @clk_is_20mhz: External crystal of WiSoC is 20MHz instead of 40MHz
-  */
- struct hw_mode_spec {
- 	unsigned int supported_bands;
-@@ -417,6 +418,7 @@ struct hw_mode_spec {
- 	const struct channel_info *channels_info;
- 
- 	struct ieee80211_sta_ht_cap ht;
-+	int clk_is_20mhz;
- };
- 
- /*
---- a/include/linux/rt2x00_platform.h
-+++ b/include/linux/rt2x00_platform.h
-@@ -18,6 +18,7 @@ struct rt2x00_platform_data {
- 
- 	int disable_2ghz;
- 	int disable_5ghz;
-+	int clk_is_20mhz;
- };
- 
- #endif /* _RT2X00_PLATFORM_H */
diff --git a/package/kernel/mac80211/patches/612-rt2x00-make-wmac-loadable-via-OF-on-rt288x-305x-SoC.patch b/package/kernel/mac80211/patches/612-rt2x00-make-wmac-loadable-via-OF-on-rt288x-305x-SoC.patch
deleted file mode 100644
index e4b028b..0000000
--- a/package/kernel/mac80211/patches/612-rt2x00-make-wmac-loadable-via-OF-on-rt288x-305x-SoC.patch
+++ /dev/null
@@ -1,33 +0,0 @@
-From 04dbd87265f6ba4a373b211ba324b437d224fb2d Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Sun, 17 Mar 2013 00:03:31 +0100
-Subject: [PATCH 21/38] rt2x00: make wmac loadable via OF on rt288x/305x SoC
-
-This patch ads the match table to allow loading the wmac support from a
-devicetree.
-
-Signed-off-by: John Crispin <blogic@openwrt.org>
----
- drivers/net/wireless/ralink/rt2x00/rt2800pci.c |    7 +++++++
- 1 file changed, 7 insertions(+)
-
---- a/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
-@@ -237,10 +237,17 @@ static int rt2800soc_probe(struct platfo
- 	return rt2x00soc_probe(pdev, &rt2800soc_ops);
- }
- 
-+static const struct of_device_id rt2880_wmac_match[] = {
-+	{ .compatible = "ralink,rt2880-wmac" },
-+	{},
-+};
-+MODULE_DEVICE_TABLE(of, rt2880_wmac_match);
-+
- static struct platform_driver rt2800soc_driver = {
- 	.driver		= {
- 		.name		= "rt2800_wmac",
- 		.mod_name	= KBUILD_MODNAME,
-+		.of_match_table	= rt2880_wmac_match,
- 	},
- 	.probe		= rt2800soc_probe,
- 	.remove		= rt2x00soc_remove,
diff --git a/package/kernel/mac80211/patches/615-rt2x00-fix_20mhz_clk.patch b/package/kernel/mac80211/patches/615-rt2x00-fix_20mhz_clk.patch
deleted file mode 100644
index e7b2a8c..0000000
--- a/package/kernel/mac80211/patches/615-rt2x00-fix_20mhz_clk.patch
+++ /dev/null
@@ -1,29 +0,0 @@
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -36,6 +36,7 @@
- #include <linux/kernel.h>
- #include <linux/module.h>
- #include <linux/slab.h>
-+#include <linux/clk.h>
- 
- #include "rt2x00.h"
- #include "rt2800lib.h"
-@@ -8486,13 +8487,14 @@ static int rt2800_probe_rt(struct rt2x00
- 
- int rt2800_probe_clk(struct rt2x00_dev *rt2x00dev)
- {
--	struct rt2x00_platform_data *pdata = rt2x00dev->dev->platform_data;
- 	struct hw_mode_spec *spec = &rt2x00dev->spec;
-+	struct clk *clk = clk_get(rt2x00dev->dev, NULL);
- 
--	if (!pdata)
--		return -EINVAL;
-+	if (IS_ERR(clk))
-+		return PTR_ERR(clk);
- 
--	spec->clk_is_20mhz = pdata->clk_is_20mhz;
-+	if (clk_get_rate(clk) == 20000000)
-+		spec->clk_is_20mhz = 1;
- 
- 	return 0;
- }
diff --git a/package/kernel/mac80211/patches/616-rt2x00-support-rt5350.patch b/package/kernel/mac80211/patches/616-rt2x00-support-rt5350.patch
deleted file mode 100644
index 44bd8a1..0000000
--- a/package/kernel/mac80211/patches/616-rt2x00-support-rt5350.patch
+++ /dev/null
@@ -1,276 +0,0 @@
---- a/drivers/net/wireless/ralink/rt2x00/rt2800.h
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800.h
-@@ -74,6 +74,7 @@
- #define RF3070				0x3070
- #define RF3290				0x3290
- #define RF3853				0x3853
-+#define RF5350				0x5350
- #define RF5360				0x5360
- #define RF5362				0x5362
- #define RF5370				0x5370
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -3015,6 +3015,13 @@ static void rt2800_config_channel_rf53xx
- 
- 				rt2800_rfcsr_write(rt2x00dev, 59,
- 						   r59_non_bt[idx]);
-+			} else if (rt2x00_rt(rt2x00dev, RT5350)) {
-+				static const char r59_non_bt[] = {0x0b, 0x0b,
-+					0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0a,
-+					0x0a, 0x09, 0x08, 0x07, 0x07, 0x06};
-+
-+				rt2800_rfcsr_write(rt2x00dev, 59,
-+						   r59_non_bt[idx]);
- 			}
- 		}
- 	}
-@@ -3493,6 +3500,7 @@ static void rt2800_config_channel(struct
- 		rt2800_config_channel_rf3853(rt2x00dev, conf, rf, info);
- 		break;
- 	case RF3070:
-+	case RF5350:
- 	case RF5360:
- 	case RF5362:
- 	case RF5370:
-@@ -3511,6 +3519,7 @@ static void rt2800_config_channel(struct
- 	if (rt2x00_rf(rt2x00dev, RF3070) ||
- 	    rt2x00_rf(rt2x00dev, RF3290) ||
- 	    rt2x00_rf(rt2x00dev, RF3322) ||
-+	    rt2x00_rf(rt2x00dev, RF5350) ||
- 	    rt2x00_rf(rt2x00dev, RF5360) ||
- 	    rt2x00_rf(rt2x00dev, RF5362) ||
- 	    rt2x00_rf(rt2x00dev, RF5370) ||
-@@ -3789,7 +3798,8 @@ static void rt2800_config_channel(struct
- 	/*
- 	 * Clear update flag
- 	 */
--	if (rt2x00_rt(rt2x00dev, RT3352)) {
-+	if (rt2x00_rt(rt2x00dev, RT3352) ||
-+	    rt2x00_rt(rt2x00dev, RT5350)) {
- 		rt2800_bbp_read(rt2x00dev, 49, &bbp);
- 		rt2x00_set_field8(&bbp, BBP49_UPDATE_FLAG, 0);
- 		rt2800_bbp_write(rt2x00dev, 49, bbp);
-@@ -4675,6 +4685,7 @@ void rt2800_vco_calibration(struct rt2x0
- 	case RF3070:
- 	case RF3290:
- 	case RF3853:
-+	case RF5350:
- 	case RF5360:
- 	case RF5362:
- 	case RF5370:
-@@ -5088,6 +5099,8 @@ static int rt2800_init_registers(struct
- 		rt2800_register_write(rt2x00dev, TX_SW_CFG0, 0x00000404);
- 		rt2800_register_write(rt2x00dev, TX_SW_CFG1, 0x00080606);
- 		rt2800_register_write(rt2x00dev, TX_SW_CFG2, 0x00000000);
-+	} else if (rt2x00_rt(rt2x00dev, RT5350)) {
-+		rt2800_register_write(rt2x00dev, TX_SW_CFG0, 0x00000404);
- 	} else {
- 		rt2800_register_write(rt2x00dev, TX_SW_CFG0, 0x00000000);
- 		rt2800_register_write(rt2x00dev, TX_SW_CFG1, 0x00080606);
-@@ -5743,9 +5756,13 @@ static void rt2800_init_bbp_3352(struct
- 
- 	rt2800_bbp_write(rt2x00dev, 82, 0x62);
- 
--	rt2800_bbp_write(rt2x00dev, 83, 0x6a);
--
--	rt2800_bbp_write(rt2x00dev, 84, 0x99);
-+	if (rt2x00_rt(rt2x00dev, RT5350)) {
-+		rt2800_bbp_write(rt2x00dev, 83, 0x7a);
-+		rt2800_bbp_write(rt2x00dev, 84, 0x9a);
-+	} else {
-+		rt2800_bbp_write(rt2x00dev, 83, 0x6a);
-+		rt2800_bbp_write(rt2x00dev, 84, 0x99);
-+	}
- 
- 	rt2800_bbp_write(rt2x00dev, 86, 0x38);
- 
-@@ -5759,9 +5776,13 @@ static void rt2800_init_bbp_3352(struct
- 
- 	rt2800_bbp_write(rt2x00dev, 104, 0x92);
- 
--	rt2800_bbp_write(rt2x00dev, 105, 0x34);
--
--	rt2800_bbp_write(rt2x00dev, 106, 0x05);
-+	if (rt2x00_rt(rt2x00dev, RT5350)) {
-+		rt2800_bbp_write(rt2x00dev, 105, 0x3c);
-+		rt2800_bbp_write(rt2x00dev, 106, 0x03);
-+	} else {
-+		rt2800_bbp_write(rt2x00dev, 105, 0x34);
-+		rt2800_bbp_write(rt2x00dev, 106, 0x05);
-+	}
- 
- 	rt2800_bbp_write(rt2x00dev, 120, 0x50);
- 
-@@ -5786,6 +5807,13 @@ static void rt2800_init_bbp_3352(struct
- 	rt2800_bbp_write(rt2x00dev, 143, 0xa2);
- 
- 	rt2800_bbp_write(rt2x00dev, 148, 0xc8);
-+
-+	if (rt2x00_rt(rt2x00dev, RT5350)) {
-+		rt2800_bbp_write(rt2x00dev, 150, 0x40); /* Antenna Software OFDM */
-+		rt2800_bbp_write(rt2x00dev, 151, 0x30); /* Antenna Software CCK */
-+		rt2800_bbp_write(rt2x00dev, 152, 0xa3);
-+		rt2800_bbp_write(rt2x00dev, 154, 0); /* Clear previously selected antenna */
-+	}
- }
- 
- static void rt2800_init_bbp_3390(struct rt2x00_dev *rt2x00dev)
-@@ -6127,6 +6155,7 @@ static void rt2800_init_bbp(struct rt2x0
- 		rt2800_init_bbp_3290(rt2x00dev);
- 		break;
- 	case RT3352:
-+	case RT5350:
- 		rt2800_init_bbp_3352(rt2x00dev);
- 		break;
- 	case RT3390:
-@@ -7078,6 +7107,76 @@ static void rt2800_init_rfcsr_3883(struc
- 	rt2800_rfcsr_write(rt2x00dev, 20, rfcsr);
- }
- 
-+static void rt2800_init_rfcsr_5350(struct rt2x00_dev *rt2x00dev)
-+{
-+	rt2800_rfcsr_write(rt2x00dev, 0, 0xf0);
-+	rt2800_rfcsr_write(rt2x00dev, 1, 0x23);
-+	rt2800_rfcsr_write(rt2x00dev, 2, 0x50);
-+	rt2800_rfcsr_write(rt2x00dev, 3, 0x08);
-+	rt2800_rfcsr_write(rt2x00dev, 4, 0x49);
-+	rt2800_rfcsr_write(rt2x00dev, 5, 0x10);
-+	rt2800_rfcsr_write(rt2x00dev, 6, 0xe0);
-+	rt2800_rfcsr_write(rt2x00dev, 7, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 8, 0xf1);
-+	rt2800_rfcsr_write(rt2x00dev, 9, 0x02);
-+	rt2800_rfcsr_write(rt2x00dev, 10, 0x53);
-+	rt2800_rfcsr_write(rt2x00dev, 11, 0x4a);
-+	rt2800_rfcsr_write(rt2x00dev, 12, 0x46);
-+	if(rt2x00dev->spec.clk_is_20mhz)
-+		rt2800_rfcsr_write(rt2x00dev, 13, 0x1f);
-+	else
-+		rt2800_rfcsr_write(rt2x00dev, 13, 0x9f);
-+	rt2800_rfcsr_write(rt2x00dev, 14, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 15, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 16, 0xc0);
-+	rt2800_rfcsr_write(rt2x00dev, 18, 0x03);
-+	rt2800_rfcsr_write(rt2x00dev, 19, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 20, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 21, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 22, 0x20);
-+	rt2800_rfcsr_write(rt2x00dev, 23, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 24, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 25, 0x80);
-+	rt2800_rfcsr_write(rt2x00dev, 26, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 27, 0x03);
-+	rt2800_rfcsr_write(rt2x00dev, 28, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 29, 0xd0);
-+	rt2800_rfcsr_write(rt2x00dev, 30, 0x10);
-+	rt2800_rfcsr_write(rt2x00dev, 31, 0x80);
-+	rt2800_rfcsr_write(rt2x00dev, 32, 0x80);
-+	rt2800_rfcsr_write(rt2x00dev, 33, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 34, 0x07);
-+	rt2800_rfcsr_write(rt2x00dev, 35, 0x12);
-+	rt2800_rfcsr_write(rt2x00dev, 36, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 37, 0x08);
-+	rt2800_rfcsr_write(rt2x00dev, 38, 0x85);
-+	rt2800_rfcsr_write(rt2x00dev, 39, 0x1b);
-+	rt2800_rfcsr_write(rt2x00dev, 40, 0x0b);
-+	rt2800_rfcsr_write(rt2x00dev, 41, 0xbb);
-+	rt2800_rfcsr_write(rt2x00dev, 42, 0xd5);
-+	rt2800_rfcsr_write(rt2x00dev, 43, 0x9b);
-+	rt2800_rfcsr_write(rt2x00dev, 44, 0x0c);
-+	rt2800_rfcsr_write(rt2x00dev, 45, 0xa6);
-+	rt2800_rfcsr_write(rt2x00dev, 46, 0x73);
-+	rt2800_rfcsr_write(rt2x00dev, 47, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 48, 0x10);
-+	rt2800_rfcsr_write(rt2x00dev, 49, 0x80);
-+	rt2800_rfcsr_write(rt2x00dev, 50, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 51, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 52, 0x38);
-+	rt2800_rfcsr_write(rt2x00dev, 53, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 54, 0x38);
-+	rt2800_rfcsr_write(rt2x00dev, 55, 0x43);
-+	rt2800_rfcsr_write(rt2x00dev, 56, 0x82);
-+	rt2800_rfcsr_write(rt2x00dev, 57, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 58, 0x39);
-+	rt2800_rfcsr_write(rt2x00dev, 59, 0x0b);
-+	rt2800_rfcsr_write(rt2x00dev, 60, 0x45);
-+	rt2800_rfcsr_write(rt2x00dev, 61, 0xd1);
-+	rt2800_rfcsr_write(rt2x00dev, 62, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 63, 0x00);
-+}
-+
- static void rt2800_init_rfcsr_5390(struct rt2x00_dev *rt2x00dev)
- {
- 	rt2800_rf_init_calibration(rt2x00dev, 2);
-@@ -7318,6 +7417,9 @@ static void rt2800_init_rfcsr(struct rt2
- 	case RT3593:
- 		rt2800_init_rfcsr_3593(rt2x00dev);
- 		break;
-+	case RT5350:
-+		rt2800_init_rfcsr_5350(rt2x00dev);
-+		break;
- 	case RT5390:
- 		rt2800_init_rfcsr_5390(rt2x00dev);
- 		break;
-@@ -7577,6 +7679,12 @@ static int rt2800_validate_eeprom(struct
- 		rt2x00_set_field16(&word, EEPROM_NIC_CONF0_RF_TYPE, RF2820);
- 		rt2800_eeprom_write(rt2x00dev, EEPROM_NIC_CONF0, word);
- 		rt2x00_eeprom_dbg(rt2x00dev, "Antenna: 0x%04x\n", word);
-+	} else if (rt2x00_rt(rt2x00dev, RT5350)) {
-+		rt2x00_set_field16(&word, EEPROM_NIC_CONF0_RXPATH, 1);
-+		rt2x00_set_field16(&word, EEPROM_NIC_CONF0_TXPATH, 1);
-+		rt2x00_set_field16(&word, EEPROM_NIC_CONF0_RF_TYPE, RF3320);
-+		rt2x00_eeprom_write(rt2x00dev, EEPROM_NIC_CONF0, word);
-+		rt2x00_eeprom_dbg(rt2x00dev, "Antenna: 0x%04x\n", word);
- 	} else if (rt2x00_rt(rt2x00dev, RT2860) ||
- 		   rt2x00_rt(rt2x00dev, RT2872)) {
- 		/*
-@@ -7715,6 +7823,8 @@ static int rt2800_init_eeprom(struct rt2
- 		rt2800_eeprom_read(rt2x00dev, EEPROM_CHIP_ID, &rf);
- 	else if (rt2x00_rt(rt2x00dev, RT3883))
- 		rf = RF3853;
-+	else if (rt2x00_rt(rt2x00dev, RT5350))
-+		rf = RF5350;
- 	else
- 		rf = rt2x00_get_field16(eeprom, EEPROM_NIC_CONF0_RF_TYPE);
- 
-@@ -7734,6 +7844,7 @@ static int rt2800_init_eeprom(struct rt2
- 	case RF3320:
- 	case RF3322:
- 	case RF3853:
-+	case RF5350:
- 	case RF5360:
- 	case RF5362:
- 	case RF5370:
-@@ -8291,6 +8402,7 @@ static int rt2800_probe_hw_mode(struct r
- 	case RF3290:
- 	case RF3320:
- 	case RF3322:
-+	case RF5350:
- 	case RF5360:
- 	case RF5362:
- 	case RF5370:
-@@ -8430,6 +8542,7 @@ static int rt2800_probe_hw_mode(struct r
- 	case RF3070:
- 	case RF3290:
- 	case RF3853:
-+	case RF5350:
- 	case RF5360:
- 	case RF5362:
- 	case RF5370:
-@@ -8470,6 +8583,7 @@ static int rt2800_probe_rt(struct rt2x00
- 	case RT3572:
- 	case RT3593:
- 	case RT3883:
-+	case RT5350:
- 	case RT5390:
- 	case RT5392:
- 	case RT5592:
---- a/drivers/net/wireless/ralink/rt2x00/rt2x00.h
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
-@@ -170,6 +170,7 @@ struct rt2x00_chip {
- #define RT3572		0x3572
- #define RT3593		0x3593
- #define RT3883		0x3883	/* WSOC */
-+#define RT5350		0x5350  /* WSOC 2.4GHz */
- #define RT5390		0x5390  /* 2.4GHz */
- #define RT5392		0x5392  /* 2.4GHz */
- #define RT5592		0x5592
diff --git a/package/kernel/mac80211/patches/619-rt2x00-change-led-polarity-from-OF.patch b/package/kernel/mac80211/patches/619-rt2x00-change-led-polarity-from-OF.patch
deleted file mode 100644
index 6094a61..0000000
--- a/package/kernel/mac80211/patches/619-rt2x00-change-led-polarity-from-OF.patch
+++ /dev/null
@@ -1,40 +0,0 @@
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -37,6 +37,7 @@
- #include <linux/module.h>
- #include <linux/slab.h>
- #include <linux/clk.h>
-+#include <linux/of.h>
- 
- #include "rt2x00.h"
- #include "rt2800lib.h"
-@@ -7934,6 +7935,17 @@ static int rt2800_init_eeprom(struct rt2
- 	rt2800_init_led(rt2x00dev, &rt2x00dev->led_assoc, LED_TYPE_ASSOC);
- 	rt2800_init_led(rt2x00dev, &rt2x00dev->led_qual, LED_TYPE_QUALITY);
- 
-+	{
-+		struct device_node *np = rt2x00dev->dev->of_node;
-+		unsigned int led_polarity;
-+
-+		/* Allow overriding polarity from OF */
-+		if (!of_property_read_u32(np, "ralink,led-polarity",
-+					  &led_polarity))
-+			rt2x00_set_field16(&eeprom, EEPROM_FREQ_LED_POLARITY,
-+					   led_polarity);
-+	}
-+
- 	rt2x00dev->led_mcu_reg = eeprom;
- #endif /* CPTCFG_RT2X00_LIB_LEDS */
- 
---- a/drivers/net/wireless/ralink/rt2x00/rt2x00leds.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00leds.c
-@@ -109,6 +109,9 @@ static int rt2x00leds_register_led(struc
- 	led->led_dev.name = name;
- 	led->led_dev.brightness = LED_OFF;
- 
-+	if (rt2x00_is_soc(rt2x00dev))
-+		led->led_dev.brightness_set(&led->led_dev, LED_OFF);
-+
- 	retval = led_classdev_register(device, &led->led_dev);
- 	if (retval) {
- 		rt2x00_err(rt2x00dev, "Failed to register led handler\n");
diff --git a/package/kernel/mac80211/patches/620-rt2x00-add-AP+STA-support.patch b/package/kernel/mac80211/patches/620-rt2x00-add-AP+STA-support.patch
deleted file mode 100644
index dba6033..0000000
--- a/package/kernel/mac80211/patches/620-rt2x00-add-AP+STA-support.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
-@@ -1283,7 +1283,7 @@ static inline void rt2x00lib_set_if_comb
- 	 */
- 	if_limit = &rt2x00dev->if_limits_ap;
- 	if_limit->max = rt2x00dev->ops->max_ap_intf;
--	if_limit->types = BIT(NL80211_IFTYPE_AP);
-+	if_limit->types = BIT(NL80211_IFTYPE_AP) | BIT(NL80211_IFTYPE_STATION);
- #ifdef CPTCFG_MAC80211_MESH
- 	if_limit->types |= BIT(NL80211_IFTYPE_MESH_POINT);
- #endif
diff --git a/package/kernel/mac80211/patches/620-rt2x00-rt3352-rf-id.patch b/package/kernel/mac80211/patches/620-rt2x00-rt3352-rf-id.patch
deleted file mode 100644
index 8ddf425..0000000
--- a/package/kernel/mac80211/patches/620-rt2x00-rt3352-rf-id.patch
+++ /dev/null
@@ -1,15 +0,0 @@
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -7818,10 +7818,11 @@ static int rt2800_init_eeprom(struct rt2
- 	 * RT53xx: defined in "EEPROM_CHIP_ID" field
- 	 */
- 	if (rt2x00_rt(rt2x00dev, RT3290) ||
--	    rt2x00_rt(rt2x00dev, RT3352) ||
- 	    rt2x00_rt(rt2x00dev, RT5390) ||
- 	    rt2x00_rt(rt2x00dev, RT5392))
- 		rt2800_eeprom_read(rt2x00dev, EEPROM_CHIP_ID, &rf);
-+	else if (rt2x00_rt(rt2x00dev, RT3352))
-+		rf = RF3322;
- 	else if (rt2x00_rt(rt2x00dev, RT3883))
- 		rf = RF3853;
- 	else if (rt2x00_rt(rt2x00dev, RT5350))
diff --git a/package/kernel/mac80211/patches/621-rt2x00-ht20_40_fix.patch b/package/kernel/mac80211/patches/621-rt2x00-ht20_40_fix.patch
deleted file mode 100644
index e3e4c98..0000000
--- a/package/kernel/mac80211/patches/621-rt2x00-ht20_40_fix.patch
+++ /dev/null
@@ -1,29 +0,0 @@
---- a/drivers/net/wireless/ralink/rt2x00/rt2800.h
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800.h
-@@ -2321,6 +2321,8 @@ struct mac_iveiv_entry {
- #define RFCSR30_RX_H20M			FIELD8(0x04)
- #define RFCSR30_RX_VCM			FIELD8(0x18)
- #define RFCSR30_RF_CALIBRATION		FIELD8(0x80)
-+#define RF3322_RFCSR30_TX_H20M		FIELD8(0x01)
-+#define RF3322_RFCSR30_RX_H20M		FIELD8(0x02)
- 
- /*
-  * RFCSR 31:
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -3528,8 +3528,13 @@ static void rt2800_config_channel(struct
- 	    rt2x00_rf(rt2x00dev, RF5390) ||
- 	    rt2x00_rf(rt2x00dev, RF5392)) {
- 		rt2800_rfcsr_read(rt2x00dev, 30, &rfcsr);
--		rt2x00_set_field8(&rfcsr, RFCSR30_TX_H20M, 0);
--		rt2x00_set_field8(&rfcsr, RFCSR30_RX_H20M, 0);
-+		if(rt2x00_rf(rt2x00dev, RF3322)) {
-+			rt2x00_set_field8(&rfcsr, RF3322_RFCSR30_TX_H20M, conf_is_ht40(conf));
-+			rt2x00_set_field8(&rfcsr, RF3322_RFCSR30_RX_H20M, conf_is_ht40(conf));
-+		} else {
-+			rt2x00_set_field8(&rfcsr, RFCSR30_TX_H20M, conf_is_ht40(conf));
-+			rt2x00_set_field8(&rfcsr, RFCSR30_RX_H20M, conf_is_ht40(conf));
-+		}
- 		rt2800_rfcsr_write(rt2x00dev, 30, rfcsr);
- 
- 		rt2800_rfcsr_read(rt2x00dev, 3, &rfcsr);
diff --git a/package/kernel/mac80211/patches/622-rt2x00-fix-beacon-bit-balance.patch b/package/kernel/mac80211/patches/622-rt2x00-fix-beacon-bit-balance.patch
deleted file mode 100644
index 3cf6268..0000000
--- a/package/kernel/mac80211/patches/622-rt2x00-fix-beacon-bit-balance.patch
+++ /dev/null
@@ -1,47 +0,0 @@
---- a/drivers/net/wireless/ralink/rt2x00/rt2x00mac.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00mac.c
-@@ -627,12 +627,8 @@ void rt2x00mac_bss_info_changed(struct i
- 		} else if (bss_conf->enable_beacon && !intf->enable_beacon) {
- 			rt2x00dev->intf_beaconing++;
- 			intf->enable_beacon = true;
--			/*
--			 * Upload beacon to the H/W. This is only required on
--			 * USB devices. PCI devices fetch beacons periodically.
--			 */
--			if (rt2x00_is_usb(rt2x00dev))
--				rt2x00queue_update_beacon(rt2x00dev, vif);
-+
-+			rt2x00queue_update_beacon(rt2x00dev, vif);
- 
- 			if (rt2x00dev->intf_beaconing == 1) {
- 				/*
---- a/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
-@@ -144,7 +144,8 @@ static void rt2x00lib_intf_scheduled_ite
- 
- 	if (test_and_clear_bit(DELAYED_UPDATE_BEACON, &intf->delayed_flags)) {
- 		mutex_lock(&intf->beacon_skb_mutex);
--		rt2x00queue_update_beacon(rt2x00dev, vif);
-+		if (intf->enable_beacon)
-+			rt2x00queue_update_beacon(rt2x00dev, vif);
- 		mutex_unlock(&intf->beacon_skb_mutex);
- 	}
- }
-@@ -207,6 +208,7 @@ static void rt2x00lib_beaconupdate_iter(
- 					struct ieee80211_vif *vif)
- {
- 	struct rt2x00_dev *rt2x00dev = data;
-+	struct rt2x00_intf *intf = vif_to_intf(vif);
- 
- 	if (vif->type != NL80211_IFTYPE_AP &&
- 	    vif->type != NL80211_IFTYPE_ADHOC &&
-@@ -220,7 +222,8 @@ static void rt2x00lib_beaconupdate_iter(
- 	 * never be called for USB devices.
- 	 */
- 	WARN_ON(rt2x00_is_usb(rt2x00dev));
--	rt2x00queue_update_beacon(rt2x00dev, vif);
-+	if (intf->enable_beacon)
-+		rt2x00queue_update_beacon(rt2x00dev, vif);
- }
- 
- void rt2x00lib_beacondone(struct rt2x00_dev *rt2x00dev)
diff --git a/package/kernel/mac80211/patches/700-mwl8k-missing-pci-id-for-WNR854T.patch b/package/kernel/mac80211/patches/700-mwl8k-missing-pci-id-for-WNR854T.patch
deleted file mode 100644
index a901a44..0000000
--- a/package/kernel/mac80211/patches/700-mwl8k-missing-pci-id-for-WNR854T.patch
+++ /dev/null
@@ -1,10 +0,0 @@
---- a/drivers/net/wireless/marvell/mwl8k.c
-+++ b/drivers/net/wireless/marvell/mwl8k.c
-@@ -5681,6 +5681,7 @@ MODULE_FIRMWARE("mwl8k/fmimage_8366.fw")
- MODULE_FIRMWARE(MWL8K_8366_AP_FW(MWL8K_8366_AP_FW_API));
- 
- static const struct pci_device_id mwl8k_pci_id_table[] = {
-+	{ PCI_VDEVICE(MARVELL, 0x2a02), .driver_data = MWL8363, },
- 	{ PCI_VDEVICE(MARVELL, 0x2a0a), .driver_data = MWL8363, },
- 	{ PCI_VDEVICE(MARVELL, 0x2a0c), .driver_data = MWL8363, },
- 	{ PCI_VDEVICE(MARVELL, 0x2a24), .driver_data = MWL8363, },
diff --git a/package/kernel/mac80211/patches/801-libertas-configure-sysfs-links.patch b/package/kernel/mac80211/patches/801-libertas-configure-sysfs-links.patch
deleted file mode 100644
index 02f3053..0000000
--- a/package/kernel/mac80211/patches/801-libertas-configure-sysfs-links.patch
+++ /dev/null
@@ -1,21 +0,0 @@
---- a/drivers/net/wireless/marvell/libertas/cfg.c
-+++ b/drivers/net/wireless/marvell/libertas/cfg.c
-@@ -2122,6 +2122,8 @@ struct wireless_dev *lbs_cfg_alloc(struc
- 		goto err_wiphy_new;
- 	}
- 
-+	set_wiphy_dev(wdev->wiphy, dev);
-+
- 	lbs_deb_leave(LBS_DEB_CFG80211);
- 	return wdev;
- 
---- a/drivers/net/wireless/marvell/libertas/main.c
-+++ b/drivers/net/wireless/marvell/libertas/main.c
-@@ -987,6 +987,7 @@ struct lbs_private *lbs_add_card(void *c
- 		goto err_adapter;
- 	}
- 
-+	dev_net_set(dev, wiphy_net(wdev->wiphy));
- 	dev->ieee80211_ptr = wdev;
- 	dev->ml_priv = priv;
- 	SET_NETDEV_DEV(dev, dmdev);
diff --git a/package/kernel/mac80211/patches/802-libertas-set-wireless-macaddr.patch b/package/kernel/mac80211/patches/802-libertas-set-wireless-macaddr.patch
deleted file mode 100644
index ad30608..0000000
--- a/package/kernel/mac80211/patches/802-libertas-set-wireless-macaddr.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/drivers/net/wireless/marvell/libertas/cfg.c
-+++ b/drivers/net/wireless/marvell/libertas/cfg.c
-@@ -2212,6 +2212,8 @@ int lbs_cfg_register(struct lbs_private
- 	wdev->wiphy->n_cipher_suites = ARRAY_SIZE(cipher_suites);
- 	wdev->wiphy->reg_notifier = lbs_reg_notifier;
- 
-+	memcpy(wdev->wiphy->perm_addr, priv->current_addr, ETH_ALEN);
-+
- 	ret = wiphy_register(wdev->wiphy);
- 	if (ret < 0)
- 		pr_err("cannot register wiphy device\n");
diff --git a/package/kernel/mac80211/patches/805-b43-gpio-mask-module-option.patch b/package/kernel/mac80211/patches/805-b43-gpio-mask-module-option.patch
deleted file mode 100644
index fd9e6fd..0000000
--- a/package/kernel/mac80211/patches/805-b43-gpio-mask-module-option.patch
+++ /dev/null
@@ -1,37 +0,0 @@
---- a/drivers/net/wireless/broadcom/b43/b43.h
-+++ b/drivers/net/wireless/broadcom/b43/b43.h
-@@ -839,6 +839,7 @@ struct b43_wldev {
- 	bool qos_enabled;		/* TRUE, if QoS is used. */
- 	bool hwcrypto_enabled;		/* TRUE, if HW crypto acceleration is enabled. */
- 	bool use_pio;			/* TRUE if next init should use PIO */
-+	int gpiomask;			/* GPIO LED mask as a module parameter */
- 
- 	/* PHY/Radio device. */
- 	struct b43_phy phy;
---- a/drivers/net/wireless/broadcom/b43/main.c
-+++ b/drivers/net/wireless/broadcom/b43/main.c
-@@ -75,6 +75,11 @@ MODULE_FIRMWARE("b43/ucode16_mimo.fw");
- MODULE_FIRMWARE("b43/ucode5.fw");
- MODULE_FIRMWARE("b43/ucode9.fw");
- 
-+static int modparam_gpiomask = 0x000F;
-+module_param_named(gpiomask, modparam_gpiomask, int, 0444);
-+MODULE_PARM_DESC(gpiomask,
-+         "GPIO mask for LED control (default 0x000F)");
-+
- static int modparam_bad_frames_preempt;
- module_param_named(bad_frames_preempt, modparam_bad_frames_preempt, int, 0444);
- MODULE_PARM_DESC(bad_frames_preempt,
-@@ -2882,10 +2887,10 @@ static int b43_gpio_init(struct b43_wlde
- 	u32 mask, set;
- 
- 	b43_maskset32(dev, B43_MMIO_MACCTL, ~B43_MACCTL_GPOUTSMSK, 0);
--	b43_maskset16(dev, B43_MMIO_GPIO_MASK, ~0, 0xF);
-+	b43_maskset16(dev, B43_MMIO_GPIO_MASK, ~0, modparam_gpiomask);
- 
- 	mask = 0x0000001F;
--	set = 0x0000000F;
-+	set = modparam_gpiomask;
- 	if (dev->dev->chip_id == 0x4301) {
- 		mask |= 0x0060;
- 		set |= 0x0060;
diff --git a/package/kernel/mac80211/patches/810-b43_no_pio.patch b/package/kernel/mac80211/patches/810-b43_no_pio.patch
deleted file mode 100644
index 79428c2..0000000
--- a/package/kernel/mac80211/patches/810-b43_no_pio.patch
+++ /dev/null
@@ -1,86 +0,0 @@
---- a/drivers/net/wireless/broadcom/b43/Makefile
-+++ b/drivers/net/wireless/broadcom/b43/Makefile
-@@ -17,7 +17,7 @@ b43-$(CPTCFG_B43_PHY_AC)	+= phy_ac.o
- b43-y				+= sysfs.o
- b43-y				+= xmit.o
- b43-y				+= dma.o
--b43-y				+= pio.o
-+b43-$(CPTCFG_B43_PIO)		+= pio.o
- b43-y				+= rfkill.o
- b43-y				+= ppr.o
- b43-$(CPTCFG_B43_LEDS)		+= leds.o
---- a/drivers/net/wireless/broadcom/b43/main.c
-+++ b/drivers/net/wireless/broadcom/b43/main.c
-@@ -2008,10 +2008,12 @@ static void b43_do_interrupt_thread(stru
- 			dma_reason[0], dma_reason[1],
- 			dma_reason[2], dma_reason[3],
- 			dma_reason[4], dma_reason[5]);
-+#ifdef CPTCFG_B43_PIO
- 		b43err(dev->wl, "This device does not support DMA "
- 			       "on your system. It will now be switched to PIO.\n");
- 		/* Fall back to PIO transfers if we get fatal DMA errors! */
- 		dev->use_pio = true;
-+#endif
- 		b43_controller_restart(dev, "DMA error");
- 		return;
- 	}
---- a/drivers/net/wireless/broadcom/b43/pio.h
-+++ b/drivers/net/wireless/broadcom/b43/pio.h
-@@ -150,7 +150,7 @@ static inline void b43_piorx_write32(str
- 	b43_write32(q->dev, q->mmio_base + offset, value);
- }
- 
--
-+#ifdef CPTCFG_B43_PIO
- int b43_pio_init(struct b43_wldev *dev);
- void b43_pio_free(struct b43_wldev *dev);
- 
-@@ -161,5 +161,37 @@ void b43_pio_rx(struct b43_pio_rxqueue *
- 
- void b43_pio_tx_suspend(struct b43_wldev *dev);
- void b43_pio_tx_resume(struct b43_wldev *dev);
-+#else
-+static inline int b43_pio_init(struct b43_wldev *dev)
-+{
-+	return 0;
-+}
-+
-+static inline void b43_pio_free(struct b43_wldev *dev)
-+{
-+}
-+
-+static inline int b43_pio_tx(struct b43_wldev *dev, struct sk_buff *skb)
-+{
-+	return 0;
-+}
-+
-+static inline void b43_pio_handle_txstatus(struct b43_wldev *dev,
-+					   const struct b43_txstatus *status)
-+{
-+}
-+
-+static inline void b43_pio_rx(struct b43_pio_rxqueue *q)
-+{
-+}
-+
-+static inline void b43_pio_tx_suspend(struct b43_wldev *dev)
-+{
-+}
-+
-+static inline void b43_pio_tx_resume(struct b43_wldev *dev)
-+{
-+}
-+#endif /* CPTCFG_B43_PIO */
- 
- #endif /* B43_PIO_H_ */
---- a/drivers/net/wireless/broadcom/b43/Kconfig
-+++ b/drivers/net/wireless/broadcom/b43/Kconfig
-@@ -98,7 +98,7 @@ config B43_BCMA_PIO
- 	default y
- 
- config B43_PIO
--	bool
-+	bool "Broadcom 43xx PIO support"
- 	depends on B43 && B43_SSB
- 	select SSB_BLOCKIO
- 	default y
diff --git a/package/kernel/mac80211/patches/820-b43-add-antenna-control.patch b/package/kernel/mac80211/patches/820-b43-add-antenna-control.patch
deleted file mode 100644
index b60ef76..0000000
--- a/package/kernel/mac80211/patches/820-b43-add-antenna-control.patch
+++ /dev/null
@@ -1,131 +0,0 @@
---- a/drivers/net/wireless/broadcom/b43/main.c
-+++ b/drivers/net/wireless/broadcom/b43/main.c
-@@ -1648,7 +1648,7 @@ static void b43_write_beacon_template(st
- 				  len, ram_offset, shm_size_offset, rate);
- 
- 	/* Write the PHY TX control parameters. */
--	antenna = B43_ANTENNA_DEFAULT;
-+	antenna = dev->tx_antenna;
- 	antenna = b43_antenna_to_phyctl(antenna);
- 	ctl = b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_BEACPHYCTL);
- 	/* We can't send beacons with short preamble. Would get PHY errors. */
-@@ -3300,8 +3300,8 @@ static int b43_chip_init(struct b43_wlde
- 
- 	/* Select the antennae */
- 	if (phy->ops->set_rx_antenna)
--		phy->ops->set_rx_antenna(dev, B43_ANTENNA_DEFAULT);
--	b43_mgmtframe_txantenna(dev, B43_ANTENNA_DEFAULT);
-+		phy->ops->set_rx_antenna(dev, dev->rx_antenna);
-+	b43_mgmtframe_txantenna(dev, dev->tx_antenna);
- 
- 	if (phy->type == B43_PHYTYPE_B) {
- 		value16 = b43_read16(dev, 0x005E);
-@@ -4001,7 +4001,6 @@ static int b43_op_config(struct ieee8021
- 	struct b43_wldev *dev = wl->current_dev;
- 	struct b43_phy *phy = &dev->phy;
- 	struct ieee80211_conf *conf = &hw->conf;
--	int antenna;
- 	int err = 0;
- 
- 	mutex_lock(&wl->mutex);
-@@ -4044,11 +4043,9 @@ static int b43_op_config(struct ieee8021
- 	}
- 
- 	/* Antennas for RX and management frame TX. */
--	antenna = B43_ANTENNA_DEFAULT;
--	b43_mgmtframe_txantenna(dev, antenna);
--	antenna = B43_ANTENNA_DEFAULT;
-+	b43_mgmtframe_txantenna(dev, dev->tx_antenna);
- 	if (phy->ops->set_rx_antenna)
--		phy->ops->set_rx_antenna(dev, antenna);
-+		phy->ops->set_rx_antenna(dev, dev->rx_antenna);
- 
- 	if (wl->radio_enabled != phy->radio_on) {
- 		if (wl->radio_enabled) {
-@@ -5207,6 +5204,47 @@ static int b43_op_get_survey(struct ieee
- 	return 0;
- }
- 
-+static int b43_op_set_antenna(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant)
-+{
-+	struct b43_wl *wl = hw_to_b43_wl(hw);
-+	struct b43_wldev *dev = wl->current_dev;
-+
-+	if (tx_ant == 1 && rx_ant == 1) {
-+		dev->tx_antenna = B43_ANTENNA0;
-+		dev->rx_antenna = B43_ANTENNA0;
-+	}
-+	else if (tx_ant == 2 && rx_ant == 2) {
-+		dev->tx_antenna = B43_ANTENNA1;
-+		dev->rx_antenna = B43_ANTENNA1;
-+	}
-+	else if ((tx_ant & 3) == 3 && (rx_ant & 3) == 3) {
-+		dev->tx_antenna = B43_ANTENNA_DEFAULT;
-+		dev->rx_antenna = B43_ANTENNA_DEFAULT;
-+	}
-+	else {
-+		return -EINVAL;
-+	}
-+
-+	return 0;
-+}
-+
-+
-+static int b43_op_get_antenna(struct ieee80211_hw *hw, u32 *tx_ant, u32 *rx_ant)
-+{
-+	struct b43_wl *wl = hw_to_b43_wl(hw);
-+	struct b43_wldev *dev = wl->current_dev;
-+
-+	switch (dev->tx_antenna) {
-+	case B43_ANTENNA0:
-+		*tx_ant = 1; *rx_ant = 1; break;
-+	case B43_ANTENNA1:
-+		*tx_ant = 2; *rx_ant = 2; break;
-+	case B43_ANTENNA_DEFAULT:
-+		*tx_ant = 3; *rx_ant = 3; break;
-+	}
-+	return 0;
-+}
-+
- static const struct ieee80211_ops b43_hw_ops = {
- 	.tx			= b43_op_tx,
- 	.conf_tx		= b43_op_conf_tx,
-@@ -5228,6 +5266,8 @@ static const struct ieee80211_ops b43_hw
- 	.sw_scan_complete	= b43_op_sw_scan_complete_notifier,
- 	.get_survey		= b43_op_get_survey,
- 	.rfkill_poll		= b43_rfkill_poll,
-+	.set_antenna		= b43_op_set_antenna,
-+	.get_antenna		= b43_op_get_antenna,
- };
- 
- /* Hard-reset the chip. Do not call this directly.
-@@ -5536,6 +5576,8 @@ static int b43_one_core_attach(struct b4
- 	if (!wldev)
- 		goto out;
- 
-+	wldev->rx_antenna = B43_ANTENNA_DEFAULT;
-+	wldev->tx_antenna = B43_ANTENNA_DEFAULT;
- 	wldev->use_pio = b43_modparam_pio;
- 	wldev->dev = dev;
- 	wldev->wl = wl;
-@@ -5626,6 +5668,9 @@ static struct b43_wl *b43_wireless_init(
- 
- 	hw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;
- 
-+	hw->wiphy->available_antennas_rx = 0x3;
-+	hw->wiphy->available_antennas_tx = 0x3;
-+
- 	wl->hw_registred = false;
- 	hw->max_rates = 2;
- 	SET_IEEE80211_DEV(hw, dev->dev);
---- a/drivers/net/wireless/broadcom/b43/b43.h
-+++ b/drivers/net/wireless/broadcom/b43/b43.h
-@@ -840,6 +840,8 @@ struct b43_wldev {
- 	bool hwcrypto_enabled;		/* TRUE, if HW crypto acceleration is enabled. */
- 	bool use_pio;			/* TRUE if next init should use PIO */
- 	int gpiomask;			/* GPIO LED mask as a module parameter */
-+	int rx_antenna;			/* Used RX antenna (B43_ANTENNAxxx) */
-+	int tx_antenna;			/* Used TX antenna (B43_ANTENNAxxx) */
- 
- 	/* PHY/Radio device. */
- 	struct b43_phy phy;
diff --git a/package/kernel/mac80211/patches/841-b43-reduce-number-of-RX-slots.patch b/package/kernel/mac80211/patches/841-b43-reduce-number-of-RX-slots.patch
deleted file mode 100644
index 5899706..0000000
--- a/package/kernel/mac80211/patches/841-b43-reduce-number-of-RX-slots.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/drivers/net/wireless/broadcom/b43/dma.h
-+++ b/drivers/net/wireless/broadcom/b43/dma.h
-@@ -169,7 +169,7 @@ struct b43_dmadesc_generic {
- 
- /* DMA engine tuning knobs */
- #define B43_TXRING_SLOTS		256
--#define B43_RXRING_SLOTS		256
-+#define B43_RXRING_SLOTS		32
- #define B43_DMA0_RX_FW598_BUFSIZE	(B43_DMA0_RX_FW598_FO + IEEE80211_MAX_FRAME_LEN)
- #define B43_DMA0_RX_FW351_BUFSIZE	(B43_DMA0_RX_FW351_FO + IEEE80211_MAX_FRAME_LEN)
- 
diff --git a/package/kernel/mac80211/patches/845-b43-only-use-gpio-0-1-for-led.patch b/package/kernel/mac80211/patches/845-b43-only-use-gpio-0-1-for-led.patch
deleted file mode 100644
index 8d0c041..0000000
--- a/package/kernel/mac80211/patches/845-b43-only-use-gpio-0-1-for-led.patch
+++ /dev/null
@@ -1,17 +0,0 @@
---- a/drivers/net/wireless/broadcom/b43/main.c
-+++ b/drivers/net/wireless/broadcom/b43/main.c
-@@ -2899,6 +2899,14 @@ static int b43_gpio_init(struct b43_wlde
- 	} else if (dev->dev->chip_id == 0x5354) {
- 		/* Don't allow overtaking buttons GPIOs */
- 		set &= 0x2; /* 0x2 is LED GPIO on BCM5354 */
-+	} else if (dev->dev->chip_id == BCMA_CHIP_ID_BCM4716 || 
-+		   dev->dev->chip_id == BCMA_CHIP_ID_BCM47162 ||
-+		   dev->dev->chip_id == BCMA_CHIP_ID_BCM5356 ||
-+		   dev->dev->chip_id == BCMA_CHIP_ID_BCM5357 ||
-+		   dev->dev->chip_id == BCMA_CHIP_ID_BCM53572) {
-+		/* just use gpio 0 and 1 for 2.4 GHz wifi led */
-+		set &= 0x3;
-+		mask &= 0x3;
- 	}
- 
- 	if (0 /* FIXME: conditional unknown */ ) {
diff --git a/package/kernel/mac80211/patches/847-b43-always-take-overlapping-devs.patch b/package/kernel/mac80211/patches/847-b43-always-take-overlapping-devs.patch
deleted file mode 100644
index ef7f3c9..0000000
--- a/package/kernel/mac80211/patches/847-b43-always-take-overlapping-devs.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/drivers/net/wireless/broadcom/b43/main.c
-+++ b/drivers/net/wireless/broadcom/b43/main.c
-@@ -117,7 +117,7 @@ static int b43_modparam_pio = 0;
- module_param_named(pio, b43_modparam_pio, int, 0644);
- MODULE_PARM_DESC(pio, "Use PIO accesses by default: 0=DMA, 1=PIO");
- 
--static int modparam_allhwsupport = !IS_ENABLED(CPTCFG_BRCMSMAC);
-+static int modparam_allhwsupport = 1;
- module_param_named(allhwsupport, modparam_allhwsupport, int, 0444);
- MODULE_PARM_DESC(allhwsupport, "Enable support for all hardware (even it if overlaps with the brcmsmac driver)");
- 
diff --git a/package/kernel/mac80211/patches/850-brcmsmac-remove-extra-regulation-restriction.patch b/package/kernel/mac80211/patches/850-brcmsmac-remove-extra-regulation-restriction.patch
deleted file mode 100644
index 3c93386..0000000
--- a/package/kernel/mac80211/patches/850-brcmsmac-remove-extra-regulation-restriction.patch
+++ /dev/null
@@ -1,27 +0,0 @@
---- a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/channel.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/channel.c
-@@ -58,19 +58,12 @@
- 				 (((c) < 149) ? 3 : 4))))
- 
- #define BRCM_2GHZ_2412_2462	REG_RULE(2412-10, 2462+10, 40, 0, 19, 0)
--#define BRCM_2GHZ_2467_2472	REG_RULE(2467-10, 2472+10, 20, 0, 19, \
--					 NL80211_RRF_NO_IR)
-+#define BRCM_2GHZ_2467_2472	REG_RULE(2467-10, 2472+10, 20, 0, 19, 0)
- 
--#define BRCM_5GHZ_5180_5240	REG_RULE(5180-10, 5240+10, 40, 0, 21, \
--					 NL80211_RRF_NO_IR)
--#define BRCM_5GHZ_5260_5320	REG_RULE(5260-10, 5320+10, 40, 0, 21, \
--					 NL80211_RRF_DFS | \
--					 NL80211_RRF_NO_IR)
--#define BRCM_5GHZ_5500_5700	REG_RULE(5500-10, 5700+10, 40, 0, 21, \
--					 NL80211_RRF_DFS | \
--					 NL80211_RRF_NO_IR)
--#define BRCM_5GHZ_5745_5825	REG_RULE(5745-10, 5825+10, 40, 0, 21, \
--					 NL80211_RRF_NO_IR)
-+#define BRCM_5GHZ_5180_5240	REG_RULE(5180-10, 5240+10, 40, 0, 21, 0)
-+#define BRCM_5GHZ_5260_5320	REG_RULE(5260-10, 5320+10, 40, 0, 21, 0)
-+#define BRCM_5GHZ_5500_5700	REG_RULE(5500-10, 5700+10, 40, 0, 21, 0)
-+#define BRCM_5GHZ_5745_5825	REG_RULE(5745-10, 5825+10, 40, 0, 21, 0)
- 
- static const struct ieee80211_regdomain brcms_regdom_x2 = {
- 	.n_reg_rules = 6,
diff --git a/package/kernel/mac80211/patches/861-brcmfmac-register-wiphy-s-during-module_init.patch b/package/kernel/mac80211/patches/861-brcmfmac-register-wiphy-s-during-module_init.patch
deleted file mode 100644
index ae571c9..0000000
--- a/package/kernel/mac80211/patches/861-brcmfmac-register-wiphy-s-during-module_init.patch
+++ /dev/null
@@ -1,97 +0,0 @@
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
-Date: Mon, 8 Jun 2015 16:11:40 +0200
-Subject: [PATCH] brcmfmac: register wiphy(s) during module_init
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-This is needed by OpenWrt which expects all PHYs to be created after
-module loads successfully.
-
-Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
----
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
-@@ -1213,6 +1213,7 @@ int __init brcmf_core_init(void)
- {
- 	if (!schedule_work(&brcmf_driver_work))
- 		return -EBUSY;
-+	flush_work(&brcmf_driver_work);
- 
- 	return 0;
- }
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c
-@@ -444,6 +444,7 @@ struct brcmf_fw {
- 	u16 bus_nr;
- 	void (*done)(struct device *dev, const struct firmware *fw,
- 		     void *nvram_image, u32 nvram_len);
-+	struct completion *completion;
- };
- 
- static void brcmf_fw_request_nvram_done(const struct firmware *fw, void *ctx)
-@@ -478,6 +479,8 @@ static void brcmf_fw_request_nvram_done(
- 		goto fail;
- 
- 	fwctx->done(fwctx->dev, fwctx->code, nvram, nvram_length);
-+	if (fwctx->completion)
-+		complete(fwctx->completion);
- 	kfree(fwctx);
- 	return;
- 
-@@ -485,6 +488,8 @@ fail:
- 	brcmf_dbg(TRACE, "failed: dev=%s\n", dev_name(fwctx->dev));
- 	release_firmware(fwctx->code);
- 	device_release_driver(fwctx->dev);
-+	if (fwctx->completion)
-+		complete(fwctx->completion);
- 	kfree(fwctx);
- }
- 
-@@ -500,6 +505,8 @@ static void brcmf_fw_request_code_done(c
- 	/* only requested code so done here */
- 	if (!(fwctx->flags & BRCMF_FW_REQUEST_NVRAM)) {
- 		fwctx->done(fwctx->dev, fw, NULL, 0);
-+		if (fwctx->completion)
-+			complete(fwctx->completion);
- 		kfree(fwctx);
- 		return;
- 	}
-@@ -517,6 +524,8 @@ static void brcmf_fw_request_code_done(c
- fail:
- 	brcmf_dbg(TRACE, "failed: dev=%s\n", dev_name(fwctx->dev));
- 	device_release_driver(fwctx->dev);
-+	if (fwctx->completion)
-+		complete(fwctx->completion);
- 	kfree(fwctx);
- }
- 
-@@ -528,6 +537,8 @@ int brcmf_fw_get_firmwares_pcie(struct d
- 				u16 domain_nr, u16 bus_nr)
- {
- 	struct brcmf_fw *fwctx;
-+	struct completion completion;
-+	int err;
- 
- 	brcmf_dbg(TRACE, "enter: dev=%s\n", dev_name(dev));
- 	if (!fw_cb || !code)
-@@ -548,9 +559,17 @@ int brcmf_fw_get_firmwares_pcie(struct d
- 	fwctx->domain_nr = domain_nr;
- 	fwctx->bus_nr = bus_nr;
- 
--	return request_firmware_nowait(THIS_MODULE, true, code, dev,
-+	init_completion(&completion);
-+	fwctx->completion = &completion;
-+
-+	err = request_firmware_nowait(THIS_MODULE, true, code, dev,
- 				       GFP_KERNEL, fwctx,
- 				       brcmf_fw_request_code_done);
-+	if (!err)
-+		wait_for_completion_timeout(fwctx->completion,
-+					    msecs_to_jiffies(5000));
-+	fwctx->completion = NULL;
-+	return err;
- }
- 
- int brcmf_fw_get_firmwares(struct device *dev, u16 flags,
diff --git a/package/kernel/mac80211/patches/862-brcmfmac-workaround-bug-with-some-inconsistent-BSSes.patch b/package/kernel/mac80211/patches/862-brcmfmac-workaround-bug-with-some-inconsistent-BSSes.patch
deleted file mode 100644
index a3a6bc4..0000000
--- a/package/kernel/mac80211/patches/862-brcmfmac-workaround-bug-with-some-inconsistent-BSSes.patch
+++ /dev/null
@@ -1,50 +0,0 @@
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
-Date: Thu, 9 Jul 2015 00:07:59 +0200
-Subject: [PATCH] brcmfmac: workaround bug with some inconsistent BSSes state
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
----
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-@@ -665,9 +665,37 @@ static struct wireless_dev *brcmf_cfg802
- 						     u32 *flags,
- 						     struct vif_params *params)
- {
-+	struct net_device *dev;
- 	struct wireless_dev *wdev;
- 	int err;
- 
-+	/*
-+	 * There is a bug with in-firmware BSS management. When adding virtual
-+	 * interface brcmfmac first tells firmware to create new BSS and then
-+	 * it creates new struct net_device.
-+	 *
-+	 * If creating/registering netdev(ice) fails, BSS remains in some bugged
-+	 * state. It conflicts with existing BSSes by overtaking their auth
-+	 * requests.
-+	 *
-+	 * It results in one BSS (addresss X) sending beacons and another BSS
-+	 * (address Y) replying to authentication requests. This makes interface
-+	 * unusable as AP.
-+	 *
-+	 * To workaround this bug we may try to guess if register_netdev(ice)
-+	 * will fail. The most obvious case is using interface name that already
-+	 * exists. This is actually quite likely with brcmfmac & some user space
-+	 * scripts as brcmfmac doesn't allow deleting virtual interfaces.
-+	 * So this bug can be triggered even by something trivial like:
-+	 * iw dev wlan0 delete
-+	 * iw phy phy0 interface add wlan0 type __ap
-+	 */
-+	dev = dev_get_by_name(&init_net, name);
-+	if (dev) {
-+		dev_put(dev);
-+		return ERR_PTR(-EEXIST);
-+	}
-+
- 	brcmf_dbg(TRACE, "enter: %s type %d\n", name, type);
- 	err = brcmf_vif_add_validate(wiphy_to_cfg(wiphy), type);
- 	if (err) {
diff --git a/package/kernel/mac80211/patches/863-brcmfmac-Disable-power-management.patch b/package/kernel/mac80211/patches/863-brcmfmac-Disable-power-management.patch
deleted file mode 100644
index f301fe1..0000000
--- a/package/kernel/mac80211/patches/863-brcmfmac-Disable-power-management.patch
+++ /dev/null
@@ -1,27 +0,0 @@
-From 66ae1b1750720a33e29792a177b1e696f4f005fb Mon Sep 17 00:00:00 2001
-From: Phil Elwell <phil@raspberrypi.org>
-Date: Wed, 9 Mar 2016 17:25:59 +0000
-Subject: [PATCH] brcmfmac: Disable power management
-
-Disable wireless power saving in the brcmfmac WLAN driver. This is a
-temporary measure until the connectivity loss resulting from power
-saving is resolved.
-
-Signed-off-by: Phil Elwell <phil@raspberrypi.org>
----
- drivers/net/wireless/brcm80211/brcmfmac/cfg80211.c | 2 ++
- 1 file changed, 2 insertions(+)
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-@@ -2783,6 +2783,10 @@ brcmf_cfg80211_set_power_mgmt(struct wip
- 	 * preference in cfg struct to apply this to
- 	 * FW later while initializing the dongle
- 	 */
-+#if defined(CONFIG_BCM2708) || defined(CONFIG_BCM2709)
-+	pr_info("power management disabled\n");
-+	enabled = false;
-+#endif
- 	cfg->pwr_save = enabled;
- 	if (!check_vif_up(ifp->vif)) {
- 
diff --git a/package/kernel/mac80211/patches/910-00-rt2x00-enable-rt2800soc-for-mt7620.patch b/package/kernel/mac80211/patches/910-00-rt2x00-enable-rt2800soc-for-mt7620.patch
deleted file mode 100644
index bc9f799..0000000
--- a/package/kernel/mac80211/patches/910-00-rt2x00-enable-rt2800soc-for-mt7620.patch
+++ /dev/null
@@ -1,20 +0,0 @@
---- a/drivers/net/wireless/ralink/rt2x00/Kconfig
-+++ b/drivers/net/wireless/ralink/rt2x00/Kconfig
-@@ -211,7 +211,7 @@ endif
- config RT2800SOC
- 	tristate "Ralink WiSoC support"
- 	depends on m
--	depends on SOC_RT288X || SOC_RT305X || SOC_RT3883
-+	depends on SOC_RT288X || SOC_RT305X || SOC_RT3883 || SOC_MT7620
- 	select RT2X00_LIB_SOC
- 	select RT2X00_LIB_MMIO
- 	select RT2X00_LIB_CRYPTO
-@@ -248,7 +248,7 @@ config RT2X00_LIB_PCI
- 
- config RT2X00_LIB_SOC
- 	tristate "RT2x00 SoC support"
--	depends on SOC_RT288X || SOC_RT305X || SOC_RT3883
-+	depends on SOC_RT288X || SOC_RT305X || SOC_RT3883 || SOC_MT7620
- 	depends on m
- 	select RT2X00_LIB
- 
diff --git a/package/kernel/mac80211/patches/910-01-add-support-for-mt7620.patch b/package/kernel/mac80211/patches/910-01-add-support-for-mt7620.patch
deleted file mode 100644
index be210f2..0000000
--- a/package/kernel/mac80211/patches/910-01-add-support-for-mt7620.patch
+++ /dev/null
@@ -1,1202 +0,0 @@
---- a/drivers/net/wireless/ralink/rt2x00/rt2800.h
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800.h
-@@ -81,6 +81,7 @@
- #define RF5372				0x5372
- #define RF5390				0x5390
- #define RF5392				0x5392
-+#define RF7620				0x7620
- 
- /*
-  * Chipset revisions.
-@@ -656,6 +657,14 @@
- #define RF_CSR_CFG_BUSY			FIELD32(0x00020000)
- 
- /*
-+ * mt7620 RF registers (reversed order)
-+ */
-+#define RF_CSR_CFG_DATA_MT7620		FIELD32(0x0000ff00)
-+#define RF_CSR_CFG_REGNUM_MT7620	FIELD32(0x03ff0000)
-+#define RF_CSR_CFG_WRITE_MT7620		FIELD32(0x00000010)
-+#define RF_CSR_CFG_BUSY_MT7620		FIELD32(0x00000001)
-+
-+/*
-  * EFUSE_CSR: RT30x0 EEPROM
-  */
- #define EFUSE_CTRL			0x0580
-@@ -1039,6 +1048,11 @@
- #define AUTOWAKEUP_CFG_AUTOWAKE		FIELD32(0x00008000)
- 
- /*
-+ * mt7620
-+ */
-+#define MIMO_PS_CFG			0x1210
-+
-+/*
-  * EDCA_AC0_CFG:
-  */
- #define EDCA_AC0_CFG			0x1300
-@@ -1218,6 +1232,8 @@
- #define TX_PIN_CFG_RFTR_POL		FIELD32(0x00020000)
- #define TX_PIN_CFG_TRSW_EN		FIELD32(0x00040000)
- #define TX_PIN_CFG_TRSW_POL		FIELD32(0x00080000)
-+#define TX_PIN_CFG_RFRX_EN		FIELD32(0x00100000) /* mt7620 */
-+#define TX_PIN_CFG_RFRX_POL		FIELD32(0x00200000) /* mt7620 */
- #define TX_PIN_CFG_PA_PE_A2_EN		FIELD32(0x01000000)
- #define TX_PIN_CFG_PA_PE_G2_EN		FIELD32(0x02000000)
- #define TX_PIN_CFG_PA_PE_A2_POL		FIELD32(0x04000000)
-@@ -1564,6 +1580,17 @@
- #define TX_PWR_CFG_4_EXT_STBC4_CH2	FIELD32(0x0000000f)
- #define TX_PWR_CFG_4_EXT_STBC6_CH2	FIELD32(0x00000f00)
- 
-+/* mt7620 */
-+#define TX0_RF_GAIN_CORRECT		0x13a0
-+#define TX1_RF_GAIN_CORRECT		0x13a4
-+#define TX0_RF_GAIN_ATTEN		0x13a8
-+#define TX1_RF_GAIN_ATTEN		0x13ac
-+#define TX_ALG_CFG_0			0x13b0
-+#define TX_ALG_CFG_1			0x13b4
-+#define TX0_BB_GAIN_ATTEN		0x13c0
-+#define TX1_BB_GAIN_ATTEN		0x13c4
-+#define TX_ALC_VGA3			0x13c8
-+
- /* TX_PWR_CFG_7 */
- #define TX_PWR_CFG_7			0x13d4
- #define TX_PWR_CFG_7_OFDM54_CH0		FIELD32(0x0000000f)
---- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -61,6 +61,8 @@
- 	rt2800_regbusy_read((__dev), BBP_CSR_CFG, BBP_CSR_CFG_BUSY, (__reg))
- #define WAIT_FOR_RFCSR(__dev, __reg) \
- 	rt2800_regbusy_read((__dev), RF_CSR_CFG, RF_CSR_CFG_BUSY, (__reg))
-+#define WAIT_FOR_RFCSR_MT7620(__dev, __reg) \
-+	rt2800_regbusy_read((__dev), RF_CSR_CFG, RF_CSR_CFG_BUSY_MT7620, (__reg))
- #define WAIT_FOR_RF(__dev, __reg) \
- 	rt2800_regbusy_read((__dev), RF_CSR_CFG0, RF_CSR_CFG0_BUSY, (__reg))
- #define WAIT_FOR_MCU(__dev, __reg) \
-@@ -186,19 +188,55 @@ static void rt2800_rfcsr_write(struct rt
- 	 * Wait until the RFCSR becomes available, afterwards we
- 	 * can safely write the new data into the register.
- 	 */
--	if (WAIT_FOR_RFCSR(rt2x00dev, &reg)) {
--		reg = 0;
--		rt2x00_set_field32(&reg, RF_CSR_CFG_DATA, value);
--		rt2x00_set_field32(&reg, RF_CSR_CFG_REGNUM, word);
--		rt2x00_set_field32(&reg, RF_CSR_CFG_WRITE, 1);
--		rt2x00_set_field32(&reg, RF_CSR_CFG_BUSY, 1);
-+	switch (rt2x00dev->chip.rf) {
-+	case RF7620:
-+		if (WAIT_FOR_RFCSR_MT7620(rt2x00dev, &reg)) {
-+			reg = 0;
-+			rt2x00_set_field32(&reg, RF_CSR_CFG_DATA_MT7620, value);
-+			rt2x00_set_field32(&reg, RF_CSR_CFG_REGNUM_MT7620, word);
-+			rt2x00_set_field32(&reg, RF_CSR_CFG_WRITE_MT7620, 1);
-+			rt2x00_set_field32(&reg, RF_CSR_CFG_BUSY_MT7620, 1);
- 
--		rt2800_register_write_lock(rt2x00dev, RF_CSR_CFG, reg);
-+			rt2800_register_write_lock(rt2x00dev, RF_CSR_CFG, reg);
-+		}
-+		break;
-+
-+	default:
-+		if (WAIT_FOR_RFCSR(rt2x00dev, &reg)) {
-+			reg = 0;
-+			rt2x00_set_field32(&reg, RF_CSR_CFG_DATA, value);
-+			rt2x00_set_field32(&reg, RF_CSR_CFG_REGNUM, word);
-+			rt2x00_set_field32(&reg, RF_CSR_CFG_WRITE, 1);
-+			rt2x00_set_field32(&reg, RF_CSR_CFG_BUSY, 1);
-+
-+			rt2800_register_write_lock(rt2x00dev, RF_CSR_CFG, reg);
-+		}
-+		break;
- 	}
- 
- 	mutex_unlock(&rt2x00dev->csr_mutex);
- }
- 
-+static void rt2800_rfcsr_write_bank(struct rt2x00_dev *rt2x00dev, const u8 bank,
-+				    const unsigned int reg, const u8 value)
-+{
-+	rt2800_rfcsr_write(rt2x00dev, (reg | (bank << 6)), value);
-+}
-+
-+static void rt2800_rfcsr_write_chanreg(struct rt2x00_dev *rt2x00dev,
-+				       const unsigned int reg, const u8 value)
-+{
-+	rt2800_rfcsr_write_bank(rt2x00dev, 4, reg, value);
-+	rt2800_rfcsr_write_bank(rt2x00dev, 6, reg, value);
-+}
-+
-+static void rt2800_rfcsr_write_dccal(struct rt2x00_dev *rt2x00dev,
-+				     const unsigned int reg, const u8 value)
-+{
-+	rt2800_rfcsr_write_bank(rt2x00dev, 5, reg, value);
-+	rt2800_rfcsr_write_bank(rt2x00dev, 7, reg, value);
-+}
-+
- static void rt2800_rfcsr_read(struct rt2x00_dev *rt2x00dev,
- 			      const unsigned int word, u8 *value)
- {
-@@ -214,22 +252,47 @@ static void rt2800_rfcsr_read(struct rt2
- 	 * doesn't become available in time, reg will be 0xffffffff
- 	 * which means we return 0xff to the caller.
- 	 */
--	if (WAIT_FOR_RFCSR(rt2x00dev, &reg)) {
--		reg = 0;
--		rt2x00_set_field32(&reg, RF_CSR_CFG_REGNUM, word);
--		rt2x00_set_field32(&reg, RF_CSR_CFG_WRITE, 0);
--		rt2x00_set_field32(&reg, RF_CSR_CFG_BUSY, 1);
-+	switch (rt2x00dev->chip.rf) {
-+	case RF7620:
-+		if (WAIT_FOR_RFCSR_MT7620(rt2x00dev, &reg)) {
-+			reg = 0;
-+			rt2x00_set_field32(&reg, RF_CSR_CFG_REGNUM_MT7620, word);
-+			rt2x00_set_field32(&reg, RF_CSR_CFG_WRITE_MT7620, 0);
-+			rt2x00_set_field32(&reg, RF_CSR_CFG_BUSY_MT7620, 1);
- 
--		rt2800_register_write_lock(rt2x00dev, RF_CSR_CFG, reg);
-+			rt2800_register_write_lock(rt2x00dev, RF_CSR_CFG, reg);
- 
--		WAIT_FOR_RFCSR(rt2x00dev, &reg);
--	}
-+			WAIT_FOR_RFCSR_MT7620(rt2x00dev, &reg);
-+		}
- 
--	*value = rt2x00_get_field32(reg, RF_CSR_CFG_DATA);
-+		*value = rt2x00_get_field32(reg, RF_CSR_CFG_DATA_MT7620);
-+		break;
-+
-+	default:
-+		if (WAIT_FOR_RFCSR(rt2x00dev, &reg)) {
-+			reg = 0;
-+			rt2x00_set_field32(&reg, RF_CSR_CFG_REGNUM, word);
-+			rt2x00_set_field32(&reg, RF_CSR_CFG_WRITE, 0);
-+			rt2x00_set_field32(&reg, RF_CSR_CFG_BUSY, 1);
-+
-+			rt2800_register_write_lock(rt2x00dev, RF_CSR_CFG, reg);
-+
-+			WAIT_FOR_RFCSR(rt2x00dev, &reg);
-+		}
-+
-+		*value = rt2x00_get_field32(reg, RF_CSR_CFG_DATA);
-+		break;
-+	}
- 
- 	mutex_unlock(&rt2x00dev->csr_mutex);
- }
- 
-+static void rt2800_rfcsr_read_bank(struct rt2x00_dev *rt2x00dev, const u8 bank,
-+				   const unsigned int reg, u8 *value)
-+{
-+	rt2800_rfcsr_read(rt2x00dev, (reg | (bank << 6)), value);
-+}
-+
- static void rt2800_rf_write(struct rt2x00_dev *rt2x00dev,
- 			    const unsigned int word, const u32 value)
- {
-@@ -566,6 +629,16 @@ void rt2800_get_txwi_rxwi_size(struct rt
- 		*rxwi_size = RXWI_DESC_SIZE_5WORDS;
- 		break;
- 
-+	case RT5390:
-+		if ( rt2x00dev->chip.rf == RF7620 ) {
-+			*txwi_size = TXWI_DESC_SIZE_5WORDS;
-+			*rxwi_size = RXWI_DESC_SIZE_6WORDS;
-+		} else {
-+			*txwi_size = TXWI_DESC_SIZE_4WORDS;
-+			*rxwi_size = RXWI_DESC_SIZE_4WORDS;
-+		}
-+		break;
-+
- 	case RT5592:
- 		*txwi_size = TXWI_DESC_SIZE_5WORDS;
- 		*rxwi_size = RXWI_DESC_SIZE_6WORDS;
-@@ -3303,6 +3376,312 @@ static void rt2800_config_channel_rf55xx
- 	rt2800_bbp_write(rt2x00dev, 196, (rf->channel <= 14) ? 0x19 : 0x7F);
- }
- 
-+typedef struct mt7620_freqconfig {
-+	u8	Channel;
-+	u8	Rdiv;
-+	u16	N;
-+	u8	K;
-+	u8	D;
-+	u32	Ksd;
-+} mt7620_freqconfig;
-+
-+mt7620_freqconfig mt7620_chanconfig[] =
-+{
-+	/* 2.4 to 2.483 GHz
-+	 * CH	Rdiv	N	K	D	Ksd */
-+	{ 0,	0,	0,	0,	0,	0	},
-+	{ 1,	3,	0x50,	0,	0,	0x19999	},
-+	{ 2,	3,	0x50,	0,	0,	0x24444	},
-+	{ 3,	3,	0x50,	0,	0,	0x2EEEE	},
-+	{ 4,	3,	0x50,	0,	0,	0x39999	},
-+	{ 5,	3,	0x51,	0,	0,	0x04444	},
-+	{ 6,	3,	0x51,	0,	0,	0x0EEEE	},
-+	{ 7,	3,	0x51,	0,	0,	0x19999	},
-+	{ 8,	3,	0x51,	0,	0,	0x24444	},
-+	{ 9,	3,	0x51,	0,	0,	0x2EEEE	},
-+	{ 10,	3,	0x51,	0,	0,	0x39999	},
-+	{ 11,	3,	0x52,	0,	0,	0x04444	},
-+	{ 12,	3,	0x52,	0,	0,	0x0EEEE	},
-+	{ 13,	3,	0x52,	0,	0,	0x19999	},
-+	{ 14,	3,	0x52,	0,	0,	0x33333	},
-+};
-+
-+static void rt2800_config_channel_rf7620(struct rt2x00_dev *rt2x00dev,
-+					 struct ieee80211_conf *conf,
-+					 struct rf_channel *rf,
-+					 struct channel_info *info)
-+{
-+	int i;
-+	u8 bbp;
-+	u8 rfcsr;
-+	u8 txrx_agc_fc;
-+	u32 reg;
-+	u16 eeprom, target_power;
-+	u32 mac_sys_ctrl, mac_status;
-+	u32 tx_pin = 0x00150F0F;
-+	struct hw_mode_spec *spec = &rt2x00dev->spec;
-+	struct rt2800_drv_data *drv_data = rt2x00dev->drv_data;
-+
-+	/* Frequeny plan setting */
-+	/*	
-+	  * Rdiv setting
-+	  * R13[1:0] 
-+	  */
-+	rt2800_rfcsr_read(rt2x00dev, 13, &rfcsr);
-+	rfcsr = rfcsr & (~0x03);
-+	if (spec->clk_is_20mhz)
-+		rfcsr |= (mt7620_chanconfig[rf->channel].Rdiv & 0x3);
-+	rt2800_rfcsr_write(rt2x00dev, 13, rfcsr);
-+
-+	/*  
-+	 * N setting
-+	 * R21[0], R20[7:0] 
-+	 */
-+	rt2800_rfcsr_read(rt2x00dev, 20, &rfcsr);
-+	rfcsr = (mt7620_chanconfig[rf->channel].N & 0x00ff);
-+	rt2800_rfcsr_write(rt2x00dev, 20, rfcsr);
-+
-+	rt2800_rfcsr_read(rt2x00dev, 21, &rfcsr);
-+	rfcsr = rfcsr & (~0x01);
-+	rfcsr |= ((mt7620_chanconfig[rf->channel].N & 0x0100) >> 8);
-+	rt2800_rfcsr_write(rt2x00dev, 21, rfcsr);
-+
-+	/* 
-+	 * K setting 
-+	 * R16[3:0] (RF PLL freq selection)
-+	 */
-+	rt2800_rfcsr_read(rt2x00dev, 16, &rfcsr);
-+	rfcsr = rfcsr & (~0x0f);
-+	rfcsr |= (mt7620_chanconfig[rf->channel].K & 0x0f);
-+	rt2800_rfcsr_write(rt2x00dev, 16, rfcsr);
-+
-+	/* 
-+	 * D setting 
-+	 * R22[2:0] (D=15, R22[2:0]=<111>)
-+	 */
-+	rt2800_rfcsr_read(rt2x00dev, 22, &rfcsr);
-+	rfcsr = rfcsr & (~0x07);
-+	rfcsr |= (mt7620_chanconfig[rf->channel].D & 0x07);
-+	rt2800_rfcsr_write(rt2x00dev, 22, rfcsr);
-+
-+	/*	
-+	 * Ksd setting
-+	 * Ksd: R19<1:0>,R18<7:0>,R17<7:0>
-+	 */
-+	rt2800_rfcsr_read(rt2x00dev, 17, &rfcsr);
-+	rfcsr = (mt7620_chanconfig[rf->channel].Ksd & 0x000000ff);
-+	rt2800_rfcsr_write(rt2x00dev, 17, rfcsr);
-+
-+	rt2800_rfcsr_read(rt2x00dev, 18, &rfcsr);
-+	rfcsr = ((mt7620_chanconfig[rf->channel].Ksd & 0x0000ff00) >> 8);
-+	rt2800_rfcsr_write(rt2x00dev, 18, rfcsr);
-+
-+	rt2800_rfcsr_read(rt2x00dev, 19, &rfcsr);
-+	rfcsr = rfcsr & (~0x03);
-+	rfcsr |= ((mt7620_chanconfig[rf->channel].Ksd & 0x00030000) >> 16);
-+	rt2800_rfcsr_write(rt2x00dev, 19, rfcsr);
-+
-+	/* Default: XO=20MHz , SDM mode */
-+	rt2800_rfcsr_read(rt2x00dev, 16, &rfcsr);
-+	rfcsr = rfcsr & (~0xE0);
-+	rfcsr |= 0x80;
-+	rt2800_rfcsr_write(rt2x00dev, 16, rfcsr);
-+
-+	rt2800_rfcsr_read(rt2x00dev, 21, &rfcsr);
-+	rfcsr |= 0x80;
-+	rt2800_rfcsr_write(rt2x00dev, 21, rfcsr);
-+
-+	rt2800_rfcsr_read(rt2x00dev, 1, &rfcsr);
-+	if (rt2x00dev->default_ant.tx_chain_num == 1)
-+		rfcsr &= (~0x2);
-+	else
-+		rfcsr |= 0x2;
-+	rt2800_rfcsr_write(rt2x00dev, 1, rfcsr);
-+
-+	rt2800_rfcsr_read(rt2x00dev, 2, &rfcsr);
-+	if (rt2x00dev->default_ant.tx_chain_num == 1)
-+		rfcsr &= (~0x20);
-+	else
-+		rfcsr |= 0x20;
-+	if (rt2x00dev->default_ant.rx_chain_num == 1)
-+		rfcsr &= (~0x02);
-+	else
-+		rfcsr |= 0x02;
-+	rt2800_rfcsr_write(rt2x00dev, 2, rfcsr);
-+
-+	rt2800_rfcsr_read(rt2x00dev, 42, &rfcsr);
-+	if (rt2x00dev->default_ant.tx_chain_num == 1)
-+		rfcsr &= (~0x40);
-+	else
-+		rfcsr |= 0x40;
-+	rt2800_rfcsr_write(rt2x00dev, 42, rfcsr);
-+
-+	/* RF for DC Cal BW */
-+	if (conf_is_ht40(conf)) {
-+		rt2800_rfcsr_write_dccal(rt2x00dev, 6, 0x10);
-+		rt2800_rfcsr_write_dccal(rt2x00dev, 7, 0x10);
-+		rt2800_rfcsr_write_dccal(rt2x00dev, 8, 0x04);
-+		rt2800_rfcsr_write_dccal(rt2x00dev, 58, 0x10);
-+		rt2800_rfcsr_write_dccal(rt2x00dev, 59, 0x10);
-+	} else {
-+		rt2800_rfcsr_write_dccal(rt2x00dev, 6, 0x20);
-+		rt2800_rfcsr_write_dccal(rt2x00dev, 7, 0x20);
-+		rt2800_rfcsr_write_dccal(rt2x00dev, 8, 0x00);
-+		rt2800_rfcsr_write_dccal(rt2x00dev, 58, 0x20);
-+		rt2800_rfcsr_write_dccal(rt2x00dev, 59, 0x20);
-+	}
-+
-+	if (conf_is_ht40(conf)) {
-+		rt2800_rfcsr_write_dccal(rt2x00dev, 58, 0x08);
-+		rt2800_rfcsr_write_dccal(rt2x00dev, 59, 0x08);
-+	} else {
-+		rt2800_rfcsr_write_dccal(rt2x00dev, 58, 0x28);
-+		rt2800_rfcsr_write_dccal(rt2x00dev, 59, 0x28);
-+	}
-+
-+	rt2800_rfcsr_read(rt2x00dev, 28, &rfcsr);
-+	if (conf_is_ht40(conf) && (rf->channel == 11))
-+		rfcsr |= 0x4;
-+	else
-+		rfcsr &= (~0x4);
-+	rt2800_rfcsr_write(rt2x00dev, 28, rfcsr);
-+
-+	/*if (bScan == FALSE)*/
-+	if (conf_is_ht40(conf)) {
-+		txrx_agc_fc = rt2x00_get_field8(drv_data->calibration_bw40,
-+						RFCSR24_TX_AGC_FC);
-+	} else {
-+		txrx_agc_fc = rt2x00_get_field8(drv_data->calibration_bw20,
-+						RFCSR24_TX_AGC_FC);		
-+	}
-+	rt2800_rfcsr_read_bank(rt2x00dev, 5, 6, &rfcsr);
-+	rfcsr &= (~0x3F);
-+	rfcsr |= txrx_agc_fc;
-+	rt2800_rfcsr_write_bank(rt2x00dev, 5, 6, rfcsr);
-+	rt2800_rfcsr_read_bank(rt2x00dev, 5, 7, &rfcsr);
-+	rfcsr &= (~0x3F);
-+	rfcsr |= txrx_agc_fc;
-+	rt2800_rfcsr_write_bank(rt2x00dev, 5, 7, rfcsr);
-+	rt2800_rfcsr_read_bank(rt2x00dev, 7, 6, &rfcsr);
-+	rfcsr &= (~0x3F);
-+	rfcsr |= txrx_agc_fc;
-+	rt2800_rfcsr_write_bank(rt2x00dev, 7, 6, rfcsr);
-+	rt2800_rfcsr_read_bank(rt2x00dev, 7, 7, &rfcsr);
-+	rfcsr &= (~0x3F);
-+	rfcsr |= txrx_agc_fc;
-+	rt2800_rfcsr_write_bank(rt2x00dev, 7, 7, rfcsr);
-+
-+	rt2800_rfcsr_read_bank(rt2x00dev, 5, 58, &rfcsr);
-+	rfcsr &= (~0x3F);
-+	rfcsr |= txrx_agc_fc;
-+	rt2800_rfcsr_write_bank(rt2x00dev, 5, 58, rfcsr);
-+	rt2800_rfcsr_read_bank(rt2x00dev, 5, 59, &rfcsr);
-+	rfcsr &= (~0x3F);
-+	rfcsr |= txrx_agc_fc;
-+	rt2800_rfcsr_write_bank(rt2x00dev, 5, 59, rfcsr);
-+	rt2800_rfcsr_read_bank(rt2x00dev, 7, 58, &rfcsr);
-+	rfcsr &= (~0x3F);
-+	rfcsr |= txrx_agc_fc;
-+	rt2800_rfcsr_write_bank(rt2x00dev, 7, 58, rfcsr);
-+	rt2800_rfcsr_read_bank(rt2x00dev, 7, 59, &rfcsr);
-+	rfcsr &= (~0x3F);
-+	rfcsr |= txrx_agc_fc;
-+	rt2800_rfcsr_write_bank(rt2x00dev, 7, 59, rfcsr);
-+
-+	rt2800_register_read(rt2x00dev, TX_ALG_CFG_0, &reg);
-+	reg = reg & (~0x3F3F);
-+	reg |= info->default_power1;
-+	reg |= (info->default_power2 << 8);
-+	reg |= (0x2F << 16);
-+	reg |= (0x2F << 24);
-+
-+	rt2800_eeprom_read(rt2x00dev, EEPROM_NIC_CONF1, &eeprom);
-+	if (rt2x00_get_field16(eeprom, EEPROM_NIC_CONF1_INTERNAL_TX_ALC)) {
-+		/* init base power by e2p target power */
-+		rt2800_eeprom_read(rt2x00dev, 0xD0, &target_power);
-+		target_power &= 0x3F;
-+		reg = reg & (~0x3F3F);
-+		reg |= target_power;
-+		reg |= (target_power << 8);
-+	}
-+	rt2800_register_write(rt2x00dev, TX_ALG_CFG_0, reg);
-+
-+	rt2800_register_read(rt2x00dev, TX_ALG_CFG_1, &reg);
-+	reg = reg & (~0x3F);
-+	rt2800_register_write(rt2x00dev, TX_ALG_CFG_1, reg);
-+
-+	/*if (bScan == FALSE)*/
-+	/* Save MAC SYS CTRL registers */
-+	rt2800_register_read(rt2x00dev, MAC_SYS_CTRL, &mac_sys_ctrl);
-+	/* Disable Tx/Rx */
-+	rt2800_register_write(rt2x00dev, MAC_SYS_CTRL, 0);
-+	/* Check MAC Tx/Rx idle */
-+	for (i = 0; i < 10000; i++) {
-+		rt2800_register_read(rt2x00dev, MAC_STATUS_CFG, &mac_status);
-+		if (mac_status & 0x3)
-+			udelay(50);
-+		else
-+			break;
-+	}
-+
-+	if (i == 10000)
-+		rt2x00_warn(rt2x00dev, "Wait MAC Status to MAX !!!\n");
-+
-+	if (rf->channel > 10) {
-+		rt2800_bbp_read(rt2x00dev, 30, &bbp);
-+		bbp = 0x40;
-+		rt2800_bbp_write(rt2x00dev, 30, bbp);
-+		rt2800_rfcsr_write(rt2x00dev, 39, 0);
-+		rt2800_rfcsr_write(rt2x00dev, 42, 0x7b);
-+	} else {
-+		rt2800_bbp_read(rt2x00dev, 30, &bbp);
-+		bbp = 0x1f;
-+		rt2800_bbp_write(rt2x00dev, 30, bbp);
-+		rt2800_rfcsr_write(rt2x00dev, 39, 0x80);
-+		rt2800_rfcsr_write(rt2x00dev, 42, 0x5b);
-+	}
-+
-+	rt2800_register_write(rt2x00dev, MAC_SYS_CTRL, mac_sys_ctrl);
-+
-+	rt2800_rfcsr_write(rt2x00dev, 5, 0x40);
-+	rt2800_rfcsr_write(rt2x00dev, 4, 0x0C);
-+
-+	/* vcocal_en (initiate VCO calibration (reset after completion)) */
-+	rt2800_rfcsr_read(rt2x00dev, 4, &rfcsr);
-+	rfcsr = ((rfcsr & ~0x80) | 0x80);
-+	rt2800_rfcsr_write(rt2x00dev, 4, rfcsr);
-+	mdelay(2);
-+
-+	rt2800_register_write(rt2x00dev, TX_PIN_CFG, tx_pin);
-+
-+	if (rt2x00dev->default_ant.tx_chain_num == 1) {
-+		rt2800_bbp_write(rt2x00dev, 91, 0x07);
-+		rt2800_bbp_write(rt2x00dev, 95, 0x1A);
-+		rt2800_bbp_write(rt2x00dev, 195, 128);
-+		rt2800_bbp_write(rt2x00dev, 196, 0xA0);
-+		rt2800_bbp_write(rt2x00dev, 195, 170);
-+		rt2800_bbp_write(rt2x00dev, 196, 0x12);
-+		rt2800_bbp_write(rt2x00dev, 195, 171);
-+		rt2800_bbp_write(rt2x00dev, 196, 0x10);		
-+	} else {
-+		rt2800_bbp_write(rt2x00dev, 91, 0x06);
-+		rt2800_bbp_write(rt2x00dev, 95, 0x9A);
-+		rt2800_bbp_write(rt2x00dev, 195, 128);
-+		rt2800_bbp_write(rt2x00dev, 196, 0xE0);
-+		rt2800_bbp_write(rt2x00dev, 195, 170);
-+		rt2800_bbp_write(rt2x00dev, 196, 0x30);
-+		rt2800_bbp_write(rt2x00dev, 195, 171);
-+		rt2800_bbp_write(rt2x00dev, 196, 0x30);
-+	}
-+
-+	/* On 11A, We should delay and wait RF/BBP to be stable*/
-+	/* and the appropriate time should be 1000 micro seconds */
-+	/* 2005/06/05 - On 11G, We also need this delay time.
-+	 * Otherwise it's difficult to pass the WHQL.*/
-+	udelay(1000);
-+}
-+
-+
- static void rt2800_bbp_write_with_rx_chain(struct rt2x00_dev *rt2x00dev,
- 					   const unsigned int word,
- 					   const u8 value)
-@@ -3459,7 +3838,7 @@ static void rt2800_config_channel(struct
- 				  struct channel_info *info)
- {
- 	u32 reg;
--	unsigned int tx_pin;
-+	u32 tx_pin;
- 	u8 bbp, rfcsr;
- 
- 	info->default_power1 = rt2800_txpower_to_dev(rt2x00dev, rf->channel,
-@@ -3513,6 +3892,9 @@ static void rt2800_config_channel(struct
- 	case RF5592:
- 		rt2800_config_channel_rf55xx(rt2x00dev, conf, rf, info);
- 		break;
-+	case RF7620:
-+		rt2800_config_channel_rf7620(rt2x00dev, conf, rf, info);
-+		break;
- 	default:
- 		rt2800_config_channel_rf2xxx(rt2x00dev, conf, rf, info);
- 	}
-@@ -3615,7 +3997,7 @@ static void rt2800_config_channel(struct
- 		else if (rt2x00_rt(rt2x00dev, RT3593) ||
- 			 rt2x00_rt(rt2x00dev, RT3883))
- 			rt2800_bbp_write(rt2x00dev, 82, 0x82);
--		else
-+		else if (rt2x00dev->chip.rf != RF7620)
- 			rt2800_bbp_write(rt2x00dev, 82, 0xf2);
- 
- 		if (rt2x00_rt(rt2x00dev, RT3593) ||
-@@ -3637,7 +4019,7 @@ static void rt2800_config_channel(struct
- 	if (rt2x00_rt(rt2x00dev, RT3572))
- 		rt2800_rfcsr_write(rt2x00dev, 8, 0);
- 
--	tx_pin = 0;
-+	rt2800_register_read(rt2x00dev, TX_PIN_CFG, &tx_pin);
- 
- 	switch (rt2x00dev->default_ant.tx_chain_num) {
- 	case 3:
-@@ -3686,6 +4068,7 @@ static void rt2800_config_channel(struct
- 
- 	rt2x00_set_field32(&tx_pin, TX_PIN_CFG_RFTR_EN, 1);
- 	rt2x00_set_field32(&tx_pin, TX_PIN_CFG_TRSW_EN, 1);
-+	rt2x00_set_field32(&tx_pin, TX_PIN_CFG_RFRX_EN, 1); /* mt7620 */
- 
- 	rt2800_register_write(rt2x00dev, TX_PIN_CFG, tx_pin);
- 
-@@ -4702,6 +5085,14 @@ void rt2800_vco_calibration(struct rt2x0
- 		rt2x00_set_field8(&rfcsr, RFCSR3_VCOCAL_EN, 1);
- 		rt2800_rfcsr_write(rt2x00dev, 3, rfcsr);
- 		break;
-+	case RF7620:
-+		rt2800_rfcsr_read(rt2x00dev, 4, &rfcsr);
-+		/* vcocal_en (initiate VCO calibration (reset after completion))
-+		 * It should be at the end of RF configuration. */
-+		rfcsr = ((rfcsr & ~0x80) | 0x80); 
-+		rt2800_rfcsr_write(rt2x00dev, 4, rfcsr);
-+		mdelay(1);
-+		break;
- 	default:
- 		return;
- 	}
-@@ -5102,9 +5493,42 @@ static int rt2800_init_registers(struct
- 	} else if (rt2x00_rt(rt2x00dev, RT5390) ||
- 		   rt2x00_rt(rt2x00dev, RT5392) ||
- 		   rt2x00_rt(rt2x00dev, RT5592)) {
--		rt2800_register_write(rt2x00dev, TX_SW_CFG0, 0x00000404);
--		rt2800_register_write(rt2x00dev, TX_SW_CFG1, 0x00080606);
--		rt2800_register_write(rt2x00dev, TX_SW_CFG2, 0x00000000);
-+		if (rt2x00dev->chip.rf == RF7620) {
-+			rt2800_register_write(rt2x00dev, TX_SW_CFG0,
-+							0x00000401);
-+			rt2800_register_write(rt2x00dev, TX_SW_CFG1,
-+							0x000C0000);
-+			rt2800_register_write(rt2x00dev, TX_SW_CFG2,
-+							0x00000000);
-+			rt2800_register_write(rt2x00dev, MIMO_PS_CFG,
-+							0x00000002);
-+			rt2800_register_write(rt2x00dev, TX_PIN_CFG,
-+							0x00150F0F);
-+			rt2800_register_write(rt2x00dev, TX_ALC_VGA3,
-+							0x06060606);
-+			rt2800_register_write(rt2x00dev, TX0_BB_GAIN_ATTEN,
-+							0x0);
-+			rt2800_register_write(rt2x00dev, TX1_BB_GAIN_ATTEN,
-+							0x0);
-+			rt2800_register_write(rt2x00dev, TX0_RF_GAIN_ATTEN,
-+							0x6C6C666C);
-+			rt2800_register_write(rt2x00dev, TX1_RF_GAIN_ATTEN,
-+							0x6C6C666C);
-+			rt2800_register_write(rt2x00dev, TX0_RF_GAIN_CORRECT,
-+							0x3630363A);
-+			rt2800_register_write(rt2x00dev, TX1_RF_GAIN_CORRECT,
-+							0x3630363A);
-+			rt2800_register_read(rt2x00dev, TX_ALG_CFG_1, &reg);
-+			reg = reg & (~0x80000000);
-+			rt2800_register_write(rt2x00dev, TX_ALG_CFG_1, reg);
-+		} else {
-+			rt2800_register_write(rt2x00dev, TX_SW_CFG0,
-+							0x00000404);
-+			rt2800_register_write(rt2x00dev, TX_SW_CFG1,
-+							0x00080606);
-+			rt2800_register_write(rt2x00dev, TX_SW_CFG2,
-+							0x00000000);
-+		}
- 	} else if (rt2x00_rt(rt2x00dev, RT5350)) {
- 		rt2800_register_write(rt2x00dev, TX_SW_CFG0, 0x00000404);
- 	} else {
-@@ -6136,6 +6560,225 @@ static void rt2800_init_bbp_5592(struct
- 		rt2800_bbp_write(rt2x00dev, 103, 0xc0);
- }
- 
-+static void rt2800_bbp_glrt_write(struct rt2x00_dev *rt2x00dev,
-+				  const u8 reg, const u8 value)
-+{
-+	rt2800_bbp_write(rt2x00dev, 195, reg);
-+	rt2800_bbp_write(rt2x00dev, 196, value);
-+}
-+
-+static void rt2800_bbp_dcoc_write(struct rt2x00_dev *rt2x00dev,
-+				  const u8 reg, const u8 value)
-+{
-+	rt2800_bbp_write(rt2x00dev, 158, reg);
-+	rt2800_bbp_write(rt2x00dev, 159, value);
-+}
-+
-+static void rt2800_init_bbp_7620(struct rt2x00_dev *rt2x00dev)
-+{
-+	u8 bbp;
-+
-+	/* Apply Maximum Likelihood Detection (MLD) for 2 stream case */
-+	rt2800_bbp_read(rt2x00dev, 105, &bbp);
-+	rt2x00_set_field8(&bbp, BBP105_MLD,
-+			  rt2x00dev->default_ant.rx_chain_num == 2);
-+	rt2800_bbp_write(rt2x00dev, 105, bbp);
-+
-+	/* Avoid data loss and CRC errors */
-+	/* MAC interface control (MAC_IF_80M, 1: 80 MHz) */
-+	rt2800_bbp4_mac_if_ctrl(rt2x00dev);
-+
-+	/* Fix I/Q swap issue */
-+	rt2800_bbp_read(rt2x00dev, 1, &bbp);
-+	bbp |= 0x04;
-+	rt2800_bbp_write(rt2x00dev, 1, bbp);
-+
-+	/* BBP for G band */
-+	rt2800_bbp_write(rt2x00dev, 3, 0x08);
-+	rt2800_bbp_write(rt2x00dev, 4, 0x00); /* rt2800_bbp4_mac_if_ctrl? */
-+	rt2800_bbp_write(rt2x00dev, 6, 0x08);
-+	rt2800_bbp_write(rt2x00dev, 14, 0x09);
-+	rt2800_bbp_write(rt2x00dev, 15, 0xFF);
-+	rt2800_bbp_write(rt2x00dev, 16, 0x01);
-+	rt2800_bbp_write(rt2x00dev, 20, 0x06);
-+	rt2800_bbp_write(rt2x00dev, 21, 0x00);
-+	rt2800_bbp_write(rt2x00dev, 22, 0x00);
-+	rt2800_bbp_write(rt2x00dev, 27, 0x00);
-+	rt2800_bbp_write(rt2x00dev, 28, 0x00);
-+	rt2800_bbp_write(rt2x00dev, 30, 0x00);
-+	rt2800_bbp_write(rt2x00dev, 31, 0x48);
-+	rt2800_bbp_write(rt2x00dev, 47, 0x40);
-+	rt2800_bbp_write(rt2x00dev, 62, 0x00);
-+	rt2800_bbp_write(rt2x00dev, 63, 0x00);
-+	rt2800_bbp_write(rt2x00dev, 64, 0x00);
-+	rt2800_bbp_write(rt2x00dev, 65, 0x2C);
-+	rt2800_bbp_write(rt2x00dev, 66, 0x1C);
-+	rt2800_bbp_write(rt2x00dev, 67, 0x20);
-+	rt2800_bbp_write(rt2x00dev, 68, 0xDD);
-+	rt2800_bbp_write(rt2x00dev, 69, 0x10);
-+	rt2800_bbp_write(rt2x00dev, 70, 0x05);
-+	rt2800_bbp_write(rt2x00dev, 73, 0x18);
-+	rt2800_bbp_write(rt2x00dev, 74, 0x0F);
-+	rt2800_bbp_write(rt2x00dev, 75, 0x60);
-+	rt2800_bbp_write(rt2x00dev, 76, 0x44);
-+	rt2800_bbp_write(rt2x00dev, 77, 0x59);
-+	rt2800_bbp_write(rt2x00dev, 78, 0x1E);
-+	rt2800_bbp_write(rt2x00dev, 79, 0x1C);
-+	rt2800_bbp_write(rt2x00dev, 80, 0x0C);
-+	rt2800_bbp_write(rt2x00dev, 81, 0x3A);
-+	rt2800_bbp_write(rt2x00dev, 82, 0xB6);
-+	rt2800_bbp_write(rt2x00dev, 83, 0x9A);
-+	rt2800_bbp_write(rt2x00dev, 84, 0x9A);
-+	rt2800_bbp_write(rt2x00dev, 86, 0x38);
-+	rt2800_bbp_write(rt2x00dev, 88, 0x90);
-+	rt2800_bbp_write(rt2x00dev, 91, 0x04);
-+	rt2800_bbp_write(rt2x00dev, 92, 0x02);
-+	rt2800_bbp_write(rt2x00dev, 95, 0x9A);
-+	rt2800_bbp_write(rt2x00dev, 96, 0x00);
-+	rt2800_bbp_write(rt2x00dev, 103, 0xC0);
-+	rt2800_bbp_write(rt2x00dev, 104, 0x92);
-+	/* FIXME BBP105 owerwrite */
-+	rt2800_bbp_write(rt2x00dev, 105, 0x3C);
-+	rt2800_bbp_write(rt2x00dev, 106, 0x12);
-+	rt2800_bbp_write(rt2x00dev, 109, 0x00);
-+	rt2800_bbp_write(rt2x00dev, 134, 0x10);
-+	rt2800_bbp_write(rt2x00dev, 135, 0xA6);
-+	rt2800_bbp_write(rt2x00dev, 137, 0x04);
-+	rt2800_bbp_write(rt2x00dev, 142, 0x30);
-+	rt2800_bbp_write(rt2x00dev, 143, 0xF7);
-+	rt2800_bbp_write(rt2x00dev, 160, 0xEC);
-+	rt2800_bbp_write(rt2x00dev, 161, 0xC4);
-+	rt2800_bbp_write(rt2x00dev, 162, 0x77);
-+	rt2800_bbp_write(rt2x00dev, 163, 0xF9);
-+	rt2800_bbp_write(rt2x00dev, 164, 0x00);
-+	rt2800_bbp_write(rt2x00dev, 165, 0x00);
-+	rt2800_bbp_write(rt2x00dev, 186, 0x00);
-+	rt2800_bbp_write(rt2x00dev, 187, 0x00);
-+	rt2800_bbp_write(rt2x00dev, 188, 0x00);
-+	rt2800_bbp_write(rt2x00dev, 186, 0x00);
-+	rt2800_bbp_write(rt2x00dev, 187, 0x01);
-+	rt2800_bbp_write(rt2x00dev, 188, 0x00);
-+	rt2800_bbp_write(rt2x00dev, 189, 0x00);
-+
-+	rt2800_bbp_write(rt2x00dev, 91, 0x06);
-+	rt2800_bbp_write(rt2x00dev, 92, 0x04);
-+	rt2800_bbp_write(rt2x00dev, 93, 0x54);
-+	rt2800_bbp_write(rt2x00dev, 99, 0x50);
-+	rt2800_bbp_write(rt2x00dev, 148, 0x84);
-+	rt2800_bbp_write(rt2x00dev, 167, 0x80);
-+	rt2800_bbp_write(rt2x00dev, 178, 0xFF);
-+	rt2800_bbp_write(rt2x00dev, 106, 0x13);
-+
-+	/* BBP for G band GLRT function (BBP_128 ~ BBP_221) */
-+	rt2800_bbp_glrt_write(rt2x00dev, 0, 0x00);
-+	rt2800_bbp_glrt_write(rt2x00dev, 1, 0x14); /* ? see above */
-+	rt2800_bbp_glrt_write(rt2x00dev, 2, 0x20);
-+	rt2800_bbp_glrt_write(rt2x00dev, 3, 0x0A);
-+	rt2800_bbp_glrt_write(rt2x00dev, 10, 0x16);
-+	rt2800_bbp_glrt_write(rt2x00dev, 11, 0x06);
-+	rt2800_bbp_glrt_write(rt2x00dev, 12, 0x02);
-+	rt2800_bbp_glrt_write(rt2x00dev, 13, 0x07);
-+	rt2800_bbp_glrt_write(rt2x00dev, 14, 0x05);
-+	rt2800_bbp_glrt_write(rt2x00dev, 15, 0x09);
-+	rt2800_bbp_glrt_write(rt2x00dev, 16, 0x20);
-+	rt2800_bbp_glrt_write(rt2x00dev, 17, 0x08);
-+	rt2800_bbp_glrt_write(rt2x00dev, 18, 0x4A);
-+	rt2800_bbp_glrt_write(rt2x00dev, 19, 0x00);
-+	rt2800_bbp_glrt_write(rt2x00dev, 20, 0x00);
-+	rt2800_bbp_glrt_write(rt2x00dev, 128, 0xE0);
-+	rt2800_bbp_glrt_write(rt2x00dev, 129, 0x1F);
-+	rt2800_bbp_glrt_write(rt2x00dev, 130, 0x4F);
-+	rt2800_bbp_glrt_write(rt2x00dev, 131, 0x32);
-+	rt2800_bbp_glrt_write(rt2x00dev, 132, 0x08);
-+	rt2800_bbp_glrt_write(rt2x00dev, 133, 0x28);
-+	rt2800_bbp_glrt_write(rt2x00dev, 134, 0x19);
-+	rt2800_bbp_glrt_write(rt2x00dev, 135, 0x0A);
-+	rt2800_bbp_glrt_write(rt2x00dev, 138, 0x16);
-+	rt2800_bbp_glrt_write(rt2x00dev, 139, 0x10);
-+	rt2800_bbp_glrt_write(rt2x00dev, 140, 0x10);
-+	rt2800_bbp_glrt_write(rt2x00dev, 141, 0x1A);
-+	rt2800_bbp_glrt_write(rt2x00dev, 142, 0x36);
-+	rt2800_bbp_glrt_write(rt2x00dev, 143, 0x2C);
-+	rt2800_bbp_glrt_write(rt2x00dev, 144, 0x26);
-+	rt2800_bbp_glrt_write(rt2x00dev, 145, 0x24);
-+	rt2800_bbp_glrt_write(rt2x00dev, 146, 0x42);
-+	rt2800_bbp_glrt_write(rt2x00dev, 147, 0x40);
-+	rt2800_bbp_glrt_write(rt2x00dev, 148, 0x30);
-+	rt2800_bbp_glrt_write(rt2x00dev, 149, 0x29);
-+	rt2800_bbp_glrt_write(rt2x00dev, 150, 0x4C);
-+	rt2800_bbp_glrt_write(rt2x00dev, 151, 0x46);
-+	rt2800_bbp_glrt_write(rt2x00dev, 152, 0x3D);
-+	rt2800_bbp_glrt_write(rt2x00dev, 153, 0x40);
-+	rt2800_bbp_glrt_write(rt2x00dev, 154, 0x3E);
-+	rt2800_bbp_glrt_write(rt2x00dev, 155, 0x38);
-+	rt2800_bbp_glrt_write(rt2x00dev, 156, 0x3D);
-+	rt2800_bbp_glrt_write(rt2x00dev, 157, 0x2F);
-+	rt2800_bbp_glrt_write(rt2x00dev, 158, 0x3C);
-+	rt2800_bbp_glrt_write(rt2x00dev, 159, 0x34);
-+	rt2800_bbp_glrt_write(rt2x00dev, 160, 0x2C);
-+	rt2800_bbp_glrt_write(rt2x00dev, 161, 0x2F);
-+	rt2800_bbp_glrt_write(rt2x00dev, 162, 0x3C);
-+	rt2800_bbp_glrt_write(rt2x00dev, 163, 0x35);
-+	rt2800_bbp_glrt_write(rt2x00dev, 164, 0x2E);
-+	rt2800_bbp_glrt_write(rt2x00dev, 165, 0x2F);
-+	rt2800_bbp_glrt_write(rt2x00dev, 166, 0x49);
-+	rt2800_bbp_glrt_write(rt2x00dev, 167, 0x41);
-+	rt2800_bbp_glrt_write(rt2x00dev, 168, 0x36);
-+	rt2800_bbp_glrt_write(rt2x00dev, 169, 0x39);
-+	rt2800_bbp_glrt_write(rt2x00dev, 170, 0x30);
-+	rt2800_bbp_glrt_write(rt2x00dev, 171, 0x30);
-+	rt2800_bbp_glrt_write(rt2x00dev, 172, 0x0E);
-+	rt2800_bbp_glrt_write(rt2x00dev, 173, 0x0D);
-+	rt2800_bbp_glrt_write(rt2x00dev, 174, 0x28);
-+	rt2800_bbp_glrt_write(rt2x00dev, 175, 0x21);
-+	rt2800_bbp_glrt_write(rt2x00dev, 176, 0x1C);
-+	rt2800_bbp_glrt_write(rt2x00dev, 177, 0x16);
-+	rt2800_bbp_glrt_write(rt2x00dev, 178, 0x50);
-+	rt2800_bbp_glrt_write(rt2x00dev, 179, 0x4A);
-+	rt2800_bbp_glrt_write(rt2x00dev, 180, 0x43);
-+	rt2800_bbp_glrt_write(rt2x00dev, 181, 0x50);
-+	rt2800_bbp_glrt_write(rt2x00dev, 182, 0x10);
-+	rt2800_bbp_glrt_write(rt2x00dev, 183, 0x10);
-+	rt2800_bbp_glrt_write(rt2x00dev, 184, 0x10);
-+	rt2800_bbp_glrt_write(rt2x00dev, 185, 0x10);
-+	rt2800_bbp_glrt_write(rt2x00dev, 200, 0x7D);
-+	rt2800_bbp_glrt_write(rt2x00dev, 201, 0x14);
-+	rt2800_bbp_glrt_write(rt2x00dev, 202, 0x32);
-+	rt2800_bbp_glrt_write(rt2x00dev, 203, 0x2C);
-+	rt2800_bbp_glrt_write(rt2x00dev, 204, 0x36);
-+	rt2800_bbp_glrt_write(rt2x00dev, 205, 0x4C);
-+	rt2800_bbp_glrt_write(rt2x00dev, 206, 0x43);
-+	rt2800_bbp_glrt_write(rt2x00dev, 207, 0x2C);
-+	rt2800_bbp_glrt_write(rt2x00dev, 208, 0x2E);
-+	rt2800_bbp_glrt_write(rt2x00dev, 209, 0x36);
-+	rt2800_bbp_glrt_write(rt2x00dev, 210, 0x30);
-+	rt2800_bbp_glrt_write(rt2x00dev, 211, 0x6E);
-+
-+	/* BBP for G band DCOC function */
-+	rt2800_bbp_dcoc_write(rt2x00dev, 140, 0x0C);
-+	rt2800_bbp_dcoc_write(rt2x00dev, 141, 0x00);
-+	rt2800_bbp_dcoc_write(rt2x00dev, 142, 0x10);
-+	rt2800_bbp_dcoc_write(rt2x00dev, 143, 0x10);
-+	rt2800_bbp_dcoc_write(rt2x00dev, 144, 0x10);
-+	rt2800_bbp_dcoc_write(rt2x00dev, 145, 0x10);
-+	rt2800_bbp_dcoc_write(rt2x00dev, 146, 0x08);
-+	rt2800_bbp_dcoc_write(rt2x00dev, 147, 0x40);
-+	rt2800_bbp_dcoc_write(rt2x00dev, 148, 0x04);
-+	rt2800_bbp_dcoc_write(rt2x00dev, 149, 0x04);
-+	rt2800_bbp_dcoc_write(rt2x00dev, 150, 0x08);
-+	rt2800_bbp_dcoc_write(rt2x00dev, 151, 0x08);
-+	rt2800_bbp_dcoc_write(rt2x00dev, 152, 0x03);
-+	rt2800_bbp_dcoc_write(rt2x00dev, 153, 0x03);
-+	rt2800_bbp_dcoc_write(rt2x00dev, 154, 0x03);
-+	rt2800_bbp_dcoc_write(rt2x00dev, 155, 0x02);
-+	rt2800_bbp_dcoc_write(rt2x00dev, 156, 0x40);
-+	rt2800_bbp_dcoc_write(rt2x00dev, 157, 0x40);
-+	rt2800_bbp_dcoc_write(rt2x00dev, 158, 0x64);
-+	rt2800_bbp_dcoc_write(rt2x00dev, 159, 0x64);
-+
-+	rt2800_bbp4_mac_if_ctrl(rt2x00dev);
-+}
-+
- static void rt2800_init_bbp(struct rt2x00_dev *rt2x00dev)
- {
- 	unsigned int i;
-@@ -6178,7 +6821,10 @@ static void rt2800_init_bbp(struct rt2x0
- 		return;
- 	case RT5390:
- 	case RT5392:
--		rt2800_init_bbp_53xx(rt2x00dev);
-+		if (rt2x00dev->chip.rf == RF7620)
-+			rt2800_init_bbp_7620(rt2x00dev);
-+		else
-+			rt2800_init_bbp_53xx(rt2x00dev);
- 		break;
- 	case RT5592:
- 		rt2800_init_bbp_5592(rt2x00dev);
-@@ -7392,6 +8038,296 @@ static void rt2800_init_rfcsr_5592(struc
- 	rt2800_led_open_drain_enable(rt2x00dev);
- }
- 
-+static void rt2800_init_rfcsr_7620(struct rt2x00_dev *rt2x00dev)
-+{
-+	u16 freq;
-+	u8 rfvalue;
-+	struct hw_mode_spec *spec = &rt2x00dev->spec;
-+
-+	/* Initialize RF central register to default value */
-+	rt2800_rfcsr_write(rt2x00dev, 0, 0x02);
-+	rt2800_rfcsr_write(rt2x00dev, 1, 0x03);
-+	rt2800_rfcsr_write(rt2x00dev, 2, 0x33);
-+	rt2800_rfcsr_write(rt2x00dev, 3, 0xFF);
-+	rt2800_rfcsr_write(rt2x00dev, 4, 0x0C);
-+	rt2800_rfcsr_write(rt2x00dev, 5, 0x40); /* Read only */
-+	rt2800_rfcsr_write(rt2x00dev, 6, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 7, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 8, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 9, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 10, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 11, 0x00);
-+	/* rt2800_rfcsr_write(rt2x00dev, 12, 0x43); *//* EEPROM */
-+	rt2800_rfcsr_write(rt2x00dev, 13, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 14, 0x40);
-+	rt2800_rfcsr_write(rt2x00dev, 15, 0x22);
-+	rt2800_rfcsr_write(rt2x00dev, 16, 0x4C);
-+	rt2800_rfcsr_write(rt2x00dev, 17, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 18, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 19, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 20, 0xA0);
-+	rt2800_rfcsr_write(rt2x00dev, 21, 0x12);
-+	rt2800_rfcsr_write(rt2x00dev, 22, 0x07);
-+	rt2800_rfcsr_write(rt2x00dev, 23, 0x13);
-+	rt2800_rfcsr_write(rt2x00dev, 24, 0xFE);
-+	rt2800_rfcsr_write(rt2x00dev, 25, 0x24);
-+	rt2800_rfcsr_write(rt2x00dev, 26, 0x7A);
-+	rt2800_rfcsr_write(rt2x00dev, 27, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 28, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 29, 0x05);
-+	rt2800_rfcsr_write(rt2x00dev, 30, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 31, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 32, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 33, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 34, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 35, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 36, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 37, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 38, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 39, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 40, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 41, 0xD0);
-+	rt2800_rfcsr_write(rt2x00dev, 42, 0x5B);
-+	rt2800_rfcsr_write(rt2x00dev, 43, 0x00);
-+
-+	rt2800_rfcsr_write(rt2x00dev, 11, 0x21);
-+	if (spec->clk_is_20mhz)
-+		rt2800_rfcsr_write(rt2x00dev, 13, 0x03);
-+	else
-+		rt2800_rfcsr_write(rt2x00dev, 13, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 14, 0x7C);
-+	rt2800_rfcsr_write(rt2x00dev, 16, 0x80);
-+	rt2800_rfcsr_write(rt2x00dev, 17, 0x99);
-+	rt2800_rfcsr_write(rt2x00dev, 18, 0x99);
-+	rt2800_rfcsr_write(rt2x00dev, 19, 0x09);
-+	rt2800_rfcsr_write(rt2x00dev, 20, 0x50);
-+	rt2800_rfcsr_write(rt2x00dev, 21, 0xB0);
-+	rt2800_rfcsr_write(rt2x00dev, 22, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 23, 0x06);
-+	rt2800_rfcsr_write(rt2x00dev, 24, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 25, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 26, 0x5D);
-+	rt2800_rfcsr_write(rt2x00dev, 27, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 28, 0x61);
-+	rt2800_rfcsr_write(rt2x00dev, 29, 0xB5);
-+	rt2800_rfcsr_write(rt2x00dev, 43, 0x02);
-+
-+	rt2800_rfcsr_write(rt2x00dev, 28, 0x62);
-+	rt2800_rfcsr_write(rt2x00dev, 29, 0xAD);
-+	rt2800_rfcsr_write(rt2x00dev, 39, 0x80);
-+	/* RTMP_TEMPERATURE_CALIBRATION */
-+	/* rt2800_rfcsr_write(rt2x00dev, 34, 0x23); */
-+	/* rt2800_rfcsr_write(rt2x00dev, 35, 0x01); */
-+
-+	/* use rt2800_adjust_freq_offset ? */
-+	rt2800_eeprom_read(rt2x00dev, EEPROM_FREQ, &freq);
-+	rfvalue = freq & 0xff;
-+	rt2800_rfcsr_write(rt2x00dev, 12, rfvalue);
-+
-+	/* Initialize RF channel register to default value */
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 0, 0x03);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 1, 0x00);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 2, 0x00);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 3, 0x00);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 4, 0x00);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 5, 0x08);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 6, 0x00);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 7, 0x51);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 8, 0x53);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 9, 0x16);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 10, 0x61);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 11, 0x53);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 12, 0x22);
-+	/* rt2800_rfcsr_write_chanreg(rt2x00dev, 13, 0x3D); */ /* fails */
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x06);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 15, 0x13);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 16, 0x22);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 17, 0x27);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 18, 0x02);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 19, 0xA7);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 20, 0x01);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 21, 0x52);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 22, 0x80);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 23, 0xB3);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 24, 0x00);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 25, 0x00);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 26, 0x00);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 27, 0x00);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 28, 0x5C);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 29, 0x6B);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 30, 0x6B);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 31, 0x31);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 32, 0x5D);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 33, 0x00);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 34, 0xE6);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 35, 0x55);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 36, 0x00);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 37, 0xBB);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 38, 0xB3);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 39, 0xB3);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 40, 0x03);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 41, 0x00);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 42, 0x00);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 43, 0xB3);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 44, 0xD3);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 45, 0xD5);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 46, 0x07);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 47, 0x68);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 48, 0xEF);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 49, 0x1C);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 54, 0x07);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 55, 0xA8);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 56, 0x85);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 57, 0x10);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 58, 0x07);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 59, 0x6A);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 60, 0x85);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 61, 0x10);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 62, 0x1C);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 63, 0x00);
-+
-+ 	rt2800_rfcsr_write_bank(rt2x00dev, 6, 45, 0xC5);
-+
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 9, 0x47);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 10, 0x71);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 11, 0x33);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x0E);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 17, 0x23);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 19, 0xA4);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 20, 0x02);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 21, 0x12);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 28, 0x1C);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 29, 0xEB);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 32, 0x7D);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 34, 0xD6);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 36, 0x08);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 38, 0xB4);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 43, 0xD3);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 44, 0xB3);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 45, 0xD5);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 46, 0x27);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 47, 0x69);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 48, 0xFF);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 54, 0x20);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 55, 0x66);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 56, 0xFF);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 57, 0x1C);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 58, 0x20);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 59, 0x6B);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 60, 0xF7);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 61, 0x09);
-+
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 10, 0x51);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x06);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 19, 0xA7);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 28, 0x2C);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 55, 0x64);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 8, 0x51);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 9, 0x36);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 11, 0x53);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x16);
-+
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 47, 0x6C);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 48, 0xFC);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 49, 0x1F);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 54, 0x27);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 55, 0x66);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 59, 0x6B);
-+
-+	/* Initialize RF channel register for DRQFN */
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 43, 0xD3);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 44, 0xE3);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 45, 0xE5);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 47, 0x28);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 55, 0x68);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 56, 0xF7);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 58, 0x02);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 60, 0xC7);
-+
-+	/* reduce power consumption */
-+/*	rt2800_rfcsr_write_chanreg(rt2x00dev, 43, 0x53);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 44, 0x53);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 45, 0x53);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 47, 0x64);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 48, 0x4F);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 49, 0x02);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 55, 0x64);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 56, 0x4F);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 57, 0x02);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 58, 0x27);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 59, 0x64);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 60, 0x4F);
-+	rt2800_rfcsr_write_chanreg(rt2x00dev, 61, 0x02);
-+*/
-+	/* Initialize RF DC calibration register to default value */
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 0, 0x47);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 1, 0x00);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 2, 0x00);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 3, 0x00);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 4, 0x00);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 5, 0x00);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 6, 0x10);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 7, 0x10);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 8, 0x04);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 9, 0x00);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 10, 0x07);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 11, 0x01);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 12, 0x07);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 13, 0x07);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 14, 0x07);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 15, 0x20);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 16, 0x22);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 17, 0x00);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 18, 0x00);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 19, 0x00);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 20, 0x00);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 21, 0xF1);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 22, 0x11);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 23, 0x02);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 24, 0x41);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 25, 0x20);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 26, 0x00);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 27, 0xD7);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 28, 0xA2);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 29, 0x20);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 30, 0x49);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 31, 0x20);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 32, 0x04);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 33, 0xF1);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 34, 0xA1);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 35, 0x01);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 41, 0x00);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 42, 0x00);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 43, 0x00);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 44, 0x00);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 45, 0x00);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 46, 0x00);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 47, 0x3E);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 48, 0x3D);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 49, 0x3E);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 50, 0x3D);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 51, 0x3E);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 52, 0x3D);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 53, 0x00);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 54, 0x00);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 55, 0x00);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 56, 0x00);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 57, 0x00);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 58, 0x10);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 59, 0x10);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 60, 0x0A);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 61, 0x00);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 62, 0x00);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 63, 0x00);
-+
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 3, 0x08);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 4, 0x04);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 5, 0x20);
-+
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 5, 0x00);
-+	rt2800_rfcsr_write_dccal(rt2x00dev, 17, 0x7C);
-+}
-+
- static void rt2800_init_rfcsr(struct rt2x00_dev *rt2x00dev)
- {
- 	if (rt2800_is_305x_soc(rt2x00dev)) {
-@@ -7427,7 +8363,10 @@ static void rt2800_init_rfcsr(struct rt2
- 		rt2800_init_rfcsr_5350(rt2x00dev);
- 		break;
- 	case RT5390:
--		rt2800_init_rfcsr_5390(rt2x00dev);
-+		if (rt2x00dev->chip.rf == RF7620)
-+			rt2800_init_rfcsr_7620(rt2x00dev);
-+		else
-+			rt2800_init_rfcsr_5390(rt2x00dev);
- 		break;
- 	case RT5392:
- 		rt2800_init_rfcsr_5392(rt2x00dev);
-@@ -7859,6 +8798,7 @@ static int rt2800_init_eeprom(struct rt2
- 	case RF5390:
- 	case RF5392:
- 	case RF5592:
-+	case RF7620:
- 		break;
- 	default:
- 		rt2x00_err(rt2x00dev, "Invalid RF chipset 0x%04x detected\n",
-@@ -8427,6 +9367,7 @@ static int rt2800_probe_hw_mode(struct r
- 	case RF5372:
- 	case RF5390:
- 	case RF5392:
-+	case RF7620:
- 		spec->num_channels = 14;
- 		if (spec->clk_is_20mhz)
- 			spec->channels = rf_vals_xtal20mhz_3x;
-@@ -8567,6 +9508,7 @@ static int rt2800_probe_hw_mode(struct r
- 	case RF5372:
- 	case RF5390:
- 	case RF5392:
-+	case RF7620:
- 		__set_bit(CAPABILITY_VCO_RECALIBRATION, &rt2x00dev->cap_flags);
- 		break;
- 	}
diff --git a/package/kernel/mac80211/patches/921-ath10k_init_devices_synchronously.patch b/package/kernel/mac80211/patches/921-ath10k_init_devices_synchronously.patch
deleted file mode 100644
index 6a904ec..0000000
--- a/package/kernel/mac80211/patches/921-ath10k_init_devices_synchronously.patch
+++ /dev/null
@@ -1,33 +0,0 @@
-From: Sven Eckelmann <sven@open-mesh.com>
-Date: Tue, 18 Nov 2014 12:29:28 +0100
-Subject: [PATCH] ath10k: Don't initialize devices asynchronously
-
-OpenWrt requires all PHYs to be initialized to create the configuration files
-during bootup. ath10k violates this because it delays the creation of the PHY
-to a not well defined point in the future.
-
-Forcing the work to be done immediately works around this problem but may also
-delay the boot when firmware images cannot be found.
-
-Signed-off-by: Sven Eckelmann <sven@open-mesh.com>
----
-
---- a/drivers/net/wireless/ath/ath10k/core.c
-+++ b/drivers/net/wireless/ath/ath10k/core.c
-@@ -2009,6 +2009,16 @@ int ath10k_core_register(struct ath10k *
- 	ar->chip_id = chip_id;
- 	queue_work(ar->workqueue, &ar->register_work);
- 
-+	/* OpenWrt requires all PHYs to be initialized to create the
-+	 * configuration files during bootup. ath10k violates this
-+	 * because it delays the creation of the PHY to a not well defined
-+	 * point in the future.
-+	 *
-+	 * Forcing the work to be done immediately works around this problem
-+	 * but may also delay the boot when firmware images cannot be found.
-+	 */
-+	flush_workqueue(ar->workqueue);
-+
- 	return 0;
- }
- EXPORT_SYMBOL(ath10k_core_register);
diff --git a/package/kernel/mac80211/patches/930-ath10k_add_tpt_led_trigger.patch b/package/kernel/mac80211/patches/930-ath10k_add_tpt_led_trigger.patch
deleted file mode 100644
index 60b5b1b..0000000
--- a/package/kernel/mac80211/patches/930-ath10k_add_tpt_led_trigger.patch
+++ /dev/null
@@ -1,37 +0,0 @@
---- a/drivers/net/wireless/ath/ath10k/mac.c
-+++ b/drivers/net/wireless/ath/ath10k/mac.c
-@@ -7662,6 +7662,21 @@ struct ath10k_vif *ath10k_get_arvif(stru
- 	return arvif_iter.arvif;
- }
- 
-+#ifdef CPTCFG_MAC80211_LEDS
-+static const struct ieee80211_tpt_blink ath10k_tpt_blink[] = {
-+	{ .throughput = 0 * 1024, .blink_time = 334 },
-+	{ .throughput = 1 * 1024, .blink_time = 260 },
-+	{ .throughput = 2 * 1024, .blink_time = 220 },
-+	{ .throughput = 5 * 1024, .blink_time = 190 },
-+	{ .throughput = 10 * 1024, .blink_time = 170 },
-+	{ .throughput = 25 * 1024, .blink_time = 150 },
-+	{ .throughput = 54 * 1024, .blink_time = 130 },
-+	{ .throughput = 120 * 1024, .blink_time = 110 },
-+	{ .throughput = 265 * 1024, .blink_time = 80 },
-+	{ .throughput = 586 * 1024, .blink_time = 50 },
-+};
-+#endif
-+
- int ath10k_mac_register(struct ath10k *ar)
- {
- 	static const u32 cipher_suites[] = {
-@@ -7880,6 +7895,12 @@ int ath10k_mac_register(struct ath10k *a
- 	ar->hw->wiphy->cipher_suites = cipher_suites;
- 	ar->hw->wiphy->n_cipher_suites = ARRAY_SIZE(cipher_suites);
- 
-+#if CPTCFG_MAC80211_LEDS
-+	ieee80211_create_tpt_led_trigger(ar->hw,
-+		IEEE80211_TPT_LEDTRIG_FL_RADIO, ath10k_tpt_blink,
-+		ARRAY_SIZE(ath10k_tpt_blink));
-+#endif
-+
- 	ret = ieee80211_register_hw(ar->hw);
- 	if (ret) {
- 		ath10k_err(ar, "failed to register ieee80211: %d\n", ret);
diff --git a/package/kernel/mac80211/patches/936-ath10k_skip_otp_check.patch b/package/kernel/mac80211/patches/936-ath10k_skip_otp_check.patch
deleted file mode 100644
index 39aba41..0000000
--- a/package/kernel/mac80211/patches/936-ath10k_skip_otp_check.patch
+++ /dev/null
@@ -1,42 +0,0 @@
---- a/drivers/net/wireless/ath/ath10k/core.c
-+++ b/drivers/net/wireless/ath/ath10k/core.c
-@@ -1165,9 +1165,6 @@ static int ath10k_core_fetch_firmware_fi
- {
- 	int ret;
- 
--	/* calibration file is optional, don't check for any errors */
--	ath10k_fetch_cal_file(ar);
--
- 	ar->fw_api = 5;
- 	ath10k_dbg(ar, ATH10K_DBG_BOOT, "trying fw api %d\n", ar->fw_api);
- 
-@@ -1870,6 +1867,9 @@ static int ath10k_core_probe_fw(struct a
- 		goto err_power_down;
- 	}
- 
-+	/* calibration file is optional, don't check for any errors */
-+	int calret = ath10k_fetch_cal_file(ar);
-+
- 	ret = ath10k_core_fetch_firmware_files(ar);
- 	if (ret) {
- 		ath10k_err(ar, "could not fetch firmware files (%d)\n", ret);
-@@ -1892,11 +1892,14 @@ static int ath10k_core_probe_fw(struct a
- 			   "could not load pre cal data: %d\n", ret);
- 	}
- 
--	ret = ath10k_core_get_board_id_from_otp(ar);
--	if (ret && ret != -EOPNOTSUPP) {
--		ath10k_err(ar, "failed to get board id from otp: %d\n",
--			   ret);
--		goto err_free_firmware_files;
-+	/* otp and board file not needed if calibration data is present */
-+	if (calret) {
-+		ret = ath10k_core_get_board_id_from_otp(ar);
-+		if (ret && ret != -EOPNOTSUPP) {
-+			ath10k_err(ar, "failed to get board id from otp: %d\n",
-+				ret);
-+			return ret;
-+		}
- 	}
- 
- 	ret = ath10k_core_fetch_board_file(ar);
diff --git a/package/kernel/mac80211/patches/940-mwl8k_init_devices_synchronously.patch b/package/kernel/mac80211/patches/940-mwl8k_init_devices_synchronously.patch
deleted file mode 100644
index 357faee..0000000
--- a/package/kernel/mac80211/patches/940-mwl8k_init_devices_synchronously.patch
+++ /dev/null
@@ -1,20 +0,0 @@
---- a/drivers/net/wireless/marvell/mwl8k.c
-+++ b/drivers/net/wireless/marvell/mwl8k.c
-@@ -6264,6 +6264,8 @@ static int mwl8k_probe(struct pci_dev *p
- 
- 	priv->running_bsses = 0;
- 
-+	wait_for_completion(&priv->firmware_loading_complete);
-+
- 	return rc;
- 
- err_stop_firmware:
-@@ -6297,8 +6299,6 @@ static void mwl8k_remove(struct pci_dev
- 		return;
- 	priv = hw->priv;
- 
--	wait_for_completion(&priv->firmware_loading_complete);
--
- 	if (priv->fw_state == FW_STATE_ERROR) {
- 		mwl8k_hw_reset(priv);
- 		goto unmap;
diff --git a/package/kernel/mac80211/patches/950-1-4-ath10k-Move-rx_location_info-out-of-struct-rx_pkt_end.patch b/package/kernel/mac80211/patches/950-1-4-ath10k-Move-rx_location_info-out-of-struct-rx_pkt_end.patch
deleted file mode 100644
index 8d74fd7..0000000
--- a/package/kernel/mac80211/patches/950-1-4-ath10k-Move-rx_location_info-out-of-struct-rx_pkt_end.patch
+++ /dev/null
@@ -1,37 +0,0 @@
-From 8f09588b2cdc2dfb6e6076fd10708791d6c6bedd Mon Sep 17 00:00:00 2001
-From: Vasanthakumar Thiagarajan <vthiagar@qti.qualcomm.com>
-Date: Mon, 23 May 2016 23:12:43 +0300
-Subject: ath10k: move rx_location_info out of struct rx_pkt_end
-
-Define rx_location_info in struct rx_ppdu_end_qca99x0 after
-rx_pkt_end. This is to prepare rx_ppdu_end for QCA9984 chip.
-
-Signed-off-by: Vasanthakumar Thiagarajan <vthiagar@qti.qualcomm.com>
-Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>
----
- drivers/net/wireless/ath/ath10k/rx_desc.h | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
-diff --git a/drivers/net/wireless/ath/ath10k/rx_desc.h b/drivers/net/wireless/ath/ath10k/rx_desc.h
-index ca8d168..3e7dfaa 100644
---- a/drivers/net/wireless/ath/ath10k/rx_desc.h
-+++ b/drivers/net/wireless/ath/ath10k/rx_desc.h
-@@ -994,7 +994,6 @@ struct rx_pkt_end {
- 	__le32 info0; /* %RX_PKT_END_INFO0_ */
- 	__le32 phy_timestamp_1;
- 	__le32 phy_timestamp_2;
--	__le32 rx_location_info; /* %RX_LOCATION_INFO_ */
- } __packed;
- 
- enum rx_phy_ppdu_end_info0 {
-@@ -1067,6 +1066,7 @@ struct rx_phy_ppdu_end {
- 
- struct rx_ppdu_end_qca99x0 {
- 	struct rx_pkt_end rx_pkt_end;
-+	__le32 rx_location_info; /* %RX_LOCATION_INFO_ */
- 	struct rx_phy_ppdu_end rx_phy_ppdu_end;
- 	__le32 rx_timing_offset; /* %RX_PPDU_END_RX_TIMING_OFFSET_ */
- 	__le32 rx_info; /* %RX_PPDU_END_RX_INFO_ */
--- 
-cgit v0.12
-
diff --git a/package/kernel/mac80211/patches/950-2-4-ath10k-Clean-up-growing-hw-checks-during-safe-and-full-reset.patch b/package/kernel/mac80211/patches/950-2-4-ath10k-Clean-up-growing-hw-checks-during-safe-and-full-reset.patch
deleted file mode 100644
index cddbe12..0000000
--- a/package/kernel/mac80211/patches/950-2-4-ath10k-Clean-up-growing-hw-checks-during-safe-and-full-reset.patch
+++ /dev/null
@@ -1,139 +0,0 @@
-From 0fc7e270523bf3757687e930c02bb46e3dcedde9 Mon Sep 17 00:00:00 2001
-From: Vasanthakumar Thiagarajan <vthiagar@qti.qualcomm.com>
-Date: Mon, 23 May 2016 23:12:43 +0300
-Subject: ath10k: clean up growing hw checks during safe and full reset
-
-Store pci chip secific reset funtions in struct ath10k_pci
-as callbacks during early ath10k_pci_probe() and use the
-callback to perform chip specific resets. This patch essentially
-adds two callback in ath10k_pci, one for doing soft reset and
-the other for hard reset. By using callbacks we can get rid of
-those hw revision checks in ath10k_pci_safe_chip_reset() and
-ath10k_pci_chip_reset(). As such this patch does not fix
-any issue.
-
-Signed-off-by: Vasanthakumar Thiagarajan <vthiagar@qti.qualcomm.com>
-Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>
----
- drivers/net/wireless/ath/ath10k/pci.c | 44 ++++++++++++++++++++++-------------
- drivers/net/wireless/ath/ath10k/pci.h |  6 +++++
- 2 files changed, 34 insertions(+), 16 deletions(-)
-
-diff --git a/drivers/net/wireless/ath/ath10k/pci.c b/drivers/net/wireless/ath/ath10k/pci.c
-index 8133d7b..81d6bad 100644
---- a/drivers/net/wireless/ath/ath10k/pci.c
-+++ b/drivers/net/wireless/ath/ath10k/pci.c
-@@ -2293,16 +2293,20 @@ static int ath10k_pci_warm_reset(struct ath10k *ar)
- 	return 0;
- }
- 
-+static int ath10k_pci_qca99x0_soft_chip_reset(struct ath10k *ar)
-+{
-+	ath10k_pci_irq_disable(ar);
-+	return ath10k_pci_qca99x0_chip_reset(ar);
-+}
-+
- static int ath10k_pci_safe_chip_reset(struct ath10k *ar)
- {
--	if (QCA_REV_988X(ar) || QCA_REV_6174(ar)) {
--		return ath10k_pci_warm_reset(ar);
--	} else if (QCA_REV_99X0(ar)) {
--		ath10k_pci_irq_disable(ar);
--		return ath10k_pci_qca99x0_chip_reset(ar);
--	} else {
-+	struct ath10k_pci *ar_pci = ath10k_pci_priv(ar);
-+
-+	if (!ar_pci->pci_soft_reset)
- 		return -ENOTSUPP;
--	}
-+
-+	return ar_pci->pci_soft_reset(ar);
- }
- 
- static int ath10k_pci_qca988x_chip_reset(struct ath10k *ar)
-@@ -2437,16 +2441,12 @@ static int ath10k_pci_qca99x0_chip_reset(struct ath10k *ar)
- 
- static int ath10k_pci_chip_reset(struct ath10k *ar)
- {
--	if (QCA_REV_988X(ar))
--		return ath10k_pci_qca988x_chip_reset(ar);
--	else if (QCA_REV_6174(ar))
--		return ath10k_pci_qca6174_chip_reset(ar);
--	else if (QCA_REV_9377(ar))
--		return ath10k_pci_qca6174_chip_reset(ar);
--	else if (QCA_REV_99X0(ar))
--		return ath10k_pci_qca99x0_chip_reset(ar);
--	else
-+	struct ath10k_pci *ar_pci = ath10k_pci_priv(ar);
-+
-+	if (WARN_ON(!ar_pci->pci_hard_reset))
- 		return -ENOTSUPP;
-+
-+	return ar_pci->pci_hard_reset(ar);
- }
- 
- static int ath10k_pci_hif_power_up(struct ath10k *ar)
-@@ -2976,24 +2976,34 @@ static int ath10k_pci_probe(struct pci_dev *pdev,
- 	enum ath10k_hw_rev hw_rev;
- 	u32 chip_id;
- 	bool pci_ps;
-+	int (*pci_soft_reset)(struct ath10k *ar);
-+	int (*pci_hard_reset)(struct ath10k *ar);
- 
- 	switch (pci_dev->device) {
- 	case QCA988X_2_0_DEVICE_ID:
- 		hw_rev = ATH10K_HW_QCA988X;
- 		pci_ps = false;
-+		pci_soft_reset = ath10k_pci_warm_reset;
-+		pci_hard_reset = ath10k_pci_qca988x_chip_reset;
- 		break;
- 	case QCA6164_2_1_DEVICE_ID:
- 	case QCA6174_2_1_DEVICE_ID:
- 		hw_rev = ATH10K_HW_QCA6174;
- 		pci_ps = true;
-+		pci_soft_reset = ath10k_pci_warm_reset;
-+		pci_hard_reset = ath10k_pci_qca6174_chip_reset;
- 		break;
- 	case QCA99X0_2_0_DEVICE_ID:
- 		hw_rev = ATH10K_HW_QCA99X0;
- 		pci_ps = false;
-+		pci_soft_reset = ath10k_pci_qca99x0_soft_chip_reset;
-+		pci_hard_reset = ath10k_pci_qca99x0_chip_reset;
- 		break;
- 	case QCA9377_1_0_DEVICE_ID:
- 		hw_rev = ATH10K_HW_QCA9377;
- 		pci_ps = true;
-+		pci_soft_reset = NULL;
-+		pci_hard_reset = ath10k_pci_qca6174_chip_reset;
- 		break;
- 	default:
- 		WARN_ON(1);
-@@ -3018,6 +3028,8 @@ static int ath10k_pci_probe(struct pci_dev *pdev,
- 	ar->dev_id = pci_dev->device;
- 	ar_pci->pci_ps = pci_ps;
- 	ar_pci->bus_ops = &ath10k_pci_bus_ops;
-+	ar_pci->pci_soft_reset = pci_soft_reset;
-+	ar_pci->pci_hard_reset = pci_hard_reset;
- 
- 	ar->id.vendor = pdev->vendor;
- 	ar->id.device = pdev->device;
-diff --git a/drivers/net/wireless/ath/ath10k/pci.h b/drivers/net/wireless/ath/ath10k/pci.h
-index 959dc32..6eca1df 100644
---- a/drivers/net/wireless/ath/ath10k/pci.h
-+++ b/drivers/net/wireless/ath/ath10k/pci.h
-@@ -234,6 +234,12 @@ struct ath10k_pci {
- 
- 	const struct ath10k_bus_ops *bus_ops;
- 
-+	/* Chip specific pci reset routine used to do a safe reset */
-+	int (*pci_soft_reset)(struct ath10k *ar);
-+
-+	/* Chip specific pci full reset function */
-+	int (*pci_hard_reset)(struct ath10k *ar);
-+
- 	/* Keep this entry in the last, memory for struct ath10k_ahb is
- 	 * allocated (ahb support enabled case) in the continuation of
- 	 * this struct.
--- 
-cgit v0.12
-
diff --git a/package/kernel/mac80211/patches/950-3-4-ath10k-Define-rx_ppdu_end-for-QCA9984.patch b/package/kernel/mac80211/patches/950-3-4-ath10k-Define-rx_ppdu_end-for-QCA9984.patch
deleted file mode 100644
index 7837e0d..0000000
--- a/package/kernel/mac80211/patches/950-3-4-ath10k-Define-rx_ppdu_end-for-QCA9984.patch
+++ /dev/null
@@ -1,89 +0,0 @@
-From acc6b5593eee9386b209dd29da1e4bdbba99cf9a Mon Sep 17 00:00:00 2001
-From: Vasanthakumar Thiagarajan <vthiagar@qti.qualcomm.com>
-Date: Mon, 23 May 2016 23:12:44 +0300
-Subject: ath10k: define rx_ppdu_end for QCA9984
-
-QCA9984 Rx descriptor has two 32-bit words of location information
-when compared to one 32-bit word in QCA99X0. To handle this difference in
-rx descriptor ppdu_end, define a new ppdu_end for QCA9984 descriptor
-which has the new structure to represent rx_location_info.
-
-Signed-off-by: Vasanthakumar Thiagarajan <vthiagar@qti.qualcomm.com>
-Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>
----
- drivers/net/wireless/ath/ath10k/rx_desc.h | 46 +++++++++++++++++++++++++++++++
- 1 file changed, 46 insertions(+)
-
-diff --git a/drivers/net/wireless/ath/ath10k/rx_desc.h b/drivers/net/wireless/ath/ath10k/rx_desc.h
-index 3e7dfaa..9ceebea 100644
---- a/drivers/net/wireless/ath/ath10k/rx_desc.h
-+++ b/drivers/net/wireless/ath/ath10k/rx_desc.h
-@@ -996,6 +996,41 @@ struct rx_pkt_end {
- 	__le32 phy_timestamp_2;
- } __packed;
- 
-+#define RX_LOCATION_INFO0_RTT_FAC_LEGACY_MASK		0x00003fff
-+#define RX_LOCATION_INFO0_RTT_FAC_LEGACY_LSB		0
-+#define RX_LOCATION_INFO0_RTT_FAC_VHT_MASK		0x1fff8000
-+#define RX_LOCATION_INFO0_RTT_FAC_VHT_LSB		15
-+#define RX_LOCATION_INFO0_RTT_STRONGEST_CHAIN_MASK	0xc0000000
-+#define RX_LOCATION_INFO0_RTT_STRONGEST_CHAIN_LSB	30
-+#define RX_LOCATION_INFO0_RTT_FAC_LEGACY_STATUS		BIT(14)
-+#define RX_LOCATION_INFO0_RTT_FAC_VHT_STATUS		BIT(29)
-+
-+#define RX_LOCATION_INFO1_RTT_PREAMBLE_TYPE_MASK	0x0000000c
-+#define RX_LOCATION_INFO1_RTT_PREAMBLE_TYPE_LSB		2
-+#define RX_LOCATION_INFO1_PKT_BW_MASK			0x00000030
-+#define RX_LOCATION_INFO1_PKT_BW_LSB			4
-+#define RX_LOCATION_INFO1_SKIP_P_SKIP_BTCF_MASK		0x0000ff00
-+#define RX_LOCATION_INFO1_SKIP_P_SKIP_BTCF_LSB		8
-+#define RX_LOCATION_INFO1_RTT_MSC_RATE_MASK		0x000f0000
-+#define RX_LOCATION_INFO1_RTT_MSC_RATE_LSB		16
-+#define RX_LOCATION_INFO1_RTT_PBD_LEG_BW_MASK		0x00300000
-+#define RX_LOCATION_INFO1_RTT_PBD_LEG_BW_LSB		20
-+#define RX_LOCATION_INFO1_TIMING_BACKOFF_MASK		0x07c00000
-+#define RX_LOCATION_INFO1_TIMING_BACKOFF_LSB		22
-+#define RX_LOCATION_INFO1_RTT_TX_FRAME_PHASE_MASK	0x18000000
-+#define RX_LOCATION_INFO1_RTT_TX_FRAME_PHASE_LSB	27
-+#define RX_LOCATION_INFO1_RTT_CFR_STATUS		BIT(0)
-+#define RX_LOCATION_INFO1_RTT_CIR_STATUS		BIT(1)
-+#define RX_LOCATION_INFO1_RTT_GI_TYPE			BIT(7)
-+#define RX_LOCATION_INFO1_RTT_MAC_PHY_PHASE		BIT(29)
-+#define RX_LOCATION_INFO1_RTT_TX_DATA_START_X_PHASE	BIT(30)
-+#define RX_LOCATION_INFO1_RX_LOCATION_VALID		BIT(31)
-+
-+struct rx_location_info {
-+	__le32 rx_location_info0; /* %RX_LOCATION_INFO0_ */
-+	__le32 rx_location_info1; /* %RX_LOCATION_INFO1_ */
-+} __packed;
-+
- enum rx_phy_ppdu_end_info0 {
- 	RX_PHY_PPDU_END_INFO0_ERR_RADAR           = BIT(2),
- 	RX_PHY_PPDU_END_INFO0_ERR_RX_ABORT        = BIT(3),
-@@ -1074,12 +1109,23 @@ struct rx_ppdu_end_qca99x0 {
- 	__le16 info1; /* %RX_PPDU_END_INFO1_ */
- } __packed;
- 
-+struct rx_ppdu_end_qca9984 {
-+	struct rx_pkt_end rx_pkt_end;
-+	struct rx_location_info rx_location_info;
-+	struct rx_phy_ppdu_end rx_phy_ppdu_end;
-+	__le32 rx_timing_offset; /* %RX_PPDU_END_RX_TIMING_OFFSET_ */
-+	__le32 rx_info; /* %RX_PPDU_END_RX_INFO_ */
-+	__le16 bb_length;
-+	__le16 info1; /* %RX_PPDU_END_INFO1_ */
-+} __packed;
-+
- struct rx_ppdu_end {
- 	struct rx_ppdu_end_common common;
- 	union {
- 		struct rx_ppdu_end_qca988x qca988x;
- 		struct rx_ppdu_end_qca6174 qca6174;
- 		struct rx_ppdu_end_qca99x0 qca99x0;
-+		struct rx_ppdu_end_qca9984 qca9984;
- 	} __packed;
- } __packed;
- 
--- 
-cgit v0.12
-
diff --git a/package/kernel/mac80211/patches/950-4-4-ath10k-Enable-support-for-QCA9984.patch b/package/kernel/mac80211/patches/950-4-4-ath10k-Enable-support-for-QCA9984.patch
deleted file mode 100644
index 3a52900..0000000
--- a/package/kernel/mac80211/patches/950-4-4-ath10k-Enable-support-for-QCA9984.patch
+++ /dev/null
@@ -1,171 +0,0 @@
-From 651b4cdcf97e75f6346784b75ca7bf3c85187143 Mon Sep 17 00:00:00 2001
-From: Vasanthakumar Thiagarajan <vthiagar@qti.qualcomm.com>
-Date: Mon, 23 May 2016 23:12:45 +0300
-Subject: ath10k: enable support for QCA9984
-
-QCA9984 shares the same configuration with QCA99X0.
-
-Signed-off-by: Vasanthakumar Thiagarajan <vthiagar@qti.qualcomm.com>
-Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>
----
- drivers/net/wireless/ath/ath10k/core.c | 23 +++++++++++++++++++++++
- drivers/net/wireless/ath/ath10k/hw.h   | 11 +++++++++++
- drivers/net/wireless/ath/ath10k/pci.c  | 14 ++++++++++++++
- 3 files changed, 48 insertions(+)
-
-diff --git a/drivers/net/wireless/ath/ath10k/core.c b/drivers/net/wireless/ath/ath10k/core.c
-index 49af624..a003980 100644
---- a/drivers/net/wireless/ath/ath10k/core.c
-+++ b/drivers/net/wireless/ath/ath10k/core.c
-@@ -163,6 +163,28 @@ static const struct ath10k_hw_params ath10k_hw_params_list[] = {
- 		},
- 	},
- 	{
-+		.id = QCA9984_HW_1_0_DEV_VERSION,
-+		.dev_id = QCA9984_1_0_DEVICE_ID,
-+		.name = "qca9984/qca9994 hw1.0",
-+		.patch_load_addr = QCA9984_HW_1_0_PATCH_LOAD_ADDR,
-+		.uart_pin = 7,
-+		.otp_exe_param = 0x00000700,
-+		.continuous_frag_desc = true,
-+		.channel_counters_freq_hz = 150000,
-+		.max_probe_resp_desc_thres = 24,
-+		.hw_4addr_pad = ATH10K_HW_4ADDR_PAD_BEFORE,
-+		.tx_chain_mask = 0xf,
-+		.rx_chain_mask = 0xf,
-+		.max_spatial_stream = 4,
-+		.cal_data_len = 12064,
-+		.fw = {
-+			.dir = QCA9984_HW_1_0_FW_DIR,
-+			.board = QCA9984_HW_1_0_BOARD_DATA_FILE,
-+			.board_size = QCA99X0_BOARD_DATA_SZ,
-+			.board_ext_size = QCA99X0_BOARD_EXT_DATA_SZ,
-+		},
-+	},
-+	{
- 		.id = QCA9377_HW_1_0_DEV_VERSION,
- 		.dev_id = QCA9377_1_0_DEVICE_ID,
- 		.name = "qca9377 hw1.0",
-@@ -2071,6 +2093,7 @@ struct ath10k *ath10k_core_create(size_t priv_size, struct device *dev,
- 		ar->hw_values = &qca6174_values;
- 		break;
- 	case ATH10K_HW_QCA99X0:
-+	case ATH10K_HW_QCA9984:
- 		ar->regs = &qca99x0_regs;
- 		ar->hw_values = &qca99x0_values;
- 		break;
-diff --git a/drivers/net/wireless/ath/ath10k/hw.h b/drivers/net/wireless/ath/ath10k/hw.h
-index aedd898..f41c91c 100644
---- a/drivers/net/wireless/ath/ath10k/hw.h
-+++ b/drivers/net/wireless/ath/ath10k/hw.h
-@@ -26,6 +26,7 @@
- #define QCA6164_2_1_DEVICE_ID   (0x0041)
- #define QCA6174_2_1_DEVICE_ID   (0x003e)
- #define QCA99X0_2_0_DEVICE_ID   (0x0040)
-+#define QCA9984_1_0_DEVICE_ID	(0x0046)
- #define QCA9377_1_0_DEVICE_ID   (0x0042)
- 
- /* QCA988X 1.0 definitions (unsupported) */
-@@ -91,6 +92,14 @@ enum qca9377_chip_id_rev {
- #define QCA99X0_HW_2_0_BOARD_DATA_FILE "board.bin"
- #define QCA99X0_HW_2_0_PATCH_LOAD_ADDR	0x1234
- 
-+/* QCA9984 1.0 defines */
-+#define QCA9984_HW_1_0_DEV_VERSION	0x1000000
-+#define QCA9984_HW_DEV_TYPE		0xa
-+#define QCA9984_HW_1_0_CHIP_ID_REV	0x0
-+#define QCA9984_HW_1_0_FW_DIR		ATH10K_FW_DIR "/QCA9984/hw1.0"
-+#define QCA9984_HW_1_0_BOARD_DATA_FILE "board.bin"
-+#define QCA9984_HW_1_0_PATCH_LOAD_ADDR	0x1234
-+
- /* QCA9377 1.0 definitions */
- #define QCA9377_HW_1_0_FW_DIR          ATH10K_FW_DIR "/QCA9377/hw1.0"
- #define QCA9377_HW_1_0_BOARD_DATA_FILE "board.bin"
-@@ -193,6 +202,7 @@ enum ath10k_hw_rev {
- 	ATH10K_HW_QCA988X,
- 	ATH10K_HW_QCA6174,
- 	ATH10K_HW_QCA99X0,
-+	ATH10K_HW_QCA9984,
- 	ATH10K_HW_QCA9377,
- 	ATH10K_HW_QCA4019,
- };
-@@ -249,6 +259,7 @@ void ath10k_hw_fill_survey_time(struct ath10k *ar, struct survey_info *survey,
- #define QCA_REV_988X(ar) ((ar)->hw_rev == ATH10K_HW_QCA988X)
- #define QCA_REV_6174(ar) ((ar)->hw_rev == ATH10K_HW_QCA6174)
- #define QCA_REV_99X0(ar) ((ar)->hw_rev == ATH10K_HW_QCA99X0)
-+#define QCA_REV_9984(ar) ((ar)->hw_rev == ATH10K_HW_QCA9984)
- #define QCA_REV_9377(ar) ((ar)->hw_rev == ATH10K_HW_QCA9377)
- #define QCA_REV_40XX(ar) ((ar)->hw_rev == ATH10K_HW_QCA4019)
- 
-diff --git a/drivers/net/wireless/ath/ath10k/pci.c b/drivers/net/wireless/ath/ath10k/pci.c
-index 81d6bad..8e8e1eb 100644
---- a/drivers/net/wireless/ath/ath10k/pci.c
-+++ b/drivers/net/wireless/ath/ath10k/pci.c
-@@ -56,6 +56,7 @@ static const struct pci_device_id ath10k_pci_id_table[] = {
- 	{ PCI_VDEVICE(ATHEROS, QCA6164_2_1_DEVICE_ID) }, /* PCI-E QCA6164 V2.1 */
- 	{ PCI_VDEVICE(ATHEROS, QCA6174_2_1_DEVICE_ID) }, /* PCI-E QCA6174 V2.1 */
- 	{ PCI_VDEVICE(ATHEROS, QCA99X0_2_0_DEVICE_ID) }, /* PCI-E QCA99X0 V2 */
-+	{ PCI_VDEVICE(ATHEROS, QCA9984_1_0_DEVICE_ID) }, /* PCI-E QCA9984 V1 */
- 	{ PCI_VDEVICE(ATHEROS, QCA9377_1_0_DEVICE_ID) }, /* PCI-E QCA9377 V1 */
- 	{0}
- };
-@@ -81,8 +82,11 @@ static const struct ath10k_pci_supp_chip ath10k_pci_supp_chips[] = {
- 
- 	{ QCA99X0_2_0_DEVICE_ID, QCA99X0_HW_2_0_CHIP_ID_REV },
- 
-+	{ QCA9984_1_0_DEVICE_ID, QCA9984_HW_1_0_CHIP_ID_REV },
-+
- 	{ QCA9377_1_0_DEVICE_ID, QCA9377_HW_1_0_CHIP_ID_REV },
- 	{ QCA9377_1_0_DEVICE_ID, QCA9377_HW_1_1_CHIP_ID_REV },
-+
- };
- 
- static void ath10k_pci_buffer_cleanup(struct ath10k *ar);
-@@ -844,6 +848,7 @@ static u32 ath10k_pci_targ_cpu_to_ce_addr(struct ath10k *ar, u32 addr)
- 		       0x7ff) << 21;
- 		break;
- 	case ATH10K_HW_QCA99X0:
-+	case ATH10K_HW_QCA9984:
- 	case ATH10K_HW_QCA4019:
- 		val = ath10k_pci_read32(ar, PCIE_BAR_REG_ADDRESS);
- 		break;
-@@ -1569,6 +1574,7 @@ static void ath10k_pci_irq_msi_fw_mask(struct ath10k *ar)
- 				   CORE_CTRL_ADDRESS, val);
- 		break;
- 	case ATH10K_HW_QCA99X0:
-+	case ATH10K_HW_QCA9984:
- 	case ATH10K_HW_QCA4019:
- 		/* TODO: Find appropriate register configuration for QCA99X0
- 		 *  to mask irq/MSI.
-@@ -1592,6 +1598,7 @@ static void ath10k_pci_irq_msi_fw_unmask(struct ath10k *ar)
- 				   CORE_CTRL_ADDRESS, val);
- 		break;
- 	case ATH10K_HW_QCA99X0:
-+	case ATH10K_HW_QCA9984:
- 	case ATH10K_HW_QCA4019:
- 		/* TODO: Find appropriate register configuration for QCA99X0
- 		 *  to unmask irq/MSI.
-@@ -1932,6 +1939,7 @@ static int ath10k_pci_get_num_banks(struct ath10k *ar)
- 	switch (ar_pci->pdev->device) {
- 	case QCA988X_2_0_DEVICE_ID:
- 	case QCA99X0_2_0_DEVICE_ID:
-+	case QCA9984_1_0_DEVICE_ID:
- 		return 1;
- 	case QCA6164_2_1_DEVICE_ID:
- 	case QCA6174_2_1_DEVICE_ID:
-@@ -2999,6 +3007,12 @@ static int ath10k_pci_probe(struct pci_dev *pdev,
- 		pci_soft_reset = ath10k_pci_qca99x0_soft_chip_reset;
- 		pci_hard_reset = ath10k_pci_qca99x0_chip_reset;
- 		break;
-+	case QCA9984_1_0_DEVICE_ID:
-+		hw_rev = ATH10K_HW_QCA9984;
-+		pci_ps = false;
-+		pci_soft_reset = ath10k_pci_qca99x0_soft_chip_reset;
-+		pci_hard_reset = ath10k_pci_qca99x0_chip_reset;
-+		break;
- 	case QCA9377_1_0_DEVICE_ID:
- 		hw_rev = ATH10K_HW_QCA9377;
- 		pci_ps = true;
--- 
-cgit v0.12
-
diff --git a/package/kernel/mac80211/patches/951-ath10k-fix-get-rx_status-from-htt-context.patch b/package/kernel/mac80211/patches/951-ath10k-fix-get-rx_status-from-htt-context.patch
deleted file mode 100644
index f4e874e..0000000
--- a/package/kernel/mac80211/patches/951-ath10k-fix-get-rx_status-from-htt-context.patch
+++ /dev/null
@@ -1,75 +0,0 @@
-From e809ea07e9edefc3678ad0b356a95f0c4c7f27e7 Mon Sep 17 00:00:00 2001
-From: Ashok Raj Nagarajan <arnagara@qti.qualcomm.com>
-Date: Tue, 26 Jul 2016 22:15:52 +0530
-Subject: ath10k: fix get rx_status from htt context
-
-On handling amsdu on rx path, get the rx_status from htt context. Without this
-fix, we are seeing warnings when running DBDC traffic like this.
-
-WARNING: CPU: 0 PID: 0 at net/mac80211/rx.c:4105 ieee80211_rx_napi+0x88/0x7d8 [mac80211]()
-
-[ 1715.878248] CPU: 0 PID: 0 Comm: swapper/0 Tainted: G W 3.18.21 #1
-[ 1715.878273] [<c001d3f4>] (unwind_backtrace) from [<c001a4b0>] (show_stack+0x10/0x14)
-[ 1715.878293] [<c001a4b0>] (show_stack) from [<c01bee64>] (dump_stack+0x70/0xbc)
-[ 1715.878315] [<c01bee64>] (dump_stack) from [<c002a61c>] (warn_slowpath_common+0x64/0x88)
-[ 1715.878339] [<c002a61c>] (warn_slowpath_common) from [<c002a6d0>] (warn_slowpath_null+0x18/0x20)
-[ 1715.878395] [<c002a6d0>] (warn_slowpath_null) from [<bf4caa98>] (ieee80211_rx_napi+0x88/0x7d8 [mac80211])
-[ 1715.878474] [<bf4caa98>] (ieee80211_rx_napi [mac80211]) from [<bf568658>] (ath10k_htt_t2h_msg_handler+0xb48/0xbfc [ath10k_core])
-[ 1715.878535] [<bf568658>] (ath10k_htt_t2h_msg_handler [ath10k_core]) from [<bf568708>] (ath10k_htt_t2h_msg_handler+0xbf8/0xbfc [ath10k_core])
-[ 1715.878597] [<bf568708>] (ath10k_htt_t2h_msg_handler [ath10k_core]) from [<bf569160>] (ath10k_htt_txrx_compl_task+0xa54/0x1170 [ath10k_core])
-[ 1715.878639] [<bf569160>] (ath10k_htt_txrx_compl_task [ath10k_core]) from [<c002db14>] (tasklet_action+0xb4/0x130)
-[ 1715.878659] [<c002db14>] (tasklet_action) from [<c002d110>] (__do_softirq+0xe0/0x210)
-[ 1715.878678] [<c002d110>] (__do_softirq) from [<c002d4b4>] (irq_exit+0x84/0xe0)
-[ 1715.878700] [<c002d4b4>] (irq_exit) from [<c005a544>] (__handle_domain_irq+0x98/0xd0)
-[ 1715.878722] [<c005a544>] (__handle_domain_irq) from [<c00085f4>] (gic_handle_irq+0x38/0x5c)
-[ 1715.878741] [<c00085f4>] (gic_handle_irq) from [<c0009680>] (__irq_svc+0x40/0x74)
-[ 1715.878753] Exception stack(0xc05f9f50 to 0xc05f9f98)
-[ 1715.878767] 9f40: ffffffed 00000000 00399e1e c000a220
-[ 1715.878786] 9f60: 00000000 c05f6780 c05f8000 00000000 c05f5db8 ffffffed c05f8000 c04d1980
-[ 1715.878802] 9f80: 00000000 c05f9f98 c0018110 c0018114 60000013 ffffffff
-[ 1715.878822] [<c0009680>] (__irq_svc) from [<c0018114>] (arch_cpu_idle+0x2c/0x50)
-[ 1715.878844] [<c0018114>] (arch_cpu_idle) from [<c00530d4>] (cpu_startup_entry+0x108/0x234)
-[ 1715.878866] [<c00530d4>] (cpu_startup_entry) from [<c05c7be0>] (start_kernel+0x33c/0x3b8)
-[ 1715.878879] ---[ end trace 6d5e1cc0fef8ed6a ]---
-[ 1715.878899] ------------[ cut here ]------------
-
-Fixes: 18235664e7f9 ("ath10k: cleanup amsdu processing for rx indication")
-Signed-off-by: Ashok Raj Nagarajan <arnagara@qti.qualcomm.com>
-Patchwork-Id: 9248457
-Signed-off-by: Kalle Valo <kvalo@qca.qualcomm.com>
----
- drivers/net/wireless/ath/ath10k/htt_rx.c | 10 +++++-----
- 1 file changed, 5 insertions(+), 5 deletions(-)
-
-diff --git a/drivers/net/wireless/ath/ath10k/htt_rx.c b/drivers/net/wireless/ath/ath10k/htt_rx.c
-index 78db5d6..24c8d65 100644
---- a/drivers/net/wireless/ath/ath10k/htt_rx.c
-+++ b/drivers/net/wireless/ath/ath10k/htt_rx.c
-@@ -1525,7 +1525,7 @@ static void ath10k_htt_rx_h_filter(struct ath10k *ar,
- static int ath10k_htt_rx_handle_amsdu(struct ath10k_htt *htt)
- {
- 	struct ath10k *ar = htt->ar;
--	static struct ieee80211_rx_status rx_status;
-+	struct ieee80211_rx_status *rx_status = &htt->rx_status;
- 	struct sk_buff_head amsdu;
- 	int ret;
- 
-@@ -1549,11 +1549,11 @@ static int ath10k_htt_rx_handle_amsdu(struct ath10k_htt *htt)
- 		return ret;
- 	}
- 
--	ath10k_htt_rx_h_ppdu(ar, &amsdu, &rx_status, 0xffff);
-+	ath10k_htt_rx_h_ppdu(ar, &amsdu, rx_status, 0xffff);
- 	ath10k_htt_rx_h_unchain(ar, &amsdu, ret > 0);
--	ath10k_htt_rx_h_filter(ar, &amsdu, &rx_status);
--	ath10k_htt_rx_h_mpdu(ar, &amsdu, &rx_status);
--	ath10k_htt_rx_h_deliver(ar, &amsdu, &rx_status);
-+	ath10k_htt_rx_h_filter(ar, &amsdu, rx_status);
-+	ath10k_htt_rx_h_mpdu(ar, &amsdu, rx_status);
-+	ath10k_htt_rx_h_deliver(ar, &amsdu, rx_status);
- 
- 	return 0;
- }
--- 
-cgit v0.12
-
-- 
2.1.4

